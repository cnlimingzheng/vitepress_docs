import{_ as i,c as a,o as t,aj as n,bL as e}from"./chunks/framework.C1xWm9jt.js";const E=JSON.parse('{"title":"React 面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview-questions/react.md","filePath":"interview-questions/react.md"}'),l={name:"interview-questions/react.md"};function h(k,s,r,p,d,o){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="react-面试题" tabindex="-1">React 面试题 <a class="header-anchor" href="#react-面试题" aria-label="Permalink to “React 面试题”">​</a></h1><h2 id="react18有哪些更新" tabindex="-1">React18有哪些更新？ <a class="header-anchor" href="#react18有哪些更新" aria-label="Permalink to “React18有哪些更新？”">​</a></h2><p>React 18 的核心更新围绕 <strong>并发渲染（Concurrent Rendering）</strong> 展开，带来性能、开发体验和 API 一致性三大提升。主要更新如下：</p><hr><h3 id="一、自动批处理-automatic-batching" tabindex="-1">一、<strong>自动批处理（Automatic Batching）</strong> <a class="header-anchor" href="#一、自动批处理-automatic-batching" aria-label="Permalink to “一、自动批处理（Automatic Batching）”">​</a></h3><ul><li><strong>问题</strong>：React 17 及之前，只有 React 事件中的多个 <code>setState</code> 会被合并（批处理），而 <code>setTimeout</code>、Promise 等异步回调中不会。</li><li><strong>改进</strong>：<strong>所有场景下的状态更新都会自动批处理</strong>，减少不必要的重渲染。<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 18 中只触发一次渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul><hr><h3 id="二、新根-api-new-root-api" tabindex="-1">二、<strong>新根 API（New Root API）</strong> <a class="header-anchor" href="#二、新根-api-new-root-api" aria-label="Permalink to “二、新根 API（New Root API）”">​</a></h3><ul><li><strong>旧</strong>：<code>ReactDOM.render(&lt;App /&gt;, root)</code></li><li><strong>新</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createRoot } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-dom/client&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRoot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;);</span></span></code></pre></div></li><li><strong>意义</strong>：为并发特性（如 <code>startTransition</code>、<code>useDeferredValue</code>）提供运行时支持。</li></ul><hr><h3 id="三、并发特性-concurrent-features" tabindex="-1">三、<strong>并发特性（Concurrent Features）</strong> <a class="header-anchor" href="#三、并发特性-concurrent-features" aria-label="Permalink to “三、并发特性（Concurrent Features）”">​</a></h3><blockquote><p>并发不是“并行”，而是 <strong>可中断、可恢复、带优先级的渲染机制</strong>。</p></blockquote><h4 id="_1-starttransition-usetransition" tabindex="-1">1. <strong><code>startTransition</code> / <code>useTransition</code></strong> <a class="header-anchor" href="#_1-starttransition-usetransition" aria-label="Permalink to “1. startTransition / useTransition”">​</a></h4><ul><li>标记<strong>非紧急更新</strong>（如搜索、切换 Tab），避免阻塞用户交互。<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isPending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setSearchQuery</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 低优先级更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul><h4 id="_2-usedeferredvalue" tabindex="-1">2. <strong><code>useDeferredValue</code></strong> <a class="header-anchor" href="#_2-usedeferredvalue" aria-label="Permalink to “2. useDeferredValue”">​</a></h4><ul><li>延迟渲染某部分 UI（类似防抖，但由 React 调度）：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> deferredQuery</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useDeferredValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(query);</span></span></code></pre></div></li></ul><h4 id="_3-suspense-支持-ssr-和更多场景" tabindex="-1">3. <strong><code>&lt;Suspense&gt;</code> 支持 SSR 和更多场景</strong> <a class="header-anchor" href="#_3-suspense-支持-ssr-和更多场景" aria-label="Permalink to “3. &lt;Suspense&gt; 支持 SSR 和更多场景”">​</a></h4><ul><li>不再仅限于 <code>lazy</code> + <code>Suspense</code>，可用于数据请求、过渡动画等。</li></ul><hr><h3 id="四、strict-mode-改进" tabindex="-1">四、<strong>Strict Mode 改进</strong> <a class="header-anchor" href="#四、strict-mode-改进" aria-label="Permalink to “四、Strict Mode 改进”">​</a></h3><ul><li><strong>移除双重渲染副作用</strong>：<br> React 18 的 Strict Mode <strong>不再双重调用 <code>useEffect</code> 的 cleanup 和 setup</strong>（仅在开发环境模拟卸载/重装组件本身）。</li><li>目的：帮助开发者编写更健壮的可复用组件。</li></ul><hr><h3 id="五、新的-hook" tabindex="-1">五、<strong>新的 Hook</strong> <a class="header-anchor" href="#五、新的-hook" aria-label="Permalink to “五、新的 Hook”">​</a></h3><ul><li><code>useId()</code>：生成稳定、SSR 安全的唯一 ID（用于 label/for 关联）</li><li><code>useSyncExternalStore</code>：集成外部状态库（如 Redux）的推荐方式</li><li><code>useInsertionEffect</code>：CSS-in-JS 库专用，确保样式在 DOM 变更前注入</li></ul><hr><h3 id="六、其他改进" tabindex="-1">六、<strong>其他改进</strong> <a class="header-anchor" href="#六、其他改进" aria-label="Permalink to “六、其他改进”">​</a></h3><ul><li>更好的 TypeScript 支持</li><li>移除部分过时 API（如 <code>ReactDOM.render</code> 将在未来废弃）</li><li>支持现代浏览器（IE11 不再支持）</li></ul><hr><p>✅ <strong>总结</strong>：<br> React 18 不是颠覆性重构，而是<strong>通过并发能力为未来打基础</strong>。它让应用更流畅、更新更智能，并统一了状态更新行为。升级成本低，收益高，<strong>强烈建议迁移</strong>。</p><h2 id="jsx是什么-它和js有什么区别" tabindex="-1">JSX是什么，它和JS有什么区别 <a class="header-anchor" href="#jsx是什么-它和js有什么区别" aria-label="Permalink to “JSX是什么，它和JS有什么区别”">​</a></h2><h3 id="jsx-是什么" tabindex="-1"><strong>JSX 是什么？</strong> <a class="header-anchor" href="#jsx-是什么" aria-label="Permalink to “JSX 是什么？”">​</a></h3><p>JSX（JavaScript XML）是 <strong>JavaScript 的语法扩展</strong>，用于在 JS 代码中<strong>声明式地描述 UI 结构</strong>。它看起来像 HTML，但最终会被编译成普通的 JavaScript 函数调用。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, {name}!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后（React.createElement）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><blockquote><p>✅ <strong>核心本质</strong>：JSX 是 <code>React.createElement()</code> 的语法糖（不仅限于 React，也可用于 Vue、Solid 等）。</p></blockquote><hr><h3 id="jsx-与-js-的区别" tabindex="-1"><strong>JSX 与 JS 的区别</strong> <a class="header-anchor" href="#jsx-与-js-的区别" aria-label="Permalink to “JSX 与 JS 的区别”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>JavaScript (JS)</th><th>JSX</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>通用编程语言</td><td><strong>专用于描述 UI 结构</strong></td></tr><tr><td><strong>语法</strong></td><td>标准 JS 语法</td><td>类 HTML 语法（如 <code>&lt;div&gt;</code>、<code>{}</code> 插值）</td></tr><tr><td><strong>执行方式</strong></td><td>浏览器/Node 直接运行</td><td><strong>必须经编译</strong>（Babel、TS 等）转为 JS</td></tr><tr><td><strong>表达式</strong></td><td>直接写逻辑</td><td>在 <code>{}</code> 中嵌入 JS 表达式（如 <code>{user.name}</code>）</td></tr><tr><td><strong>元素创建</strong></td><td>手动调用 <code>document.createElement</code> 或框架 API</td><td>声明式写标签，由编译器转为函数调用</td></tr></tbody></table><hr><h3 id="关键规则" tabindex="-1"><strong>关键规则</strong> <a class="header-anchor" href="#关键规则" aria-label="Permalink to “关键规则”">​</a></h3><ol><li><strong>必须引入 React（React 17+ 可省略）</strong><br> （因 JSX 编译依赖 <code>React.createElement</code>）</li><li><strong>只能返回一个根元素</strong><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (&lt;&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/&gt;);</span></span></code></pre></div></li><li><strong>属性命名用驼峰</strong>（如 <code>className</code> 而非 <code>class</code>）</li><li><strong>自闭合标签必须闭合</strong>：<code>&lt;img /&gt;</code> 而非 <code>&lt;img&gt;</code></li></ol><hr><h3 id="为什么用-jsx" tabindex="-1"><strong>为什么用 JSX？</strong> <a class="header-anchor" href="#为什么用-jsx" aria-label="Permalink to “为什么用 JSX？”">​</a></h3><ul><li><strong>直观</strong>：结构清晰，接近 HTML</li><li><strong>高效</strong>：编译时静态分析优化</li><li><strong>安全</strong>：自动转义防止 XSS（<code>{userInput}</code> 会被转义）</li></ul><hr><p>✅ <strong>一句话总结</strong>：<br><strong>JSX 不是字符串，也不是 HTML，而是编译成 JS 函数调用的语法糖，让 UI 代码更简洁、可读、可维护。</strong></p><h2 id="简述react的生命周期" tabindex="-1">简述React的生命周期 <a class="header-anchor" href="#简述react的生命周期" aria-label="Permalink to “简述React的生命周期”">​</a></h2><p>React 的生命周期分为 <strong>挂载（Mounting）</strong>、<strong>更新（Updating）</strong> 和 <strong>卸载（Unmounting）</strong> 三个阶段。<strong>React 16.3+ 引入新 API，17+ 废弃部分旧钩子，函数组件用 Hooks 替代</strong>。</p><hr><h3 id="一、类组件生命周期-react-16-3-推荐写法" tabindex="-1">一、<strong>类组件生命周期（React 16.3+ 推荐写法）</strong> <a class="header-anchor" href="#一、类组件生命周期-react-16-3-推荐写法" aria-label="Permalink to “一、类组件生命周期（React 16.3+ 推荐写法）”">​</a></h3><h4 id="✅-挂载阶段" tabindex="-1">✅ <strong>挂载阶段</strong> <a class="header-anchor" href="#✅-挂载阶段" aria-label="Permalink to “✅ 挂载阶段”">​</a></h4><ol><li><code>constructor()</code>：初始化 state、绑定方法</li><li><code>static getDerivedStateFromProps(props, state)</code>：<strong>根据 props 派生 state</strong>（极少用）</li><li><code>render()</code>：返回 JSX（纯函数，无副作用）</li><li><code>componentDidMount()</code>：<strong>发起请求、订阅、操作 DOM</strong>（仅客户端执行）</li></ol><h4 id="✅-更新阶段" tabindex="-1">✅ <strong>更新阶段</strong> <a class="header-anchor" href="#✅-更新阶段" aria-label="Permalink to “✅ 更新阶段”">​</a></h4><ol><li><code>static getDerivedStateFromProps()</code></li><li><code>shouldComponentUpdate(nextProps, nextState)</code>：<strong>性能优化</strong>，返回 <code>false</code> 阻止渲染</li><li><code>render()</code></li><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>：<strong>捕获 DOM 更新前的状态</strong>（如滚动位置）</li><li><code>componentDidUpdate(prevProps, prevState, snapshot)</code>：<strong>处理更新后的副作用</strong>（如发请求）</li></ol><h4 id="✅-卸载阶段" tabindex="-1">✅ <strong>卸载阶段</strong> <a class="header-anchor" href="#✅-卸载阶段" aria-label="Permalink to “✅ 卸载阶段”">​</a></h4><ul><li><code>componentWillUnmount()</code>：<strong>清理定时器、取消订阅、移除监听</strong></li></ul><blockquote><p>⚠️ <strong>已废弃</strong>（不推荐使用）：<br><code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code></p></blockquote><hr><h3 id="二、函数组件-用-hooks-替代" tabindex="-1">二、<strong>函数组件：用 Hooks 替代</strong> <a class="header-anchor" href="#二、函数组件-用-hooks-替代" aria-label="Permalink to “二、函数组件：用 Hooks 替代”">​</a></h3><ul><li><code>useEffect(() =&gt; { ... }, [])</code> ≈ <code>componentDidMount</code> + <code>componentWillUnmount</code></li><li><code>useEffect(() =&gt; { ... })</code> ≈ <code>componentDidUpdate</code></li><li><code>useMemo</code> / <code>useCallback</code> ≈ <code>shouldComponentUpdate</code> 优化</li><li>无直接等价于 <code>getSnapshotBeforeUpdate</code> 的 Hook</li></ul><hr><h3 id="三、关键原则" tabindex="-1">三、<strong>关键原则</strong> <a class="header-anchor" href="#三、关键原则" aria-label="Permalink to “三、关键原则”">​</a></h3><ul><li><strong>避免在 <code>render</code> 中写副作用</strong></li><li><strong>优先用函数组件 + Hooks</strong>（更简洁、逻辑复用强）</li><li><strong>新生命周期更安全</strong>：去除了容易引发 bug 的 <code>will</code> 钩子</li></ul><hr><p>✅ <strong>一句话总结</strong>：<br> React 生命周期是组件从创建到销毁的全过程控制机制，<strong>类组件用新钩子，函数组件用 Hooks</strong>，核心目标是<strong>合理管理副作用与性能</strong>。</p><h2 id="react事件机制和原生dom事件流有什么区别" tabindex="-1">React事件机制和原生DOM事件流有什么区别 <a class="header-anchor" href="#react事件机制和原生dom事件流有什么区别" aria-label="Permalink to “React事件机制和原生DOM事件流有什么区别”">​</a></h2><p>React 的事件机制（<strong>合成事件，SyntheticEvent</strong>）与原生 DOM 事件流有以下核心区别：</p><hr><h3 id="一、事件绑定位置不同" tabindex="-1">一、<strong>事件绑定位置不同</strong> <a class="header-anchor" href="#一、事件绑定位置不同" aria-label="Permalink to “一、事件绑定位置不同”">​</a></h3><ul><li><strong>原生 DOM</strong>：<br> 事件可绑定在<strong>任意元素</strong>上，支持<strong>冒泡（bubble）和捕获（capture）</strong> 阶段。</li><li><strong>React</strong>：<br> 所有事件<strong>委托到 document（React 16）或 root 容器（React 17+）</strong> 上统一处理（事件委托）。</li></ul><blockquote><p>✅ 优势：减少内存占用，避免频繁 add/remove listener。</p></blockquote><hr><h3 id="二、事件对象不同" tabindex="-1">二、<strong>事件对象不同</strong> <a class="header-anchor" href="#二、事件对象不同" aria-label="Permalink to “二、事件对象不同”">​</a></h3><ul><li><strong>原生事件</strong>：浏览器原生 <code>Event</code> 对象。</li><li><strong>React 事件</strong>：<strong>跨浏览器封装的 <code>SyntheticEvent</code></strong> 对象： <ul><li>接口与原生一致（如 <code>stopPropagation()</code>、<code>preventDefault()</code>）</li><li><strong>自动池化（pooling）</strong>：事件回调结束后属性被清空（React 17+ 已移除池化）</li></ul></li></ul><blockquote><p>⚠️ 注意：若需异步访问事件对象，需调用 <code>event.persist()</code>（仅 React 16 及更早版本需要）。</p></blockquote><hr><h3 id="三、事件命名与语法" tabindex="-1">三、<strong>事件命名与语法</strong> <a class="header-anchor" href="#三、事件命名与语法" aria-label="Permalink to “三、事件命名与语法”">​</a></h3><ul><li><strong>命名</strong>：React 使用<strong>驼峰命名</strong>（如 <code>onClick</code>），原生为全小写（<code>onclick</code>）。</li><li><strong>传参</strong>：React 中需使用箭头函数或 <code>bind</code>，不能直接拼接：<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id)}&gt;Click&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误（立即执行）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id)}&gt;Click&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul><hr><h3 id="四、阻止默认行为方式" tabindex="-1">四、<strong>阻止默认行为方式</strong> <a class="header-anchor" href="#四、阻止默认行为方式" aria-label="Permalink to “四、阻止默认行为方式”">​</a></h3><ul><li><strong>原生</strong>：<code>return false</code> 可同时阻止默认 + 冒泡（仅限 onxxx 属性写法）。</li><li><strong>React</strong>：<strong>必须显式调用 <code>preventDefault()</code></strong>，<code>return false</code> 无效。</li></ul><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 必须</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="五、兼容性与一致性" tabindex="-1">五、<strong>兼容性与一致性</strong> <a class="header-anchor" href="#五、兼容性与一致性" aria-label="Permalink to “五、兼容性与一致性”">​</a></h3><ul><li>React 合成事件<strong>抹平浏览器差异</strong>（如 IE 事件 API 不同）。</li><li>所有事件回调都在<strong>React 控制的事务中执行</strong>，确保状态更新一致性。</li></ul><hr><h3 id="六、新增限制" tabindex="-1">六、<strong>新增限制</strong> <a class="header-anchor" href="#六、新增限制" aria-label="Permalink to “六、新增限制”">​</a></h3><ul><li>无法直接使用原生事件 API（如 <code>addEventListener</code>）与 React 事件混用（可能造成顺序混乱）。</li><li>某些原生事件（如 <code>onScroll</code>、<code>onMouseEnter</code>）在 React 中行为略有调整。</li></ul><hr><p>✅ <strong>总结</strong>：<br> React 合成事件 = <strong>事件委托 + 跨浏览器封装 + 统一 API</strong>，提升性能与开发体验，但需注意其与原生事件的隔离性。</p><h2 id="redux工作原理" tabindex="-1">Redux工作原理 <a class="header-anchor" href="#redux工作原理" aria-label="Permalink to “Redux工作原理”">​</a></h2><p>Redux 是一个<strong>集中式状态管理库</strong>，核心思想是：<strong>单一数据源、状态只读、纯函数更新</strong>。其工作原理可概括为 <strong>“Store → Action → Reducer → New State”</strong> 的单向数据流。</p><hr><h3 id="一、三大核心原则" tabindex="-1">一、三大核心原则 <a class="header-anchor" href="#一、三大核心原则" aria-label="Permalink to “一、三大核心原则”">​</a></h3><ol><li><strong>单一数据源（Single Source of Truth）</strong><ul><li>整个应用状态存储在<strong>一个 store 对象</strong>中。</li></ul></li><li><strong>State 是只读的（State is Read-Only）</strong><ul><li>唯一改变 state 的方式是<strong>派发 action</strong>（普通对象）。</li></ul></li><li><strong>使用纯函数修改状态（Changes with Pure Functions）</strong><ul><li>通过 <strong>reducer</strong>（纯函数）接收旧 state 和 action，返回新 state。</li></ul></li></ol><hr><h3 id="二、核心组成部分" tabindex="-1">二、核心组成部分 <a class="header-anchor" href="#二、核心组成部分" aria-label="Permalink to “二、核心组成部分”">​</a></h3><h4 id="_1-store" tabindex="-1">1. <strong>Store</strong> <a class="header-anchor" href="#_1-store" aria-label="Permalink to “1. Store”">​</a></h4><ul><li>由 <code>createStore(reducer)</code> 创建</li><li>提供方法： <ul><li><code>getState()</code>：获取当前状态</li><li><code>dispatch(action)</code>：触发状态更新</li><li><code>subscribe(listener)</code>：监听状态变化</li></ul></li></ul><h4 id="_2-action" tabindex="-1">2. <strong>Action</strong> <a class="header-anchor" href="#_2-action" aria-label="Permalink to “2. Action”">​</a></h4><ul><li>普通 JavaScript 对象，必须有 <code>type</code> 字段</li><li>描述“发生了什么”<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;INCREMENT&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">payload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li></ul><h4 id="_3-reducer" tabindex="-1">3. <strong>Reducer</strong> <a class="header-anchor" href="#_3-reducer" aria-label="Permalink to “3. Reducer”">​</a></h4><ul><li>纯函数：<code>(state, action) =&gt; newState</code></li><li>根据 <code>action.type</code> 决定如何生成新状态</li><li><strong>不能直接修改原 state</strong>，需返回新对象（常用展开运算符或 Immer）</li></ul><hr><h3 id="三、工作流程-单向数据流" tabindex="-1">三、工作流程（单向数据流） <a class="header-anchor" href="#三、工作流程-单向数据流" aria-label="Permalink to “三、工作流程（单向数据流）”">​</a></h3><p><img src="`+e+`" alt="An Image"></p><ol><li>组件调用 <code>store.dispatch(action)</code></li><li>Store 将 <code>action</code> 和当前 <code>state</code> 传给 <code>reducer</code></li><li>Reducer 返回新 <code>state</code></li><li>Store 更新状态，并通知所有订阅者（如 UI 重新渲染）</li></ol><hr><h3 id="四、中间件-middleware" tabindex="-1">四、中间件（Middleware） <a class="header-anchor" href="#四、中间件-middleware" aria-label="Permalink to “四、中间件（Middleware）”">​</a></h3><ul><li>扩展 Redux 功能（如日志、异步处理）</li><li>典型：<code>redux-thunk</code>（支持 dispatch 函数）、<code>redux-saga</code>（基于 generator）</li><li>通过 <code>applyMiddleware</code> 注入</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  reducer,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  applyMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thunk)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><hr><h3 id="五、与-react-集成-react-redux" tabindex="-1">五、与 React 集成（React-Redux） <a class="header-anchor" href="#五、与-react-集成-react-redux" aria-label="Permalink to “五、与 React 集成（React-Redux）”">​</a></h3><ul><li>使用 <code>Provider</code> 注入 store</li><li>组件通过 <code>useSelector</code> 读取状态，<code>useDispatch</code> 派发 action</li></ul><hr><p>✅ <strong>一句话总结</strong>：<br> Redux 通过 <strong>“派发 action → 纯函数计算 → 更新全局状态”</strong> 的严格单向流，实现可预测、可调试的状态管理。适用于<strong>复杂、多组件共享状态</strong>的场景。</p><h2 id="react-router工作原理-react-router-dom有哪些组件" tabindex="-1">React-Router工作原理? react-router-dom有哪些组件 <a class="header-anchor" href="#react-router工作原理-react-router-dom有哪些组件" aria-label="Permalink to “React-Router工作原理? react-router-dom有哪些组件”">​</a></h2><h3 id="react-router-工作原理" tabindex="-1">React Router 工作原理 <a class="header-anchor" href="#react-router-工作原理" aria-label="Permalink to “React Router 工作原理”">​</a></h3><p>React Router 的核心是 <strong>监听 URL 变化 → 匹配路由规则 → 动态渲染对应组件</strong>，实现 SPA（单页应用）的无刷新导航。</p><h4 id="核心机制" tabindex="-1">核心机制： <a class="header-anchor" href="#核心机制" aria-label="Permalink to “核心机制：”">​</a></h4><ol><li><strong>路由模式</strong>： <ul><li><strong><code>BrowserRouter</code></strong>：基于 HTML5 History API（<code>pushState</code>/<code>replaceState</code> + <code>popstate</code> 事件）</li><li><strong><code>HashRouter</code></strong>：基于 URL 的 hash（<code>#</code>）变化 + <code>hashchange</code> 事件</li></ul></li><li><strong>路由匹配</strong>： <ul><li>使用 <code>path-to-regexp</code> 库将路由路径（如 <code>/users/:id</code>）编译为正则表达式</li><li>对当前 URL 进行匹配，提取参数（如 <code>params.id</code>）</li></ul></li><li><strong>动态渲染</strong>： <ul><li>通过 React Context 共享路由状态（location、history 等）</li><li><code>&lt;Route&gt;</code> 组件根据匹配结果决定是否渲染其 <code>element</code>（v6）或 <code>component</code>/<code>render</code>（v5）</li></ul></li></ol><blockquote><p>✅ <strong>关键点</strong>：所有路由组件共享同一个 <code>history</code> 对象，URL 变化时通知所有 <code>&lt;Route&gt;</code> 重新匹配。</p></blockquote><hr><h3 id="react-router-dom-主要组件-以-v6-为主" tabindex="-1">react-router-dom 主要组件（以 v6 为主） <a class="header-anchor" href="#react-router-dom-主要组件-以-v6-为主" aria-label="Permalink to “react-router-dom 主要组件（以 v6 为主）”">​</a></h3><h4 id="_1-路由器-必须包裹整个应用" tabindex="-1">1. <strong>路由器（必须包裹整个应用）</strong> <a class="header-anchor" href="#_1-路由器-必须包裹整个应用" aria-label="Permalink to “1. 路由器（必须包裹整个应用）”">​</a></h4><ul><li><code>BrowserRouter</code>：HTML5 history 模式（推荐）</li><li><code>HashRouter</code>：hash 模式（兼容旧浏览器）</li><li><code>MemoryRouter</code>：内存 history（测试/非浏览器环境）</li></ul><h4 id="_2-路由匹配与渲染" tabindex="-1">2. <strong>路由匹配与渲染</strong> <a class="header-anchor" href="#_2-路由匹配与渲染" aria-label="Permalink to “2. 路由匹配与渲染”">​</a></h4><ul><li><code>Routes</code>：<strong>v6 新增</strong>，替代 v5 的 <code>Switch</code>，包含多个 <code>Route</code></li><li><code>Route</code>：定义路径与组件映射<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/users&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Users</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;} /&gt;</span></span></code></pre></div></li><li><code>Navigate</code>：<strong>v6 替代 <code>Redirect</code></strong>，用于重定向<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/old&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Navigate</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/new&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;} /&gt;</span></span></code></pre></div></li></ul><h4 id="_3-导航组件" tabindex="-1">3. <strong>导航组件</strong> <a class="header-anchor" href="#_3-导航组件" aria-label="Permalink to “3. 导航组件”">​</a></h4><ul><li><code>Link</code>：声明式导航（生成 <code>&lt;a&gt;</code> 标签，不刷新页面）<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Home&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Link</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><code>NavLink</code>：<strong>带激活状态的 Link</strong>（常用于导航栏）<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NavLink</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/profile&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">isActive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isActive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;active&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} /&gt;</span></span></code></pre></div></li><li><code>useNavigate()</code> Hook：<strong>编程式导航</strong>（v6 替代 <code>history.push</code>）<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> navigate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useNavigate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">navigate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul><h4 id="_4-hooks-v6-推荐方式" tabindex="-1">4. <strong>Hooks（v6 推荐方式）</strong> <a class="header-anchor" href="#_4-hooks-v6-推荐方式" aria-label="Permalink to “4. Hooks（v6 推荐方式）”">​</a></h4><ul><li><code>useParams()</code>：获取动态路由参数（如 <code>/users/:id</code> → <code>{ id: &#39;123&#39; }</code>）</li><li><code>useSearchParams()</code>：读写 URL 查询参数（类似 <code>?name=foo</code>）</li><li><code>useLocation()</code>：获取当前 location 对象（pathname、search 等）</li><li><code>useNavigate()</code>：导航函数（见上）</li></ul><h4 id="_5-其他" tabindex="-1">5. <strong>其他</strong> <a class="header-anchor" href="#_5-其他" aria-label="Permalink to “5. 其他”">​</a></h4><ul><li><code>Outlet</code>：<strong>嵌套路由的占位符</strong>（父路由中使用，渲染子路由内容）</li><li><code>useRoutes()</code>：用 JS 对象配置路由（替代 JSX 写法）</li></ul><hr><h3 id="v5-vs-v6-关键差异" tabindex="-1">v5 vs v6 关键差异 <a class="header-anchor" href="#v5-vs-v6-关键差异" aria-label="Permalink to “v5 vs v6 关键差异”">​</a></h3><table tabindex="0"><thead><tr><th>功能</th><th>v5</th><th>v6</th></tr></thead><tbody><tr><td>路由容器</td><td><code>&lt;Switch&gt;</code></td><td><code>&lt;Routes&gt;</code></td></tr><tr><td>路由组件</td><td><code>component</code>/<code>render</code></td><td><code>element</code>（JSX）</td></tr><tr><td>重定向</td><td><code>&lt;Redirect&gt;</code></td><td><code>&lt;Navigate&gt;</code></td></tr><tr><td>编程式导航</td><td><code>props.history</code></td><td><code>useNavigate()</code></td></tr><tr><td>嵌套路由</td><td>手动拼接</td><td>自动嵌套 + <code>&lt;Outlet&gt;</code></td></tr></tbody></table><hr><p>✅ <strong>总结</strong>：<br> React Router 通过 <strong>History API 监听 + 路径匹配 + Context 共享状态</strong> 实现 SPA 路由。<code>react-router-dom</code> 提供了从路由定义（<code>Route</code>）、导航（<code>Link</code>/<code>useNavigate</code>）到参数获取（<code>useParams</code>）的完整工具链，<strong>v6 更简洁、类型安全、性能更好</strong>。</p><h2 id="react-hooks解决了什么问题-函数组件与类组件的区别" tabindex="-1">React hooks解决了什么问题? 函数组件与类组件的区别 <a class="header-anchor" href="#react-hooks解决了什么问题-函数组件与类组件的区别" aria-label="Permalink to “React hooks解决了什么问题? 函数组件与类组件的区别”">​</a></h2><h3 id="react-hooks-解决了什么问题" tabindex="-1">React Hooks 解决了什么问题？ <a class="header-anchor" href="#react-hooks-解决了什么问题" aria-label="Permalink to “React Hooks 解决了什么问题？”">​</a></h3><p>Hooks 是 React 16.8 引入的特性，<strong>让函数组件拥有类组件的能力</strong>，主要解决以下问题：</p><hr><h4 id="_1-逻辑复用困难-mixin-hoc-render-props-的缺陷" tabindex="-1">1. <strong>逻辑复用困难（Mixin / HOC / Render Props 的缺陷）</strong> <a class="header-anchor" href="#_1-逻辑复用困难-mixin-hoc-render-props-的缺陷" aria-label="Permalink to “1. 逻辑复用困难（Mixin / HOC / Render Props 的缺陷）”">​</a></h4><ul><li>类组件中，共享状态逻辑需借助高阶组件（HOC）或 Render Props，导致<strong>嵌套地狱、命名冲突、props 传递繁琐</strong>。</li><li><strong>Hooks 通过自定义 Hook（如 <code>useFetch</code>）实现扁平化逻辑复用</strong>，无嵌套、无 props 干扰。</li></ul><h4 id="_2-组件复杂度高-wrapper-hell-状态逻辑分散" tabindex="-1">2. <strong>组件复杂度高（“Wrapper Hell” + 状态逻辑分散）</strong> <a class="header-anchor" href="#_2-组件复杂度高-wrapper-hell-状态逻辑分散" aria-label="Permalink to “2. 组件复杂度高（“Wrapper Hell” + 状态逻辑分散）”">​</a></h4><ul><li>类组件中，相关逻辑（如订阅、数据获取）常分散在多个生命周期（<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>）。</li><li><strong>Hooks 将关联逻辑聚合在同一个 <code>useEffect</code> 中</strong>，提升可读性和维护性。</li></ul><h4 id="_3-类组件难以优化和理解" tabindex="-1">3. <strong>类组件难以优化和理解</strong> <a class="header-anchor" href="#_3-类组件难以优化和理解" aria-label="Permalink to “3. 类组件难以优化和理解”">​</a></h4><ul><li><code>this</code> 指向易错、需绑定方法、压缩后难调试。</li><li><strong>函数组件更轻量、无 <code>this</code>、更易测试和推理</strong>。</li></ul><h4 id="_4-无法在函数组件中使用状态和副作用" tabindex="-1">4. <strong>无法在函数组件中使用状态和副作用</strong> <a class="header-anchor" href="#_4-无法在函数组件中使用状态和副作用" aria-label="Permalink to “4. 无法在函数组件中使用状态和副作用”">​</a></h4><ul><li>函数组件原为“纯函数”，无法管理状态或执行副作用。</li><li><strong>Hooks（<code>useState</code>, <code>useEffect</code> 等）赋予函数组件完整能力</strong>，统一编程模型。</li></ul><hr><h3 id="函数组件-vs-类组件的区别" tabindex="-1">函数组件 vs 类组件的区别 <a class="header-anchor" href="#函数组件-vs-类组件的区别" aria-label="Permalink to “函数组件 vs 类组件的区别”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>函数组件（+ Hooks）</th><th>类组件</th></tr></thead><tbody><tr><td><strong>状态管理</strong></td><td><code>useState</code>, <code>useReducer</code></td><td><code>this.state</code> + <code>setState</code></td></tr><tr><td><strong>副作用处理</strong></td><td><code>useEffect</code></td><td><code>componentDidMount</code> 等生命周期</td></tr><tr><td><strong>逻辑复用</strong></td><td>自定义 Hook（扁平、组合式）</td><td>HOC / Render Props（嵌套、复杂）</td></tr><tr><td><strong>代码体积</strong></td><td>更小（无类语法开销）</td><td>较大</td></tr><tr><td><strong>性能</strong></td><td>更易优化（React 团队推荐）</td><td>需手动优化（如 <code>PureComponent</code>）</td></tr><tr><td><strong><code>this</code> 问题</strong></td><td>无</td><td>需绑定方法，易出错</td></tr><tr><td><strong>热更新（HMR）</strong></td><td>支持更好</td><td>可能丢失状态</td></tr><tr><td><strong>TypeScript 支持</strong></td><td>更友好（类型推导清晰）</td><td>需处理 <code>this</code> 类型</td></tr></tbody></table><hr><h3 id="✅-总结" tabindex="-1">✅ 总结 <a class="header-anchor" href="#✅-总结" aria-label="Permalink to “✅ 总结”">​</a></h3><ul><li><strong>Hooks 不是替代类组件，而是提供更优的编程范式</strong>：<br><strong>函数式 + 声明式 + 组合式</strong>，让代码更简洁、可复用、易测试。</li><li><strong>官方推荐</strong>：新项目优先使用函数组件 + Hooks，类组件仅用于维护旧代码。</li></ul><blockquote><p>“Hooks 让函数组件从‘展示型’升级为‘全能型’，同时解决了类组件的历史包袱。” —— React 团队</p></blockquote><h2 id="setstate是同步还是异步的-setstate做了什么" tabindex="-1">SetState是同步还是异步的，setState做了什么 <a class="header-anchor" href="#setstate是同步还是异步的-setstate做了什么" aria-label="Permalink to “SetState是同步还是异步的，setState做了什么”">​</a></h2><p><code>setState</code> 在 React 中<strong>通常是异步的，但在某些特定场景下表现为同步</strong>。它的核心作用是：<strong>调度状态更新，并触发组件的重新渲染（re-render）</strong>。</p><hr><h3 id="一、setstate-是同步还是异步" tabindex="-1">一、<code>setState</code> 是同步还是异步？ <a class="header-anchor" href="#一、setstate-是同步还是异步" aria-label="Permalink to “一、setState 是同步还是异步？”">​</a></h3><h4 id="✅-大多数情况-异步-批量更新" tabindex="-1">✅ <strong>大多数情况：异步（批量更新）</strong> <a class="header-anchor" href="#✅-大多数情况-异步-批量更新" aria-label="Permalink to “✅ 大多数情况：异步（批量更新）”">​</a></h4><ul><li>在 <strong>React 事件处理器</strong>（如 <code>onClick</code>）和 <strong>生命周期方法</strong> 中：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.count); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 输出旧值（异步）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>React 会将多个 <code>setState</code> <strong>合并（batching）</strong>，在事件结束时<strong>统一更新</strong>，避免频繁渲染。</li></ul></li></ul><h4 id="⚠️-少数情况-同步-非-react-控制的上下文" tabindex="-1">⚠️ <strong>少数情况：同步（非 React 控制的上下文）</strong> <a class="header-anchor" href="#⚠️-少数情况-同步-非-react-控制的上下文" aria-label="Permalink to “⚠️ 少数情况：同步（非 React 控制的上下文）”">​</a></h4><ul><li>在 <strong>原生事件</strong>、<strong>setTimeout</strong>、<strong>Promise</strong>、<strong>async/await</strong> 等中：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.count); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 输出 1（同步）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li>因为 React 无法控制这些上下文，所以<strong>立即执行更新</strong>（但注意：React 18 后通过 <code>createRoot</code> 启用自动批处理，上述行为可能改变）。</li></ul></li></ul><blockquote><p>🔔 <strong>React 18 新特性</strong>：<br> 使用 <code>createRoot</code> 后，<strong>所有 <code>setState</code> 默认自动批处理</strong>（包括 setTimeout），除非手动调用 <code>flushSync</code> 强制同步。</p></blockquote><hr><h3 id="二、setstate-做了什么" tabindex="-1">二、<code>setState</code> 做了什么？ <a class="header-anchor" href="#二、setstate-做了什么" aria-label="Permalink to “二、setState 做了什么？”">​</a></h3><ol><li><p><strong>调度更新（Schedule Update）</strong></p><ul><li>将新的 state 与当前 state 合并（对象浅合并）</li><li>将更新任务放入 React 的更新队列</li></ul></li><li><p><strong>触发协调（Reconciliation）</strong></p><ul><li>在合适的时机（如事件结束），React 执行： <ul><li>调用 <code>render()</code> 生成新虚拟 DOM</li><li>与旧虚拟 DOM diff</li><li>更新真实 DOM（如有差异）</li></ul></li></ul></li><li><p><strong>调用生命周期 / Hooks</strong></p><ul><li>类组件：<code>getSnapshotBeforeUpdate</code> → <code>componentDidUpdate</code></li><li>函数组件：<code>useEffect</code> 回调（在 DOM 更新后执行）</li></ul></li></ol><hr><h3 id="三、注意事项" tabindex="-1">三、注意事项 <a class="header-anchor" href="#三、注意事项" aria-label="Permalink to “三、注意事项”">​</a></h3><ul><li><strong>不要依赖 <code>this.state</code> 立即更新</strong>：使用回调函数形式获取最新状态<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prevState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ count: prevState.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }));</span></span></code></pre></div></li><li><strong>对象 state 需手动合并</strong>：<code>setState</code> 只做浅合并<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误：会覆盖其他属性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ user: { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ user: { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prev.user, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } }));</span></span></code></pre></div></li></ul><hr><p>✅ <strong>一句话总结</strong>：<br><code>setState</code> 是 <strong>“调度器”而非“赋值器”</strong> —— 它告诉 React “状态要变了”，由 React 决定何时更新，以实现高性能批量渲染。理解其异步性是避免状态 bug 的关键。</p><h2 id="什么是fiber-fiber解决了什么问题" tabindex="-1">什么是fiber，fiber解决了什么问题 <a class="header-anchor" href="#什么是fiber-fiber解决了什么问题" aria-label="Permalink to “什么是fiber，fiber解决了什么问题”">​</a></h2><h3 id="什么是-fiber" tabindex="-1">什么是 Fiber？ <a class="header-anchor" href="#什么是-fiber" aria-label="Permalink to “什么是 Fiber？”">​</a></h3><p><strong>Fiber 是 React 16 引入的全新协调（Reconciliation）引擎</strong>，是对 React 核心算法的重写。它的本质是一个 <strong>基于优先级和可中断的增量渲染机制</strong>，核心目标是：<strong>提升复杂 UI 的响应性和性能</strong>。</p><blockquote><p>📌 “Fiber” 既指代这个新架构，也指代 React 内部用于表示组件工作单元的数据结构（每个组件对应一个 Fiber 节点）。</p></blockquote><hr><h3 id="fiber-解决了什么问题" tabindex="-1">Fiber 解决了什么问题？ <a class="header-anchor" href="#fiber-解决了什么问题" aria-label="Permalink to “Fiber 解决了什么问题？”">​</a></h3><h4 id="❌-react-15-的-stack-reconciler-栈协调器-的问题" tabindex="-1">❌ <strong>React 15 的 Stack Reconciler（栈协调器）的问题</strong> <a class="header-anchor" href="#❌-react-15-的-stack-reconciler-栈协调器-的问题" aria-label="Permalink to “❌ React 15 的 Stack Reconciler（栈协调器）的问题”">​</a></h4><ul><li><strong>递归 diff，不可中断</strong>：一旦开始更新，必须同步完成整个虚拟 DOM 树的遍历和更新。</li><li><strong>长时间占用主线程</strong>：大型应用更新时会阻塞浏览器，导致页面卡顿、掉帧（&gt;16ms），用户交互无响应。</li></ul><h4 id="✅-fiber-的解决方案" tabindex="-1">✅ <strong>Fiber 的解决方案</strong> <a class="header-anchor" href="#✅-fiber-的解决方案" aria-label="Permalink to “✅ Fiber 的解决方案”">​</a></h4><ol><li><p><strong>可中断的渲染（Interruptible Rendering）</strong></p><ul><li>将渲染/更新任务拆分为多个 <strong>小单元（Fiber 节点）</strong>。</li><li>每处理完一个单元，检查是否需让出主线程（如响应用户输入、动画）。</li><li>若有高优先级任务（如点击），暂停当前更新，先处理紧急任务。</li></ul></li><li><p><strong>优先级调度（Priority Scheduling）</strong></p><ul><li>不同更新赋予不同优先级： <ul><li><strong>高优先级</strong>：用户交互（点击、输入）</li><li><strong>低优先级</strong>：数据获取、过渡动画</li></ul></li><li>高优任务可打断低优任务，实现“流畅交互”。</li></ul></li><li><p><strong>增量更新（Incremental Updates）</strong></p><ul><li>更新可分多帧完成，避免单帧超时（&gt;16ms）。</li><li>即使未完成全部更新，也能保证部分 UI 及时响应。</li></ul></li><li><p><strong>支持新特性基础</strong></p><ul><li>为 <code>Suspense</code>、<code>Concurrent Mode</code>（现称 Concurrent Features）、<code>startTransition</code> 等提供底层支持。</li></ul></li></ol><hr><h3 id="fiber-的工作机制-简化" tabindex="-1">Fiber 的工作机制（简化） <a class="header-anchor" href="#fiber-的工作机制-简化" aria-label="Permalink to “Fiber 的工作机制（简化）”">​</a></h3><ol><li><p><strong>双缓冲树（Double Buffering）</strong></p><ul><li>维护两棵 Fiber 树：<code>current</code>（已渲染）和 <code>workInProgress</code>（正在构建）。</li><li>更新在 <code>workInProgress</code> 上进行，完成后原子切换，避免中间状态暴露。</li></ul></li><li><p><strong>工作循环（Work Loop）</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (workInProgress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shouldYield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  performUnitOfWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>shouldYield()</code>：检查是否需让出主线程（基于帧时间预算）。</li></ul></li><li><p><strong>链表遍历</strong></p><ul><li>Fiber 节点通过 <code>child</code>、<code>sibling</code>、<code>return</code> 指针构成链表，替代递归，便于暂停/恢复。</li></ul></li></ol><hr><h3 id="✅-总结-1" tabindex="-1">✅ 总结 <a class="header-anchor" href="#✅-总结-1" aria-label="Permalink to “✅ 总结”">​</a></h3><table tabindex="0"><thead><tr><th>问题</th><th>Fiber 如何解决</th></tr></thead><tbody><tr><td>渲染卡顿</td><td>拆分任务 + 让出主线程</td></tr><tr><td>交互延迟</td><td>高优先级任务插队</td></tr><tr><td>大更新阻塞</td><td>增量、可中断更新</td></tr><tr><td>无法实现并发特性</td><td>提供底层调度能力</td></tr></tbody></table><blockquote><p><strong>Fiber 不是为了更快，而是为了让 React “更聪明”</strong> —— 在正确的时间做正确的事，保障用户体验流畅。</p></blockquote><h2 id="react中在哪捕获错误" tabindex="-1">React中在哪捕获错误？ <a class="header-anchor" href="#react中在哪捕获错误" aria-label="Permalink to “React中在哪捕获错误？”">​</a></h2><p>在 React 中，<strong>不能使用传统的 <code>try...catch</code> 捕获子组件内部的渲染错误或生命周期错误</strong>，因为 React 的渲染是异步和批量处理的。为此，React 提供了 <strong>错误边界（Error Boundaries）</strong> 机制。</p><hr><h3 id="✅-正确方式-使用-错误边界-error-boundary" tabindex="-1">✅ 正确方式：使用 <strong>错误边界（Error Boundary）</strong> <a class="header-anchor" href="#✅-正确方式-使用-错误边界-error-boundary" aria-label="Permalink to “✅ 正确方式：使用 错误边界（Error Boundary）”">​</a></h3><p>错误边界是一个 <strong>React 组件</strong>，它能捕获其<strong>子组件树中任何位置的 JavaScript 错误</strong>（包括渲染、生命周期方法、构造函数等），并防止整个应用崩溃。</p><h4 id="如何创建错误边界" tabindex="-1">如何创建错误边界？ <a class="header-anchor" href="#如何创建错误边界" aria-label="Permalink to “如何创建错误边界？”">​</a></h4><p>通过定义以下 <strong>两个生命周期方法</strong>（仅限类组件）：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ErrorBoundary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(props);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { hasError: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 捕获子组件的错误</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDerivedStateFromError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { hasError: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新 state 以触发 fallback UI</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 记录错误信息（可选）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  componentDidCatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">errorInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Error:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Error Info:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, errorInfo);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 可上报错误日志（如 Sentry）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.hasError) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Oops! Something went wrong.&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fallback UI</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.props.children; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正常渲染子组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="使用方式" tabindex="-1">使用方式： <a class="header-anchor" href="#使用方式" aria-label="Permalink to “使用方式：”">​</a></h4><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt; {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 若 MyComponent 报错，会被捕获 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><hr><h3 id="⚠️-错误边界-不能捕获-的错误类型" tabindex="-1">⚠️ 错误边界 <strong>不能捕获</strong> 的错误类型： <a class="header-anchor" href="#⚠️-错误边界-不能捕获-的错误类型" aria-label="Permalink to “⚠️ 错误边界 不能捕获 的错误类型：”">​</a></h3><ol><li><strong>事件处理器中的错误</strong>（如 <code>onClick</code>）<br> → 直接用 <code>try...catch</code></li><li><strong>异步代码中的错误</strong>（如 <code>setTimeout</code>、<code>Promise</code>）<br> → 需在异步回调内自行处理</li><li><strong>服务端渲染（SSR）错误</strong></li><li><strong>错误边界自身抛出的错误</strong></li></ol><hr><h3 id="✅-函数组件怎么办" tabindex="-1">✅ 函数组件怎么办？ <a class="header-anchor" href="#✅-函数组件怎么办" aria-label="Permalink to “✅ 函数组件怎么办？”">​</a></h3><ul><li><strong>函数组件本身不能成为错误边界</strong>（因无生命周期方法）。</li><li>但可以<strong>被错误边界包裹</strong>。</li><li>若需在函数组件中处理局部错误，可： <ul><li>将可能出错的部分封装到类组件中作为错误边界</li><li>或使用第三方库（如 <code>react-error-boundary</code>）</li></ul></li></ul><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 react-error-boundary（推荐）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ErrorBoundary } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-error-boundary&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FallbackComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ErrorFallback}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ErrorBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="✅-最佳实践" tabindex="-1">✅ 最佳实践 <a class="header-anchor" href="#✅-最佳实践" aria-label="Permalink to “✅ 最佳实践”">​</a></h3><ul><li>在<strong>应用顶层</strong>设置全局错误边界（防白屏）</li><li>在<strong>关键模块</strong>（如评论区、支付组件）设置局部错误边界</li><li>错误边界内提供<strong>用户友好的降级 UI</strong> 和<strong>重试机制</strong></li><li>结合监控平台（如 Sentry）上报错误</li></ul><hr><p>✅ <strong>总结</strong>：<br> React 中通过 <strong>错误边界（类组件 + <code>getDerivedStateFromError</code> / <code>componentDidCatch</code>）</strong> 捕获子组件渲染错误；其他错误（事件、异步）仍需传统 <code>try...catch</code>。<strong>错误边界是保障应用健壮性的关键机制。</strong></p><h2 id="react组件传值有哪些方式" tabindex="-1">React组件传值有哪些方式 <a class="header-anchor" href="#react组件传值有哪些方式" aria-label="Permalink to “React组件传值有哪些方式”">​</a></h2><p>React 组件传值（数据流）遵循 <strong>“单向数据流”</strong> 原则，主要方式如下：</p><hr><h3 id="一、父子组件通信" tabindex="-1">一、<strong>父子组件通信</strong> <a class="header-anchor" href="#一、父子组件通信" aria-label="Permalink to “一、父子组件通信”">​</a></h3><h4 id="_1-父-→-子-props" tabindex="-1">1. <strong>父 → 子：<code>props</code></strong> <a class="header-anchor" href="#_1-父-→-子-props" aria-label="Permalink to “1. 父 → 子：props”">​</a></h4><ul><li>最基础方式，父组件通过属性传递数据/函数<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onUpdate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleUpdate} /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">onUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li></ul><h4 id="_2-子-→-父-回调函数-callback" tabindex="-1">2. <strong>子 → 父：回调函数（Callback）</strong> <a class="header-anchor" href="#_2-子-→-父-回调函数-callback" aria-label="Permalink to “2. 子 → 父：回调函数（Callback）”">​</a></h4><ul><li>父组件传递函数给子组件，子组件调用时传参<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newValue);</span></span></code></pre></div></li></ul><hr><h3 id="二、跨层级-兄弟组件通信" tabindex="-1">二、<strong>跨层级 / 兄弟组件通信</strong> <a class="header-anchor" href="#二、跨层级-兄弟组件通信" aria-label="Permalink to “二、跨层级 / 兄弟组件通信”">​</a></h3><h4 id="_3-状态提升-lifting-state-up" tabindex="-1">3. <strong>状态提升（Lifting State Up）</strong> <a class="header-anchor" href="#_3-状态提升-lifting-state-up" aria-label="Permalink to “3. 状态提升（Lifting State Up）”">​</a></h4><ul><li>将共享状态移到<strong>最近的共同父组件</strong>，通过 <code>props</code> 向下传递</li></ul><h4 id="_4-context-api-官方跨组件方案" tabindex="-1">4. <strong>Context API（官方跨组件方案）</strong> <a class="header-anchor" href="#_4-context-api-官方跨组件方案" aria-label="Permalink to “4. Context API（官方跨组件方案）”">​</a></h4><ul><li>适用于<strong>多层嵌套</strong>且不希望逐层透传 <code>props</code><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建 Context</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ThemeContext</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;light&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 祖先组件提供值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThemeContext.Provider</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dark&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThemeContext.Provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 任意后代组件消费</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> theme</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ThemeContext);</span></span></code></pre></div></li></ul><blockquote><p>✅ 适合：主题、语言、用户信息等全局但非频繁变化的数据</p></blockquote><h4 id="_5-状态管理库-redux-zustand-jotai-等" tabindex="-1">5. <strong>状态管理库（Redux / Zustand / Jotai 等）</strong> <a class="header-anchor" href="#_5-状态管理库-redux-zustand-jotai-等" aria-label="Permalink to “5. 状态管理库（Redux / Zustand / Jotai 等）”">​</a></h4><ul><li>适用于<strong>复杂应用</strong>，集中管理全局状态<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Redux 示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dispatch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useDispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li></ul><hr><h3 id="三、特殊场景" tabindex="-1">三、<strong>特殊场景</strong> <a class="header-anchor" href="#三、特殊场景" aria-label="Permalink to “三、特殊场景”">​</a></h3><h4 id="_6-ref-转发-父访问子组件实例或-dom" tabindex="-1">6. <strong>Ref 转发（父访问子组件实例或 DOM）</strong> <a class="header-anchor" href="#_6-ref-转发-父访问子组件实例或-dom" aria-label="Permalink to “6. Ref 转发（父访问子组件实例或 DOM）”">​</a></h4><ul><li>使用 <code>forwardRef</code> + <code>useImperativeHandle</code> 暴露子组件方法<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> forwardRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useImperativeHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ref, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() }));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul><h4 id="_7-事件总线-event-bus-—-不推荐" tabindex="-1">7. <strong>事件总线（Event Bus）— 不推荐</strong> <a class="header-anchor" href="#_7-事件总线-event-bus-—-不推荐" aria-label="Permalink to “7. 事件总线（Event Bus）— 不推荐”">​</a></h4><ul><li>通过第三方库（如 <code>mitt</code>）实现发布订阅</li><li><strong>破坏组件封装性，调试困难，仅限特殊场景</strong></li></ul><h4 id="_8-url-参数-浏览器存储" tabindex="-1">8. <strong>URL 参数 / 浏览器存储</strong> <a class="header-anchor" href="#_8-url-参数-浏览器存储" aria-label="Permalink to “8. URL 参数 / 浏览器存储”">​</a></h4><ul><li>通过路由参数（<code>useParams</code>）、查询参数（<code>useSearchParams</code>）或 <code>localStorage</code> 共享状态</li></ul><hr><h3 id="四、函数组件-vs-类组件差异" tabindex="-1">四、<strong>函数组件 vs 类组件差异</strong> <a class="header-anchor" href="#四、函数组件-vs-类组件差异" aria-label="Permalink to “四、函数组件 vs 类组件差异”">​</a></h3><ul><li>函数组件：使用 <code>props</code>、<code>useContext</code>、<code>useRef</code> 等 Hooks</li><li>类组件：<code>this.props</code>、<code>contextType</code>、<code>ref</code> 回调</li></ul><hr><h3 id="✅-选择建议" tabindex="-1">✅ 选择建议 <a class="header-anchor" href="#✅-选择建议" aria-label="Permalink to “✅ 选择建议”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>简单父子通信</td><td><code>props</code> + 回调</td></tr><tr><td>多层嵌套透传</td><td><code>Context</code></td></tr><tr><td>全局状态（用户、主题）</td><td><code>Context</code> 或轻量库（Zustand）</td></tr><tr><td>复杂业务状态（购物车、表单）</td><td>Redux / Zustand</td></tr><tr><td>父调用子方法</td><td><code>forwardRef</code> + <code>useImperativeHandle</code></td></tr></tbody></table><blockquote><p><strong>原则</strong>：优先用 <code>props</code>，避免过早引入全局状态；Context 不适合高频更新（会触发所有消费者重渲染）。</p></blockquote><h2 id="react无状态组件和class类组件的区别" tabindex="-1">react无状态组件和class类组件的区别 <a class="header-anchor" href="#react无状态组件和class类组件的区别" aria-label="Permalink to “react无状态组件和class类组件的区别”">​</a></h2><p>在 React 中，“无状态组件”通常指 <strong>函数组件（Functional Component）</strong>，而“类组件（Class Component）”是 ES6 class 写法的组件。它们的核心区别如下：</p><hr><h3 id="一、基本定义" tabindex="-1">一、基本定义 <a class="header-anchor" href="#一、基本定义" aria-label="Permalink to “一、基本定义”">​</a></h3><table tabindex="0"><thead><tr><th>类型</th><th>写法</th><th>是否有状态</th></tr></thead><tbody><tr><td><strong>函数组件（无状态组件）</strong></td><td><code>function MyComp() { return &lt;div /&gt; }</code></td><td><strong>最初无状态</strong>，但 <strong>Hooks 出现后可管理状态</strong></td></tr><tr><td><strong>类组件</strong></td><td><code>class MyComp extends React.Component { render() { return &lt;div /&gt; } }</code></td><td><strong>天生支持状态和生命周期</strong></td></tr></tbody></table><blockquote><p>📌 注意：<strong>“无状态组件”这个说法在 Hooks（React 16.8+）之后已过时</strong>，因为函数组件现在也能拥有状态。</p></blockquote><hr><h3 id="二、核心区别" tabindex="-1">二、核心区别 <a class="header-anchor" href="#二、核心区别" aria-label="Permalink to “二、核心区别”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>函数组件（+ Hooks）</th><th>类组件</th></tr></thead><tbody><tr><td><strong>状态管理</strong></td><td><code>useState</code>, <code>useReducer</code></td><td><code>this.state</code> + <code>setState</code></td></tr><tr><td><strong>副作用处理</strong></td><td><code>useEffect</code></td><td><code>componentDidMount</code> / <code>componentDidUpdate</code> / <code>componentWillUnmount</code></td></tr><tr><td><strong>性能</strong></td><td>更轻量，无 class 实例开销</td><td>创建实例，内存占用略高</td></tr><tr><td><strong>代码简洁性</strong></td><td>更简洁、扁平，逻辑按关注点聚合</td><td>逻辑分散在多个生命周期中</td></tr><tr><td><strong><code>this</code> 问题</strong></td><td>无 <code>this</code>，避免绑定烦恼</td><td>需手动绑定方法（如 <code>this.handleClick = this.handleClick.bind(this)</code>）</td></tr><tr><td><strong>逻辑复用</strong></td><td>自定义 Hook（组合式，无嵌套）</td><td>HOC / Render Props（易产生“Wrapper Hell”）</td></tr><tr><td><strong>热更新（HMR）</strong></td><td>支持更好</td><td>可能丢失状态</td></tr><tr><td><strong>TypeScript 支持</strong></td><td>类型推导更自然</td><td>需处理 <code>this</code> 类型</td></tr></tbody></table><hr><h3 id="三、能力对比-现代-react" tabindex="-1">三、能力对比（现代 React） <a class="header-anchor" href="#三、能力对比-现代-react" aria-label="Permalink to “三、能力对比（现代 React）”">​</a></h3><table tabindex="0"><thead><tr><th>能力</th><th>函数组件</th><th>类组件</th></tr></thead><tbody><tr><td>使用 state</td><td>✅ (<code>useState</code>)</td><td>✅</td></tr><tr><td>处理副作用</td><td>✅ (<code>useEffect</code>)</td><td>✅</td></tr><tr><td>获取 ref</td><td>✅ (<code>useRef</code>, <code>forwardRef</code>)</td><td>✅ (<code>createRef</code>)</td></tr><tr><td>错误边界</td><td>❌（需用类组件或第三方库）</td><td>✅（<code>componentDidCatch</code>）</td></tr><tr><td>性能优化</td><td>✅ (<code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code>)</td><td>✅ (<code>PureComponent</code>, <code>shouldComponentUpdate</code>)</td></tr></tbody></table><blockquote><p>⚠️ 唯一函数组件<strong>不能直接实现</strong>的是 <strong>错误边界（Error Boundary）</strong>，必须用类组件（或封装好的第三方组件如 <code>react-error-boundary</code>）。</p></blockquote><hr><h3 id="四、官方态度与趋势" tabindex="-1">四、官方态度与趋势 <a class="header-anchor" href="#四、官方态度与趋势" aria-label="Permalink to “四、官方态度与趋势”">​</a></h3><ul><li><strong>React 官方强烈推荐使用函数组件 + Hooks</strong>。</li><li>新特性（如 Concurrent Mode、Suspense）优先为函数组件设计。</li><li>类组件仍受支持，但<strong>新项目应优先使用函数组件</strong>。</li></ul><hr><h3 id="✅-总结-2" tabindex="-1">✅ 总结 <a class="header-anchor" href="#✅-总结-2" aria-label="Permalink to “✅ 总结”">​</a></h3><table tabindex="0"><thead><tr><th>角度</th><th>结论</th></tr></thead><tbody><tr><td><strong>历史</strong></td><td>“无状态组件”曾指纯展示组件，Hooks 后已能完全替代类组件</td></tr><tr><td><strong>现状</strong></td><td>函数组件 = 全能组件，类组件 = 遗留方案</td></tr><tr><td><strong>选择建议</strong></td><td><strong>新项目一律使用函数组件 + Hooks</strong>；仅维护旧代码时接触类组件</td></tr></tbody></table><blockquote><p>💡 <strong>记住</strong>：<br><strong>“函数组件不是无状态的，而是更优雅的状态管理者。”</strong></p></blockquote><h2 id="react如何做到和vue中keep-alive的缓存效果" tabindex="-1">react如何做到和vue中keep-alive的缓存效果 <a class="header-anchor" href="#react如何做到和vue中keep-alive的缓存效果" aria-label="Permalink to “react如何做到和vue中keep-alive的缓存效果”">​</a></h2><p>React <strong>没有内置类似 Vue <code>keep-alive</code> 的组件缓存机制</strong>，但可以通过以下方式实现<strong>组件状态缓存 / 保留 DOM / 避免重复渲染</strong>的效果：</p><hr><h3 id="✅-方案一-状态提升-条件渲染-最常用" tabindex="-1">✅ 方案一：<strong>状态提升 + 条件渲染（最常用）</strong> <a class="header-anchor" href="#✅-方案一-状态提升-条件渲染-最常用" aria-label="Permalink to “✅ 方案一：状态提升 + 条件渲染（最常用）”">​</a></h3><p>将组件的<strong>状态提升到父组件</strong>，即使子组件卸载，状态仍保留，重新挂载时恢复。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">showA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setShowA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stateA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setStateA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态保留在父级</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setShowA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">showA)}&gt;Toggle&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {showA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ChildA</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{stateA} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onStateChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{setStateA} /&gt;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>✅ 优点：简单、可控<br> ❌ 缺点：需手动管理状态，不适合复杂组件树</p></blockquote><hr><h3 id="✅-方案二-使用-display-none-css-控制显隐-保留-dom" tabindex="-1">✅ 方案二：<strong>使用 <code>display: none</code> / CSS 控制显隐（保留 DOM）</strong> <a class="header-anchor" href="#✅-方案二-使用-display-none-css-控制显隐-保留-dom" aria-label="Permalink to “✅ 方案二：使用 display: none / CSS 控制显隐（保留 DOM）”">​</a></h3><p>不卸载组件，仅隐藏，从而保留状态和 DOM 结构。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{showA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ChildA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 卸载（状态丢失）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ display: showA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;block&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;none&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }}&gt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ChildA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不卸载（状态保留）</span></span></code></pre></div><blockquote><p>✅ 优点：完全保留状态、DOM、定时器等<br> ❌ 缺点：隐藏的组件仍在内存中，可能影响性能（大量组件时不推荐）</p></blockquote><hr><h3 id="✅-方案三-自定义缓存容器-模拟-keep-alive" tabindex="-1">✅ 方案三：<strong>自定义缓存容器（模拟 keep-alive）</strong> <a class="header-anchor" href="#✅-方案三-自定义缓存容器-模拟-keep-alive" aria-label="Permalink to “✅ 方案三：自定义缓存容器（模拟 keep-alive）”">​</a></h3><p>通过 <code>Map</code> 缓存组件的 <strong>React Element</strong> 或 <strong>状态 + props</strong>，切换时复用。</p><h4 id="示例-缓存组件实例-使用-ref-cloneelement" tabindex="-1">示例：缓存组件实例（使用 <code>ref</code> + <code>cloneElement</code>） <a class="header-anchor" href="#示例-缓存组件实例-使用-ref-cloneelement" aria-label="Permalink to “示例：缓存组件实例（使用 ref + cloneElement）”">​</a></h4><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> KeepAlive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">active</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cacheRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children.key;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (active </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cacheRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cacheRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, children); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 缓存 element</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> active </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cacheRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">KeepAlive</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> active</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{tab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tabA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TabA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">KeepAlive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><blockquote><p>⚠️ 注意：此方法缓存的是 <strong>Element（描述）而非实例</strong>，无法保留内部状态。若需保留状态，需结合方案一。</p></blockquote><hr><h3 id="✅-方案四-使用第三方库" tabindex="-1">✅ 方案四：<strong>使用第三方库</strong> <a class="header-anchor" href="#✅-方案四-使用第三方库" aria-label="Permalink to “✅ 方案四：使用第三方库”">​</a></h3><ul><li><a href="https://github.com/CJY0208/react-activation" target="_blank" rel="noreferrer"><code>react-activation</code></a>（推荐）<br> 提供 <code>&lt;KeepAlive&gt;</code> 和 <code>&lt;AliveScope&gt;</code>，真正实现 Vue 式缓存：<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { AliveScope, KeepAlive } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-activation&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AliveScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">KeepAlive</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tabA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TabA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">KeepAlive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AliveScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>✅ 支持状态、DOM、定时器、异步操作完整保留</li><li>✅ 支持路由级缓存</li><li>❌ 需额外依赖，且与 React 官方理念略有冲突（非标准模式）</li></ul></li></ul><hr><h3 id="✅-方案五-结合-react-router-实现-tab-缓存" tabindex="-1">✅ 方案五：<strong>结合 React Router 实现 Tab 缓存</strong> <a class="header-anchor" href="#✅-方案五-结合-react-router-实现-tab-缓存" aria-label="Permalink to “✅ 方案五：结合 React Router 实现 Tab 缓存”">​</a></h3><p>在路由切换时，用 <code>display: none</code> 隐藏非激活路由：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Routes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {routes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">route</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Route</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{route.path}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{route.path}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ display: currentPath </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> route.path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;block&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;none&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">route.component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ))}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Routes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><hr><h3 id="📌-总结-如何选择" tabindex="-1">📌 总结：如何选择？ <a class="header-anchor" href="#📌-总结-如何选择" aria-label="Permalink to “📌 总结：如何选择？”">​</a></h3><table tabindex="0"><thead><tr><th>需求</th><th>推荐方案</th></tr></thead><tbody><tr><td>简单状态缓存</td><td><strong>状态提升（方案一）</strong></td></tr><tr><td>完整保留组件（含 DOM、定时器）</td><td><strong>CSS 隐藏（方案二）</strong> 或 <strong><code>react-activation</code>（方案四）</strong></td></tr><tr><td>路由级 Tab 缓存</td><td><strong><code>react-activation</code></strong> 或 <strong>自定义路由容器 + 隐藏</strong></td></tr><tr><td>轻量级、无依赖</td><td><strong>状态提升 + 合理设计状态粒度</strong></td></tr></tbody></table><blockquote><p>💡 <strong>核心思想</strong>：<br> React 哲学是“状态驱动 UI”，<strong>缓存本质是状态管理问题</strong>。优先通过状态设计避免频繁卸载，而非强行保留组件实例。</p></blockquote><h2 id="react如何做路由监听" tabindex="-1">React如何做路由监听 <a class="header-anchor" href="#react如何做路由监听" aria-label="Permalink to “React如何做路由监听”">​</a></h2><p>在 React 中，<strong>路由监听</strong>主要用于响应 URL 变化（如页面切换、参数更新），常见于埋点、权限校验、滚动恢复等场景。根据使用的路由库（主要是 <code>react-router-dom</code>），有以下几种方式：</p><hr><h3 id="一、使用-uselocation-useeffect-推荐-适用于函数组件" tabindex="-1">一、使用 <code>useLocation</code> + <code>useEffect</code>（推荐，适用于函数组件） <a class="header-anchor" href="#一、使用-uselocation-useeffect-推荐-适用于函数组件" aria-label="Permalink to “一、使用 useLocation + useEffect（推荐，适用于函数组件）”">​</a></h3><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useLocation } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-router-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 每次路由变化都会触发</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Route changed to:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, location.pathname);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 示例：页面埋点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    trackPageView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location.pathname);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 示例：回到顶部</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scrollTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [location]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Outlet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>✅ <strong>优点</strong>：简洁、响应式、自动清理<br> 🔔 注意：需将 <code>location</code> 作为依赖项</p></blockquote><hr><h3 id="二、使用-usenavigation-react-router-v6-4-新增" tabindex="-1">二、使用 <code>useNavigation</code>（React Router v6.4+ 新增） <a class="header-anchor" href="#二、使用-usenavigation-react-router-v6-4-新增" aria-label="Permalink to “二、使用 useNavigation（React Router v6.4+ 新增）”">​</a></h3><p>适用于数据路由器（<code>createBrowserRouter</code>）：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> navigation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useNavigation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// navigation.state: &#39;idle&#39; | &#39;loading&#39; | &#39;submitting&#39;</span></span></code></pre></div><p>但<strong>不直接用于监听路径变化</strong>，更多用于加载状态。</p><hr><h3 id="三、通过-history-对象监听-适用于类组件或全局监听" tabindex="-1">三、通过 <code>history</code> 对象监听（适用于类组件或全局监听） <a class="header-anchor" href="#三、通过-history-对象监听-适用于类组件或全局监听" aria-label="Permalink to “三、通过 history 对象监听（适用于类组件或全局监听）”">​</a></h3><h4 id="react-router-v5" tabindex="-1">React Router v5： <a class="header-anchor" href="#react-router-v5" aria-label="Permalink to “React Router v5：”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useHistory } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-router-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在组件内</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> history</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unlisten</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Route changed:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, location.pathname);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unlisten; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 清理监听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span></code></pre></div><h4 id="react-router-v6-需自定义-history" tabindex="-1">React Router v6（需自定义 history）： <a class="header-anchor" href="#react-router-v6-需自定义-history" aria-label="Permalink to “React Router v6（需自定义 history）：”">​</a></h4><p>v6 默认不暴露 <code>history</code>，但可通过以下方式创建可监听的 <code>history</code>：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// history.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createBrowserHistory } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> history</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createBrowserHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// router.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Router } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-router-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { history } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Router</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> history</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{history}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* routes */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Router</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 全局监听（如在 index.js）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Route changed:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, location.pathname);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><blockquote><p>⚠️ 注意：<strong>v6 官方不推荐此方式</strong>，优先用 <code>useLocation</code></p></blockquote><hr><h3 id="四、在路由配置中统一处理-v6-数据路由器" tabindex="-1">四、在路由配置中统一处理（v6 数据路由器） <a class="header-anchor" href="#四、在路由配置中统一处理-v6-数据路由器" aria-label="Permalink to “四、在路由配置中统一处理（v6 数据路由器）”">​</a></h3><p>使用 <code>createBrowserRouter</code> 时，可在 loader/action 中处理，但<strong>无法直接监听所有路由变化</strong>。仍需配合 <code>useLocation</code>。</p><hr><h3 id="五、类组件中监听-不推荐-仅兼容旧代码" tabindex="-1">五、类组件中监听（不推荐，仅兼容旧代码） <a class="header-anchor" href="#五、类组件中监听-不推荐-仅兼容旧代码" aria-label="Permalink to “五、类组件中监听（不推荐，仅兼容旧代码）”">​</a></h3><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { withRouter } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-router-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  componentDidUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prevProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.props.location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevProps.location) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Route changed&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> withRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyComponent);</span></span></code></pre></div><blockquote><p>📌 <code>withRouter</code> 在 v6 中已移除，<strong>新项目不要使用</strong></p></blockquote><hr><h3 id="✅-最佳实践总结" tabindex="-1">✅ 最佳实践总结 <a class="header-anchor" href="#✅-最佳实践总结" aria-label="Permalink to “✅ 最佳实践总结”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>函数组件监听路由变化</td><td><strong><code>useLocation</code> + <code>useEffect</code></strong></td></tr><tr><td>全局埋点 / 权限校验</td><td>在根组件用 <code>useLocation</code> 监听</td></tr><tr><td>需要兼容类组件</td><td>使用 HOC 包装 <code>useLocation</code> 自定义 Hook</td></tr><tr><td>必须用 history 监听</td><td>v5 用 <code>history.listen</code>，v6 需自定义 history（不推荐）</td></tr></tbody></table><hr><h3 id="💡-补充-监听查询参数变化" tabindex="-1">💡 补充：监听查询参数变化 <a class="header-anchor" href="#💡-补充-监听查询参数变化" aria-label="Permalink to “💡 补充：监听查询参数变化”">​</a></h3><p>若需监听 <code>?search=value</code> 变化，结合 <code>useSearchParams</code>：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">searchParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSearchParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Query changed:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, searchParams.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;q&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [searchParams]);</span></span></code></pre></div><hr><p>✅ <strong>核心原则</strong>：<br><strong>优先使用 React Router v6 提供的 Hooks（<code>useLocation</code>, <code>useParams</code>, <code>useSearchParams</code>）</strong>，避免直接操作 history，保持代码声明式和可维护性。</p><h2 id="react有哪几种方式改变state" tabindex="-1">React有哪几种方式改变state <a class="header-anchor" href="#react有哪几种方式改变state" aria-label="Permalink to “React有哪几种方式改变state”">​</a></h2><p>在 React 中，<strong>改变 state 的方式取决于组件类型（函数组件 vs 类组件）</strong>。核心原则是：<strong>永远不要直接修改 state，必须通过 React 提供的更新方法触发重新渲染</strong>。</p><hr><h3 id="一、函数组件-使用-hooks" tabindex="-1">一、函数组件（使用 Hooks） <a class="header-anchor" href="#一、函数组件-使用-hooks" aria-label="Permalink to “一、函数组件（使用 Hooks）”">​</a></h3><h4 id="_1-usestate-更新状态" tabindex="-1">1. <strong><code>useState</code> 更新状态</strong> <a class="header-anchor" href="#_1-usestate-更新状态" aria-label="Permalink to “1. useState 更新状态”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 方式1：传入新值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 方式2：传入函数（推荐用于依赖旧状态）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h4 id="_2-usereducer-更新复杂状态" tabindex="-1">2. <strong><code>useReducer</code> 更新复杂状态</strong> <a class="header-anchor" href="#_2-usereducer-更新复杂状态" aria-label="Permalink to “2. useReducer 更新复杂状态”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useReducer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reducer, initialState);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过 dispatch action 触发 reducer</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;INCREMENT&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, payload: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><blockquote><p>✅ 适用场景：</p><ul><li><code>useState</code>：简单状态（number、string、简单对象）</li><li><code>useReducer</code>：复杂状态逻辑、多子状态关联更新</li></ul></blockquote><hr><h3 id="二、类组件" tabindex="-1">二、类组件 <a class="header-anchor" href="#二、类组件" aria-label="Permalink to “二、类组件”">​</a></h3><h4 id="_1-this-setstate" tabindex="-1">1. <strong><code>this.setState()</code></strong> <a class="header-anchor" href="#_1-this-setstate" aria-label="Permalink to “1. this.setState()”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 方式1：传入对象（浅合并）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 方式2：传入函数（推荐用于依赖旧状态）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prevState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  count: prevState.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}));</span></span></code></pre></div><blockquote><p>⚠️ 注意：</p><ul><li><code>setState</code> 是<strong>异步批量更新</strong>（React 控制的上下文中）</li><li>对象更新需手动展开（<code>setState</code> 只做浅合并）</li></ul></blockquote><hr><h3 id="三、其他间接方式-不直接调用-setstate" tabindex="-1">三、其他间接方式（不直接调用 setState） <a class="header-anchor" href="#三、其他间接方式-不直接调用-setstate" aria-label="Permalink to “三、其他间接方式（不直接调用 setState）”">​</a></h3><h4 id="_1-状态管理库-redux-zustand-等" tabindex="-1">1. <strong>状态管理库（Redux / Zustand 等）</strong> <a class="header-anchor" href="#_1-状态管理库-redux-zustand-等" aria-label="Permalink to “1. 状态管理库（Redux / Zustand 等）”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Redux</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;SET_COUNT&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, payload: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Zustand</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">useStore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h4 id="_2-context-api-usereducer" tabindex="-1">2. <strong>Context API + useReducer</strong> <a class="header-anchor" href="#_2-context-api-usereducer" aria-label="Permalink to “2. Context API + useReducer”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 Context Provider 中使用 useReducer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useReducer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reducer, initialState);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyContext.Provider</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ state, dispatch }}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {children}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyContext.Provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><hr><h3 id="❌-错误方式-禁止" tabindex="-1">❌ 错误方式（禁止！） <a class="header-anchor" href="#❌-错误方式-禁止" aria-label="Permalink to “❌ 错误方式（禁止！）”">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接修改 state（不会触发 re-render）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数组件（即使用了 useState）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.user.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对象属性直接赋值</span></span></code></pre></div><hr><h3 id="✅-最佳实践总结-1" tabindex="-1">✅ 最佳实践总结 <a class="header-anchor" href="#✅-最佳实践总结-1" aria-label="Permalink to “✅ 最佳实践总结”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>简单状态（函数组件）</td><td><code>useState</code> + 函数式更新</td></tr><tr><td>复杂状态逻辑</td><td><code>useReducer</code> 或状态管理库</td></tr><tr><td>类组件（遗留代码）</td><td><code>this.setState</code> + 函数式更新</td></tr><tr><td>全局共享状态</td><td>Redux / Zustand / Context + useReducer</td></tr></tbody></table><blockquote><p>💡 <strong>关键原则</strong>：<br><strong>所有状态更新必须通过 React 的调度机制（setState / setter / dispatch）</strong>，确保虚拟 DOM 正确 diff 和渲染。</p></blockquote><h2 id="react有哪几种创建组件方法" tabindex="-1">React有哪几种创建组件方法 <a class="header-anchor" href="#react有哪几种创建组件方法" aria-label="Permalink to “React有哪几种创建组件方法”">​</a></h2><p>在 React 的发展历程中，创建组件的方式经历了多次演进。目前主要有以下 <strong>三种主流方式</strong>，其中前两种是现代 React 推荐的写法：</p><hr><h3 id="✅-1-函数组件-function-component-hooks-react-16-8-推荐" tabindex="-1">✅ 1. <strong>函数组件（Function Component） + Hooks（React 16.8+ 推荐）</strong> <a class="header-anchor" href="#✅-1-函数组件-function-component-hooks-react-16-8-推荐" aria-label="Permalink to “✅ 1. 函数组件（Function Component） + Hooks（React 16.8+ 推荐）”">​</a></h3><blockquote><p><strong>当前官方首选方式</strong>，简洁、高效、逻辑复用能力强。</p></blockquote><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 基础写法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Welcome</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, {props.name}!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Hooks 管理状态和副作用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useState, useEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.title </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Count: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [count]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;{count}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li>使用 <code>useState</code>、<code>useEffect</code> 等 Hooks 管理状态和生命周期</li><li>无 <code>this</code> 绑定问题</li><li>更易测试和优化</li><li>支持 TypeScript 类型推导</li></ul><hr><h3 id="✅-2-es6-类组件-class-component" tabindex="-1">✅ 2. <strong>ES6 类组件（Class Component）</strong> <a class="header-anchor" href="#✅-2-es6-类组件-class-component" aria-label="Permalink to “✅ 2. ES6 类组件（Class Component）”">​</a></h3><blockquote><p>React 16.8 之前的主要方式，现主要用于维护旧代码。</p></blockquote><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { Component } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Welcome</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(props);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  componentDidMount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.title </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Count: \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.count}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li>使用 <code>this.state</code> 和 <code>this.setState</code></li><li>通过生命周期方法（<code>componentDidMount</code> 等）处理副作用</li><li>需要绑定事件处理器（或使用箭头函数）</li><li>官方已不推荐新项目使用</li></ul><hr><h3 id="⚠️-3-react-createclass-已废弃" tabindex="-1">⚠️ 3. <strong>React.createClass（已废弃）</strong> <a class="header-anchor" href="#⚠️-3-react-createclass-已废弃" aria-label="Permalink to “⚠️ 3. React.createClass（已废弃）”">​</a></h3><blockquote><p>React 早期（v0.14 之前）的方式，<strong>现已完全废弃</strong>，仅用于了解历史。</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 不要使用！</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Welcome </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getInitialState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.name}!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><strong>淘汰原因</strong>：</p><ul><li>依赖 mixins（已被 Hooks 取代）</li><li>语法冗余</li><li>不符合现代 JavaScript 标准</li></ul><hr><h3 id="🔍-补充-特殊组件形式" tabindex="-1">🔍 补充：特殊组件形式 <a class="header-anchor" href="#🔍-补充-特殊组件形式" aria-label="Permalink to “🔍 补充：特殊组件形式”">​</a></h3><h4 id="•-高阶组件-hoc" tabindex="-1">• <strong>高阶组件（HOC）</strong> <a class="header-anchor" href="#•-高阶组件-hoc" aria-label="Permalink to “• 高阶组件（HOC）”">​</a></h4><p>不是创建组件的方式，而是<strong>复用组件逻辑的模式</strong>：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> withLoading</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">WrappedComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props.isLoading </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Loading...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WrappedComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props} /&gt;;</span></span></code></pre></div><h4 id="•-render-props" tabindex="-1">• <strong>Render Props</strong> <a class="header-anchor" href="#•-render-props" aria-label="Permalink to “• Render Props”">​</a></h4><p>同样是逻辑复用模式，非组件创建方式：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataProvider</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello {data.target}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;} /&gt;</span></span></code></pre></div><hr><h3 id="✅-总结-如何选择" tabindex="-1">✅ 总结：如何选择？ <a class="header-anchor" href="#✅-总结-如何选择" aria-label="Permalink to “✅ 总结：如何选择？”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td><strong>新项目开发</strong></td><td><strong>函数组件 + Hooks</strong>（官方强烈推荐）</td></tr><tr><td><strong>维护旧项目</strong></td><td>类组件（逐步迁移到函数组件）</td></tr><tr><td><strong>学习/面试</strong></td><td>了解类组件，但重点掌握函数组件</td></tr></tbody></table><blockquote><p>💡 <strong>核心结论</strong>：<br><strong>现代 React 开发 = 函数组件 + Hooks</strong>。类组件已成为历史，<code>createClass</code> 已彻底淘汰。</p></blockquote><h2 id="react中props和state有什么区别" tabindex="-1">react中props和state有什么区别 <a class="header-anchor" href="#react中props和state有什么区别" aria-label="Permalink to “react中props和state有什么区别”">​</a></h2><p>在 React 中，<code>props</code> 和 <code>state</code> 都是用于管理数据的机制，但它们在<strong>来源、可变性、用途和生命周期</strong>上有本质区别：</p><hr><h3 id="✅-核心区别对比表" tabindex="-1">✅ 核心区别对比表 <a class="header-anchor" href="#✅-核心区别对比表" aria-label="Permalink to “✅ 核心区别对比表”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th><strong>props</strong></th><th><strong>state</strong></th></tr></thead><tbody><tr><td><strong>来源</strong></td><td>由<strong>父组件传递</strong>（外部输入）</td><td>组件<strong>内部定义和管理</strong>（内部状态）</td></tr><tr><td><strong>可变性</strong></td><td><strong>只读（immutable）</strong><br>子组件不能修改 props</td><td><strong>可变（mutable）</strong><br>通过 <code>setState</code> / <code>useState</code> 更新</td></tr><tr><td><strong>用途</strong></td><td><strong>配置组件</strong>（如标题、回调函数、初始值）</td><td><strong>记录组件随时间变化的数据</strong>（如表单输入、计数器）</td></tr><tr><td><strong>更新方式</strong></td><td>父组件重新渲染时传入新值</td><td>组件自身调用状态更新函数</td></tr><tr><td><strong>生命周期</strong></td><td>每次父组件 re-render 都可能变化</td><td>在组件整个生命周期中持续存在（直到卸载）</td></tr><tr><td><strong>默认值</strong></td><td>可通过 <code>defaultProps</code>（类）或解构默认值（函数）设置</td><td>初始化时在 <code>constructor</code>（类）或 <code>useState</code>（函数）中设定</td></tr></tbody></table><hr><h3 id="📌-详细说明" tabindex="-1">📌 详细说明 <a class="header-anchor" href="#📌-详细说明" aria-label="Permalink to “📌 详细说明”">​</a></h3><h4 id="_1-props-组件的-输入参数" tabindex="-1">1. <strong>props：组件的“输入参数”</strong> <a class="header-anchor" href="#_1-props-组件的-输入参数" aria-label="Permalink to “1. props：组件的“输入参数””">​</a></h4><ul><li>类似函数的形参：<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UserCard</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onEdit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleEdit} /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserCard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">onEdit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{onEdit}&gt;{name}, {age}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><strong>子组件绝不能直接修改 props</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li></ul><h4 id="_2-state-组件的-私有记忆" tabindex="-1">2. <strong>state：组件的“私有记忆”</strong> <a class="header-anchor" href="#_2-state-组件的-私有记忆" aria-label="Permalink to “2. state：组件的“私有记忆””">​</a></h4><ul><li>用于保存会随用户交互或时间变化的数据：<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// state</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      Clicked {count} times</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><strong>只能通过 React 提供的方法更新</strong>（<code>setState</code> / <code>useState</code> 的 setter）</li></ul><hr><h3 id="🔁-数据流动原则-单向数据流" tabindex="-1">🔁 数据流动原则：<strong>单向数据流</strong> <a class="header-anchor" href="#🔁-数据流动原则-单向数据流" aria-label="Permalink to “🔁 数据流动原则：单向数据流”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>父组件 state </span></span>
<span class="line"><span>   ↓ （作为 props 传递）</span></span>
<span class="line"><span>子组件 props </span></span>
<span class="line"><span>   ↓ （触发父组件回调）</span></span>
<span class="line"><span>父组件更新自身 state </span></span>
<span class="line"><span>   ↓ （重新渲染，传递新 props）</span></span>
<span class="line"><span>子组件收到新 props</span></span></code></pre></div><blockquote><p>✅ 所有状态最终都应“提升”到最近的共同父组件管理。</p></blockquote><hr><h3 id="⚠️-常见误区" tabindex="-1">⚠️ 常见误区 <a class="header-anchor" href="#⚠️-常见误区" aria-label="Permalink to “⚠️ 常见误区”">​</a></h3><table tabindex="0"><thead><tr><th>误区</th><th>正确理解</th></tr></thead><tbody><tr><td>“props 是静态的”</td><td>props 会随父组件 re-render 而更新</td></tr><tr><td>“state 只能组件自己用”</td><td>state 可通过 props 传递给子组件（变成子组件的 props）</td></tr><tr><td>“props 和 state 不能互相转换”</td><td><strong>props 可初始化 state</strong>（但需谨慎！）：<br><code>const [name, setName] = useState(props.initialName)</code></td></tr></tbody></table><blockquote><p>💡 <strong>重要警告</strong>：<br><strong>不要用 props 直接初始化 state 后又期望它随 props 更新</strong>（会导致状态不同步）。此时应使用 <strong>受控组件</strong> 或 <code>useEffect</code> 同步。</p></blockquote><hr><h3 id="✅-总结一句话" tabindex="-1">✅ 总结一句话： <a class="header-anchor" href="#✅-总结一句话" aria-label="Permalink to “✅ 总结一句话：”">​</a></h3><blockquote><p><strong><code>props</code> 是组件的“输入”，由外部控制；<code>state</code> 是组件的“记忆”，由自身管理。两者共同驱动 UI 响应变化，但职责分明，不可混淆。</strong></p></blockquote><h2 id="react-中-keys-的作用是什么" tabindex="-1">React 中 keys 的作用是什么？ <a class="header-anchor" href="#react-中-keys-的作用是什么" aria-label="Permalink to “React 中 keys 的作用是什么？”">​</a></h2><p>在 React 中，<strong><code>key</code> 是用于识别列表中每个元素的唯一标识符</strong>，它的核心作用是：<strong>帮助 React 高效地更新（diff）列表，避免不必要的 DOM 操作，同时保持组件状态的正确性</strong>。</p><hr><h3 id="✅-一、key-的核心作用" tabindex="-1">✅ 一、<code>key</code> 的核心作用 <a class="header-anchor" href="#✅-一、key-的核心作用" aria-label="Permalink to “✅ 一、key 的核心作用”">​</a></h3><h4 id="_1-提升列表渲染性能-diff-优化" tabindex="-1">1. <strong>提升列表渲染性能（Diff 优化）</strong> <a class="header-anchor" href="#_1-提升列表渲染性能-diff-优化" aria-label="Permalink to “1. 提升列表渲染性能（Diff 优化）”">​</a></h4><ul><li>当列表变化（增删改）时，React 通过 <code>key</code> 判断哪些元素是<strong>新增、删除或移动</strong>的。</li><li>若没有 <code>key</code>（或使用 <code>index</code>），React 只能按<strong>位置顺序</strong>比较，导致大量 DOM 重建。</li><li>有稳定唯一的 <code>key</code>，React 能<strong>复用已有 DOM 节点和组件实例</strong>，仅更新必要部分。</li></ul><blockquote><p>📌 举例：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误：用 index 作 key（列表可变时）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Item</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{index} /&gt;)}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确：用唯一 ID</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Item</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{item.id} /&gt;)}</span></span></code></pre></div></blockquote><h4 id="_2-保持组件状态-state-正确" tabindex="-1">2. <strong>保持组件状态（State）正确</strong> <a class="header-anchor" href="#_2-保持组件状态-state-正确" aria-label="Permalink to “2. 保持组件状态（State）正确”">​</a></h4><ul><li>若 <code>key</code> 不稳定（如用 <code>Math.random()</code>），React 会认为这是<strong>全新元素</strong>，导致： <ul><li>组件被销毁重建</li><li>内部 state（如输入框内容、计数器）丢失</li></ul></li><li>稳定的 <code>key</code> 能确保<strong>相同逻辑项对应相同组件实例</strong>，状态得以保留。</li></ul><hr><h3 id="⚠️-二、使用-key-的注意事项" tabindex="-1">⚠️ 二、使用 <code>key</code> 的注意事项 <a class="header-anchor" href="#⚠️-二、使用-key-的注意事项" aria-label="Permalink to “⚠️ 二、使用 key 的注意事项”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>建议</th></tr></thead><tbody><tr><td><strong>列表项有唯一 ID</strong></td><td>优先使用 <code>item.id</code>、<code>item.uuid</code> 等</td></tr><tr><td><strong>静态列表（永不改变顺序/数量）</strong></td><td>可用 <code>index</code>（但不推荐）</td></tr><tr><td><strong>动态列表（可排序、增删）</strong></td><td><strong>绝对不要用 <code>index</code></strong>！会导致状态错乱</td></tr><tr><td><strong>key 必须在同一层级唯一</strong></td><td>不需要全局唯一，只需在兄弟节点中唯一</td></tr></tbody></table><blockquote><p>💡 示例：为什么 <code>index</code> 在动态列表中出问题？</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 初始: [A, B, C] → keys: [0,1,2]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除 A 后: [B, C] → keys 变为 [0,1]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 认为 B(原key=1) 变成了新 B(key=0)，C 同理 → 状态错位！</span></span></code></pre></div></blockquote><hr><h3 id="🔍-三、key-的工作原理-简化版" tabindex="-1">🔍 三、<code>key</code> 的工作原理（简化版） <a class="header-anchor" href="#🔍-三、key-的工作原理-简化版" aria-label="Permalink to “🔍 三、key 的工作原理（简化版）”">​</a></h3><p>React 在 reconciler（协调器）中执行以下逻辑：</p><ol><li>遍历新旧列表</li><li>通过 <code>key</code> 建立映射关系</li><li>对比： <ul><li><strong>相同 key</strong> → 复用组件，更新 props</li><li><strong>新 key</strong> → 创建新组件</li><li><strong>旧 key 消失</strong> → 卸载组件</li></ul></li><li>最小化 DOM 操作</li></ol><hr><h3 id="✅-四、最佳实践" tabindex="-1">✅ 四、最佳实践 <a class="header-anchor" href="#✅-四、最佳实践" aria-label="Permalink to “✅ 四、最佳实践”">​</a></h3><ul><li><strong>始终给列表项显式指定 <code>key</code></strong></li><li><strong>使用数据本身的唯一 ID</strong>（如数据库主键）</li><li><strong>避免使用 <code>index</code>、<code>random()</code>、<code>Date.now()</code> 等不稳定值</strong></li><li><strong>不要在 JSX 中计算复杂 key</strong>（影响性能）</li></ul><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 推荐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{users.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UserCard</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{user.id} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{user} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 避免</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{users.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UserCard</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{i} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{user} /&gt; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 若 users 可增删/排序，会出 bug</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))}</span></span></code></pre></div><hr><h3 id="💡-总结一句话" tabindex="-1">💡 总结一句话： <a class="header-anchor" href="#💡-总结一句话" aria-label="Permalink to “💡 总结一句话：”">​</a></h3><blockquote><p><strong><code>key</code> 是 React 识别列表元素身份的“身份证号”——稳定且唯一，才能让更新高效、状态可靠。</strong></p></blockquote><h2 id="react-中-refs-的作用是什么" tabindex="-1">React 中 refs 的作用是什么？ <a class="header-anchor" href="#react-中-refs-的作用是什么" aria-label="Permalink to “React 中 refs 的作用是什么？”">​</a></h2><p>在 React 中，<strong><code>ref</code>（引用）用于直接访问 DOM 元素或类组件实例</strong>，绕过 React 的声明式数据流，实现<strong>命令式操作</strong>。它是 React 提供的“逃生舱”（escape hatch），用于处理那些无法通过 <code>props</code> 和 <code>state</code> 解决的场景。</p><hr><h3 id="✅-一、ref-的核心作用" tabindex="-1">✅ 一、<code>ref</code> 的核心作用 <a class="header-anchor" href="#✅-一、ref-的核心作用" aria-label="Permalink to “✅ 一、ref 的核心作用”">​</a></h3><h4 id="_1-访问-dom-元素" tabindex="-1">1. <strong>访问 DOM 元素</strong> <a class="header-anchor" href="#_1-访问-dom-元素" aria-label="Permalink to “1. 访问 DOM 元素”">​</a></h4><ul><li>获取原生 DOM 节点，执行命令式操作（如聚焦、滚动、测量尺寸）：<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  inputRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动聚焦</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{inputRef} /&gt;;</span></span></code></pre></div></li></ul><h4 id="_2-访问类组件实例" tabindex="-1">2. <strong>访问类组件实例</strong> <a class="header-anchor" href="#_2-访问类组件实例" aria-label="Permalink to “2. 访问类组件实例”">​</a></h4><ul><li>调用子组件的方法（函数组件需配合 <code>forwardRef</code> + <code>useImperativeHandle</code>）：<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子组件（类）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  scrollDown</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> childRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> childRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scrollDown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{childRef} /&gt;;</span></span></code></pre></div></li></ul><h4 id="_3-保存可变值-类似实例变量" tabindex="-1">3. <strong>保存可变值（类似实例变量）</strong> <a class="header-anchor" href="#_3-保存可变值-类似实例变量" aria-label="Permalink to “3. 保存可变值（类似实例变量）”">​</a></h4><ul><li>在组件整个生命周期中<strong>持久存储数据</strong>，且<strong>修改它不会触发 re-render</strong>：<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> countRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  countRef.current</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不会重新渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(countRef.current);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><hr><h3 id="⚠️-二、使用-ref-的注意事项" tabindex="-1">⚠️ 二、使用 <code>ref</code> 的注意事项 <a class="header-anchor" href="#⚠️-二、使用-ref-的注意事项" aria-label="Permalink to “⚠️ 二、使用 ref 的注意事项”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td><strong>函数组件默认不能被 ref 引用</strong></td><td>需用 <code>forwardRef</code> 包装</td></tr><tr><td><strong>避免过度使用</strong></td><td>破坏 React 声明式理念，应优先用 state/props</td></tr><tr><td><strong>不能用于条件渲染的元素</strong></td><td>若元素可能为 <code>null</code>，<code>ref.current</code> 可能为 <code>null</code></td></tr><tr><td><strong>不要在 render 中读取 ref.current</strong></td><td>可能获取到旧值（应在 <code>useEffect</code> 中读取）</td></tr></tbody></table><hr><h3 id="🔧-三、常用-api" tabindex="-1">🔧 三、常用 API <a class="header-anchor" href="#🔧-三、常用-api" aria-label="Permalink to “🔧 三、常用 API”">​</a></h3><h4 id="_1-useref-函数组件" tabindex="-1">1. <strong><code>useRef()</code>（函数组件）</strong> <a class="header-anchor" href="#_1-useref-函数组件" aria-label="Permalink to “1. useRef()（函数组件）”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initialValue);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ref.current 可读写</span></span></code></pre></div><h4 id="_2-createref-类组件" tabindex="-1">2. <strong><code>createRef()</code>（类组件）</strong> <a class="header-anchor" href="#_2-createref-类组件" aria-label="Permalink to “2. createRef()（类组件）”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  inputRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.inputRef} /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3-forwardref-转发-ref-到子组件" tabindex="-1">3. <strong><code>forwardRef</code>（转发 ref 到子组件）</strong> <a class="header-anchor" href="#_3-forwardref-转发-ref-到子组件" aria-label="Permalink to “3. forwardRef（转发 ref 到子组件）”">​</a></h4><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FancyInput</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> forwardRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ref} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fancy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><h4 id="_4-useimperativehandle-自定义暴露给父组件的方法" tabindex="-1">4. <strong><code>useImperativeHandle</code>（自定义暴露给父组件的方法）</strong> <a class="header-anchor" href="#_4-useimperativehandle-自定义暴露给父组件的方法" aria-label="Permalink to “4. useImperativeHandle（自定义暴露给父组件的方法）”">​</a></h4><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> forwardRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useImperativeHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ref, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputRef.current.value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{inputRef} /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h3 id="🚫-四、什么情况下不应该用-ref" tabindex="-1">🚫 四、什么情况下<strong>不应该</strong>用 <code>ref</code>？ <a class="header-anchor" href="#🚫-四、什么情况下不应该用-ref" aria-label="Permalink to “🚫 四、什么情况下不应该用 ref？”">​</a></h3><ul><li><strong>可以通过 <code>props</code> 或 <code>state</code> 实现的逻辑</strong><br> （例如：控制显示/隐藏 → 用 <code>state</code>；传递数据 → 用 <code>props</code>）</li><li><strong>试图“强制更新”组件</strong><br> （应检查 state/props 依赖是否正确）</li></ul><hr><h3 id="✅-五、典型使用场景" tabindex="-1">✅ 五、典型使用场景 <a class="header-anchor" href="#✅-五、典型使用场景" aria-label="Permalink to “✅ 五、典型使用场景”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>示例</th></tr></thead><tbody><tr><td>自动聚焦输入框</td><td>登录页用户名输入框</td></tr><tr><td>触发第三方库</td><td>初始化地图、视频播放器</td></tr><tr><td>测量 DOM 尺寸</td><td>动态计算容器高度</td></tr><tr><td>管理焦点/滚动</td><td>聊天窗口自动滚到底部</td></tr><tr><td>暴露子组件方法</td><td>父组件调用子组件的验证方法</td></tr></tbody></table><hr><h3 id="💡-总结一句话-1" tabindex="-1">💡 总结一句话： <a class="header-anchor" href="#💡-总结一句话-1" aria-label="Permalink to “💡 总结一句话：”">​</a></h3><blockquote><p><strong><code>ref</code> 是 React 中用于命令式操作的工具——当你需要“直接动手”而不是“声明意图”时才使用它，且应尽量限制其使用范围。</strong></p></blockquote><h2 id="react-diff-原理" tabindex="-1">React diff 原理 <a class="header-anchor" href="#react-diff-原理" aria-label="Permalink to “React diff 原理”">​</a></h2><p>React 的 <strong>Diff 算法</strong>（也称为 <strong>Reconciliation 协调算法</strong>）是 React 高性能的核心机制之一。它的目标是：<strong>在状态更新时，以最小的代价计算出需要对真实 DOM 做哪些修改</strong>。</p><blockquote><p>💡 注意：React 并没有使用传统的“全量 diff”（如 Git），而是基于<strong>两个核心假设</strong>设计了一套<strong>启发式 O(n) 算法</strong>。</p></blockquote><hr><h3 id="一、react-diff-的三大核心策略" tabindex="-1">一、React Diff 的三大核心策略 <a class="header-anchor" href="#一、react-diff-的三大核心策略" aria-label="Permalink to “一、React Diff 的三大核心策略”">​</a></h3><h4 id="✅-1-层级优先-tree-diff" tabindex="-1">✅ 1. <strong>层级优先（Tree Diff）</strong> <a class="header-anchor" href="#✅-1-层级优先-tree-diff" aria-label="Permalink to “✅ 1. 层级优先（Tree Diff）”">​</a></h4><ul><li><strong>只对同层级的节点进行比较</strong>，忽略跨层级移动。</li><li>如果某节点类型不同（如 <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code>），<strong>直接销毁整棵子树并重建</strong>。<div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新前</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hi&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新后</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hi&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// → div 被销毁，新建 p + span</span></span></code></pre></div></li></ul><blockquote><p>📌 <strong>原因</strong>：跨层级移动在实际开发中极少发生，此假设可将复杂度从 O(n³) 降至 O(n)。</p></blockquote><hr><h4 id="✅-2-组件类型决定是否复用-component-diff" tabindex="-1">✅ 2. <strong>组件类型决定是否复用（Component Diff）</strong> <a class="header-anchor" href="#✅-2-组件类型决定是否复用-component-diff" aria-label="Permalink to “✅ 2. 组件类型决定是否复用（Component Diff）”">​</a></h4><ul><li>如果组件类型相同（如 <code>MyButton</code> → <code>MyButton</code>），<strong>复用组件实例</strong>，仅更新 props。</li><li>如果组件类型不同（如 <code>MyButton</code> → <code>YourButton</code>），<strong>销毁旧组件及其子树，创建新组件</strong>。</li></ul><blockquote><p>💡 这就是为什么<strong>自定义组件首字母必须大写</strong>——避免与 HTML 标签混淆导致意外重建。</p></blockquote><hr><h4 id="✅-3-列表通过-key-优化-element-diff" tabindex="-1">✅ 3. <strong>列表通过 key 优化（Element Diff）</strong> <a class="header-anchor" href="#✅-3-列表通过-key-优化-element-diff" aria-label="Permalink to “✅ 3. 列表通过 key 优化（Element Diff）”">​</a></h4><ul><li>对于兄弟节点列表，React 默认按<strong>顺序逐个对比</strong>。</li><li>若未提供 <code>key</code>，插入/删除中间项会导致后续所有节点被重建。</li><li><strong>提供唯一稳定的 <code>key</code> 后</strong>，React 能： <ul><li>识别哪些元素是新增、删除或移动的</li><li><strong>复用已有 DOM 节点和组件实例</strong></li><li>保持内部状态（如输入框内容）</li></ul></li></ul><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 无 key：列表变化时全部重建</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{item}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 有 key：精准复用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{item.id}&gt;{item.text}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)}</span></span></code></pre></div><hr><h3 id="二、diff-过程详解-fiber-架构下" tabindex="-1">二、Diff 过程详解（Fiber 架构下） <a class="header-anchor" href="#二、diff-过程详解-fiber-架构下" aria-label="Permalink to “二、Diff 过程详解（Fiber 架构下）”">​</a></h3><p>React 16+ 使用 <strong>Fiber Reconciler</strong>，将 Diff 过程拆分为可中断的单元：</p><ol><li><p><strong>生成 Fiber 树</strong></p><ul><li>每个组件/元素对应一个 Fiber 节点</li><li>形成链表结构（child/sibling/return 指针），替代递归</li></ul></li><li><p><strong>双缓冲机制（Double Buffering）</strong></p><ul><li>维护两棵树：<code>current</code>（已渲染）和 <code>workInProgress</code>（正在构建）</li><li>更新在 <code>workInProgress</code> 上进行，完成后原子切换</li></ul></li><li><p><strong>可中断 &amp; 优先级调度</strong></p><ul><li>每处理一个 Fiber 节点，检查是否需让出主线程</li><li>高优先级更新（如用户输入）可打断低优先级更新</li></ul></li></ol><hr><h3 id="三、关键优化点总结" tabindex="-1">三、关键优化点总结 <a class="header-anchor" href="#三、关键优化点总结" aria-label="Permalink to “三、关键优化点总结”">​</a></h3><table tabindex="0"><thead><tr><th>问题</th><th>React 的解决方案</th></tr></thead><tbody><tr><td>全量 diff 太慢</td><td><strong>只 diff 同层级</strong></td></tr><tr><td>组件状态丢失</td><td><strong>类型相同则复用实例</strong></td></tr><tr><td>列表更新低效</td><td><strong>依赖 <code>key</code> 精准匹配</strong></td></tr><tr><td>长任务阻塞 UI</td><td><strong>Fiber 可中断 + 优先级调度</strong></td></tr></tbody></table><hr><h3 id="⚠️-开发者注意事项" tabindex="-1">⚠️ 开发者注意事项 <a class="header-anchor" href="#⚠️-开发者注意事项" aria-label="Permalink to “⚠️ 开发者注意事项”">​</a></h3><ol><li><strong>永远为列表提供稳定唯一的 <code>key</code></strong>（不用 index！）</li><li><strong>避免不必要的组件类型变化</strong>（如条件渲染用 CSS 而非切换组件）</li><li><strong>不要依赖 Diff 行为做副作用</strong>（如手动操作 DOM）</li></ol><hr><h3 id="💡-一句话总结" tabindex="-1">💡 一句话总结： <a class="header-anchor" href="#💡-一句话总结" aria-label="Permalink to “💡 一句话总结：”">​</a></h3><blockquote><p>React Diff 不是“完美算法”，而是<strong>基于合理假设的高效启发式策略</strong>——通过<strong>层级限制 + 类型复用 + key 优化</strong>，在 O(n) 时间内完成更新，兼顾性能与开发体验。</p></blockquote><h2 id="受控组件和非受控组件有什么区别" tabindex="-1">受控组件和非受控组件有什么区别？ <a class="header-anchor" href="#受控组件和非受控组件有什么区别" aria-label="Permalink to “受控组件和非受控组件有什么区别？”">​</a></h2><p>在 React 中，<strong>受控组件（Controlled Component）</strong> 和 <strong>非受控组件（Uncontrolled Component）</strong> 是处理表单输入（如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>）的两种不同模式，核心区别在于：<strong>谁“掌控”表单元素的值</strong>。</p><hr><h3 id="✅-一、受控组件-controlled-component" tabindex="-1">✅ 一、受控组件（Controlled Component） <a class="header-anchor" href="#✅-一、受控组件-controlled-component" aria-label="Permalink to “✅ 一、受控组件（Controlled Component）”">​</a></h3><h4 id="🔹-定义" tabindex="-1">🔹 定义： <a class="header-anchor" href="#🔹-定义" aria-label="Permalink to “🔹 定义：”">​</a></h4><ul><li>表单元素的 <strong>值由 React 的 state 控制</strong></li><li>每次用户输入，都通过 <code>onChange</code> 更新 state，从而驱动 UI</li></ul><h4 id="🔹-特点" tabindex="-1">🔹 特点： <a class="header-anchor" href="#🔹-特点" aria-label="Permalink to “🔹 特点：”">​</a></h4><ul><li><strong>值 = state</strong></li><li><strong>变更 = setState</strong></li><li><strong>完全受 React 管理</strong></li></ul><h4 id="🔹-示例" tabindex="-1">🔹 示例： <a class="header-anchor" href="#🔹-示例" aria-label="Permalink to “🔹 示例：”">​</a></h4><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ControlledInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{value}          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 值来自 state</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      onChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.target.value)} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 受控更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="🔹-优点" tabindex="-1">🔹 优点： <a class="header-anchor" href="#🔹-优点" aria-label="Permalink to “🔹 优点：”">​</a></h4><ul><li><strong>状态集中管理</strong>，便于校验、格式化、同步</li><li>支持<strong>即时反馈</strong>（如输入时实时搜索）</li><li>符合 React <strong>单向数据流</strong>理念</li></ul><h4 id="🔹-缺点" tabindex="-1">🔹 缺点： <a class="header-anchor" href="#🔹-缺点" aria-label="Permalink to “🔹 缺点：”">​</a></h4><ul><li>代码稍多（需写 <code>onChange</code> 处理器）</li></ul><hr><h3 id="✅-二、非受控组件-uncontrolled-component" tabindex="-1">✅ 二、非受控组件（Uncontrolled Component） <a class="header-anchor" href="#✅-二、非受控组件-uncontrolled-component" aria-label="Permalink to “✅ 二、非受控组件（Uncontrolled Component）”">​</a></h3><h4 id="🔹-定义-1" tabindex="-1">🔹 定义： <a class="header-anchor" href="#🔹-定义-1" aria-label="Permalink to “🔹 定义：”">​</a></h4><ul><li>表单元素的 <strong>值由 DOM 自身管理</strong></li><li>React 通过 <code>ref</code> 在需要时读取当前值</li></ul><h4 id="🔹-特点-1" tabindex="-1">🔹 特点： <a class="header-anchor" href="#🔹-特点-1" aria-label="Permalink to “🔹 特点：”">​</a></h4><ul><li><strong>值 = DOM 元素的 value 属性</strong></li><li><strong>变更 = 用户直接操作 DOM</strong></li><li>React <strong>不监听每次变化</strong></li></ul><h4 id="🔹-示例-1" tabindex="-1">🔹 示例： <a class="header-anchor" href="#🔹-示例-1" aria-label="Permalink to “🔹 示例：”">​</a></h4><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UncontrolledInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleSubmit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputRef.current.value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 提交时读取值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{inputRef}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      defaultValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;初始值&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 注意：用 defaultValue 而非 value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="🔹-优点-1" tabindex="-1">🔹 优点： <a class="header-anchor" href="#🔹-优点-1" aria-label="Permalink to “🔹 优点：”">​</a></h4><ul><li>代码简洁（无需 <code>onChange</code>）</li><li>适合<strong>一次性读取</strong>（如登录表单提交）</li></ul><h4 id="🔹-缺点-1" tabindex="-1">🔹 缺点： <a class="header-anchor" href="#🔹-缺点-1" aria-label="Permalink to “🔹 缺点：”">​</a></h4><ul><li>无法实时响应输入变化</li><li>难以实现复杂交互（如输入格式化、联动校验）</li></ul><hr><h3 id="🆚-三、核心区别对比表" tabindex="-1">🆚 三、核心区别对比表 <a class="header-anchor" href="#🆚-三、核心区别对比表" aria-label="Permalink to “🆚 三、核心区别对比表”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>受控组件</th><th>非受控组件</th></tr></thead><tbody><tr><td><strong>值的来源</strong></td><td>React state</td><td>DOM 自身</td></tr><tr><td><strong>更新方式</strong></td><td><code>onChange</code> + <code>setState</code></td><td>用户直接输入</td></tr><tr><td><strong>获取值时机</strong></td><td>实时（state 即最新值）</td><td>需通过 <code>ref</code> 主动读取</td></tr><tr><td><strong>初始值属性</strong></td><td><code>value</code></td><td><code>defaultValue</code> / <code>defaultChecked</code></td></tr><tr><td><strong>适用场景</strong></td><td>需要实时控制/校验的表单</td><td>简单表单、集成第三方库</td></tr><tr><td><strong>是否符合 React 哲学</strong></td><td>✅ 是</td><td>⚠️ “逃生舱”（escape hatch）</td></tr></tbody></table><hr><h3 id="⚠️-四、常见误区" tabindex="-1">⚠️ 四、常见误区 <a class="header-anchor" href="#⚠️-四、常见误区" aria-label="Permalink to “⚠️ 四、常见误区”">​</a></h3><ol><li><p><strong>混淆 <code>value</code> 和 <code>defaultValue</code></strong></p><ul><li>受控：必须用 <code>value</code></li><li>非受控：用 <code>defaultValue</code>（否则会变成只读）</li></ul></li><li><p><strong>在非受控组件中使用 <code>value</code></strong></p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误：value 固定为 &quot;hello&quot;，输入无效！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div></li><li><p><strong>混合使用</strong></p><ul><li>同一个表单字段不要同时用 <code>value</code> + <code>ref</code> 控制</li></ul></li></ol><hr><h3 id="✅-五、如何选择" tabindex="-1">✅ 五、如何选择？ <a class="header-anchor" href="#✅-五、如何选择" aria-label="Permalink to “✅ 五、如何选择？”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>表单需实时校验/格式化</td><td><strong>受控组件</strong></td></tr><tr><td>简单登录/注册表单</td><td>非受控（或受控均可）</td></tr><tr><td>集成 jQuery 插件等第三方库</td><td><strong>非受控组件</strong>（避免冲突）</td></tr><tr><td>文件上传 <code>&lt;input type=&quot;file&quot;&gt;</code></td><td><strong>必须非受控</strong>（value 只读）</td></tr></tbody></table><hr><h3 id="💡-总结一句话-2" tabindex="-1">💡 总结一句话： <a class="header-anchor" href="#💡-总结一句话-2" aria-label="Permalink to “💡 总结一句话：”">​</a></h3><blockquote><p><strong>受控组件 = React 主导一切；非受控组件 = DOM 自主管理，React 按需读取。优先使用受控组件，非受控仅作补充。</strong></p></blockquote><h2 id="为什么虚拟-dom-会提高性能" tabindex="-1">为什么虚拟 dom 会提高性能? <a class="header-anchor" href="#为什么虚拟-dom-会提高性能" aria-label="Permalink to “为什么虚拟 dom 会提高性能?”">​</a></h2><p>虚拟 DOM（Virtual DOM）之所以能提高性能，<strong>核心原因不是它本身“快”，而是它通过“批量、最小化、可优化”的方式减少昂贵的真实 DOM 操作</strong>。以下是详细解析：</p><hr><h3 id="一、真实-dom-操作为什么慢" tabindex="-1">一、真实 DOM 操作为什么慢？ <a class="header-anchor" href="#一、真实-dom-操作为什么慢" aria-label="Permalink to “一、真实 DOM 操作为什么慢？”">​</a></h3><ol><li><p><strong>浏览器渲染流程复杂</strong><br> 修改真实 DOM 会触发：</p><ul><li><strong>Reflow（回流）</strong>：重新计算元素几何位置（如宽高、布局）</li><li><strong>Repaint（重绘）</strong>：重新绘制像素（如颜色、背景）</li></ul><blockquote><p>⚠️ 这两个过程非常耗时，尤其在复杂页面中。</p></blockquote></li><li><p><strong>频繁操作导致性能瓶颈</strong><br> 若直接操作 DOM（如循环中多次 <code>appendChild</code>），浏览器会反复触发 Reflow/Repaint。</p></li></ol><hr><h3 id="二、虚拟-dom-如何优化" tabindex="-1">二、虚拟 DOM 如何优化？ <a class="header-anchor" href="#二、虚拟-dom-如何优化" aria-label="Permalink to “二、虚拟 DOM 如何优化？”">​</a></h3><h4 id="✅-1-批量更新-batching" tabindex="-1">✅ 1. <strong>批量更新（Batching）</strong> <a class="header-anchor" href="#✅-1-批量更新-batching" aria-label="Permalink to “✅ 1. 批量更新（Batching）”">​</a></h4><ul><li>React 将多次 <code>setState</code> 合并为<strong>一次更新</strong>，避免重复渲染。</li><li>虚拟 DOM 先在内存中完成所有变更，<strong>最后一次性同步到真实 DOM</strong>。</li></ul><h4 id="✅-2-diff-算法-协调算法" tabindex="-1">✅ 2. <strong>Diff 算法（协调算法）</strong> <a class="header-anchor" href="#✅-2-diff-算法-协调算法" aria-label="Permalink to “✅ 2. Diff 算法（协调算法）”">​</a></h4><ul><li>通过高效的 <strong>O(n) 启发式 Diff</strong>（基于层级、组件类型、key），<strong>精准找出最小变更集</strong>。</li><li>只更新<strong>真正变化的节点</strong>，避免全量替换。</li></ul><blockquote><p>📌 对比：<br> 直接操作 DOM → 每次修改都触发布局计算<br> 虚拟 DOM → 内存中计算差异 → 仅提交必要修改</p></blockquote><h4 id="✅-3-跨平台抽象" tabindex="-1">✅ 3. <strong>跨平台抽象</strong> <a class="header-anchor" href="#✅-3-跨平台抽象" aria-label="Permalink to “✅ 3. 跨平台抽象”">​</a></h4><ul><li>虚拟 DOM 是<strong>纯 JavaScript 对象</strong>，与平台无关。</li><li>同一套 diff 逻辑可用于 Web（ReactDOM）、移动端（React Native）、甚至 VR。</li></ul><h4 id="✅-4-开发体验与性能平衡" tabindex="-1">✅ 4. <strong>开发体验与性能平衡</strong> <a class="header-anchor" href="#✅-4-开发体验与性能平衡" aria-label="Permalink to “✅ 4. 开发体验与性能平衡”">​</a></h4><ul><li>开发者只需声明“UI 应该是什么样子”（声明式），无需手动优化 DOM 操作。</li><li>React 在底层自动处理性能问题。</li></ul><hr><h3 id="三、虚拟-dom-并非总是更快" tabindex="-1">三、虚拟 DOM 并非总是更快！ <a class="header-anchor" href="#三、虚拟-dom-并非总是更快" aria-label="Permalink to “三、虚拟 DOM 并非总是更快！”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>虚拟 DOM</th><th>直接操作 DOM</th></tr></thead><tbody><tr><td><strong>简单静态页面</strong></td><td>❌ 有额外内存和计算开销</td><td>✅ 更快</td></tr><tr><td><strong>高频动态更新</strong></td><td>✅ 批量 + Diff 优势明显</td><td>❌ 易写出低效代码</td></tr><tr><td><strong>极致性能场景</strong>（如游戏）</td><td>⚠️ 可能成为瓶颈</td><td>✅ 手动优化更高效</td></tr></tbody></table><blockquote><p>💡 <strong>关键结论</strong>：<br> 虚拟 DOM 的价值不在于“绝对速度”，而在于 <strong>“以合理的性能代价，换取开发效率和可维护性”</strong>。</p></blockquote><hr><h3 id="四、现代优化-fiber-架构进一步提升" tabindex="-1">四、现代优化：Fiber 架构进一步提升 <a class="header-anchor" href="#四、现代优化-fiber-架构进一步提升" aria-label="Permalink to “四、现代优化：Fiber 架构进一步提升”">​</a></h3><p>React 16+ 的 <strong>Fiber Reconciler</strong> 让虚拟 DOM 更智能：</p><ul><li><strong>可中断渲染</strong>：高优先级任务（如用户输入）可打断低优先级更新</li><li><strong>增量更新</strong>：将 Diff 拆分为小任务，避免主线程长时间阻塞</li></ul><hr><h3 id="✅-总结一句话-1" tabindex="-1">✅ 总结一句话： <a class="header-anchor" href="#✅-总结一句话-1" aria-label="Permalink to “✅ 总结一句话：”">​</a></h3><blockquote><p><strong>虚拟 DOM 通过“内存中计算差异 + 批量最小化更新”，避免了开发者手动优化 DOM 的复杂性，在大多数应用中实现了性能与开发效率的最佳平衡。</strong></p></blockquote>`,560)])])}const c=i(l,[["render",h]]);export{E as __pageData,c as default};
