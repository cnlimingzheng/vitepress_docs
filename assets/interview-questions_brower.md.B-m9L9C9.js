import{_ as i,c as t,o as a,aj as e,b3 as n}from"./chunks/framework.Dm5fGzKW.js";const c=JSON.parse('{"title":"HTTP和浏览器","description":"","frontmatter":{},"headers":[],"relativePath":"interview-questions/brower.md","filePath":"interview-questions/brower.md"}'),l={name:"interview-questions/brower.md"};function r(o,s,h,d,g,k){return a(),t("div",null,[...s[0]||(s[0]=[e(`<h1 id="http和浏览器" tabindex="-1">HTTP和浏览器 <a class="header-anchor" href="#http和浏览器" aria-label="Permalink to “HTTP和浏览器”">​</a></h1><h2 id="get和post有什么区别" tabindex="-1">GET和POST有什么区别 <a class="header-anchor" href="#get和post有什么区别" aria-label="Permalink to “GET和POST有什么区别”">​</a></h2><p>GET 和 POST 是 HTTP 协议中最常用的两种请求方法，核心区别如下：</p><ol><li><p><strong>语义不同</strong></p><ul><li>GET：用于<strong>获取</strong>资源，应是安全（不修改服务器状态）且幂等的。</li><li>POST：用于<strong>提交</strong>数据，通常会改变服务器状态，非幂等。</li></ul></li><li><p><strong>参数位置</strong></p><ul><li>GET：参数附在 URL 的查询字符串中（?key=value）。</li><li>POST：参数放在请求体（body）中。</li></ul></li><li><p><strong>长度与编码限制</strong></p><ul><li>GET：受 URL 长度限制（浏览器/服务器通常限制 2KB~8KB），仅支持 ASCII 编码。</li><li>POST：无长度限制（理论上），支持多种编码（如 multipart/form-data、application/json 等）。</li></ul></li><li><p><strong>安全性</strong></p><ul><li>GET：参数暴露在 URL 中，易被记录（历史、日志、书签），<strong>不适合传敏感信息</strong>。</li><li>POST：参数在 body 中，相对更安全（但 HTTPS 才是关键）。</li></ul></li><li><p><strong>缓存与书签</strong></p><ul><li>GET：可被缓存、收藏为书签。</li><li>POST：不可缓存，不能直接通过 URL 重现。</li></ul></li><li><p><strong>TCP 行为（常见误解澄清）</strong></p><ul><li>并非“GET 一次包、POST 两次包”——实际取决于实现和是否带 body，现代浏览器对两者都可能合并或分片传输。</li></ul></li></ol><blockquote><p>总结：<strong>用 GET 获取数据，用 POST 提交数据；安全性和语义比技术细节更重要。</strong></p></blockquote><h2 id="http2相对于http1-x有什么优势和特点" tabindex="-1">HTTP2相对于HTTP1.x有什么优势和特点 <a class="header-anchor" href="#http2相对于http1-x有什么优势和特点" aria-label="Permalink to “HTTP2相对于HTTP1.x有什么优势和特点”">​</a></h2><p>HTTP/2 相对于 HTTP/1.x 的核心优势和特点可高度概括如下：</p><ol><li><p><strong>二进制分帧（Binary Framing）</strong></p><ul><li>将请求和响应拆分为二进制帧（frame），提升解析效率和协议健壮性，取代 HTTP/1.x 的文本格式。</li></ul></li><li><p><strong>多路复用（Multiplexing）</strong></p><ul><li>单个 TCP 连接上可并行传输多个请求/响应流（stream），彻底解决 HTTP/1.x 的“队头阻塞”问题，无需域名分片或连接池。</li></ul></li><li><p><strong>头部压缩（HPACK）</strong></p><ul><li>使用 HPACK 算法压缩头部，避免重复字段冗余传输，显著减少带宽消耗（尤其对含 Cookie 的请求）。</li></ul></li><li><p><strong>服务器推送（Server Push）</strong></p><ul><li>服务器可主动向客户端推送资源（如 CSS、JS），无需等待客户端请求，优化关键渲染路径。</li></ul></li><li><p><strong>优先级与流控制</strong></p><ul><li>支持为流设置优先级，客户端可告知服务器资源加载顺序；同时提供细粒度的流量控制机制。</li></ul></li><li><p><strong>兼容性</strong></p><ul><li>语义层（方法、状态码、Header 等）与 HTTP/1.x 完全兼容，仅传输层重构，现有 Web 应用无需重写。</li></ul></li></ol><blockquote><p>总结：<strong>HTTP/2 通过二进制分帧 + 多路复用 + 头部压缩，在单连接上实现高效、低延迟、低开销的通信，大幅提升页面加载性能。</strong></p></blockquote><h2 id="https是怎么保证安全的-为什么比http安全" tabindex="-1">https是怎么保证安全的，为什么比http安全 <a class="header-anchor" href="#https是怎么保证安全的-为什么比http安全" aria-label="Permalink to “https是怎么保证安全的，为什么比http安全”">​</a></h2><p>HTTPS 本质是 <strong>HTTP over TLS/SSL</strong>，其安全性源于在传输层引入了加密、认证和完整性保护机制。相比 HTTP（明文传输），核心安全优势如下：</p><hr><h3 id="_1-加密-confidentiality" tabindex="-1">1. <strong>加密（Confidentiality）</strong> <a class="header-anchor" href="#_1-加密-confidentiality" aria-label="Permalink to “1. 加密（Confidentiality）”">​</a></h3><ul><li><strong>对称加密 + 非对称加密混合机制</strong>： <ul><li>非对称加密（如 RSA、ECDHE）用于安全交换<strong>会话密钥</strong>；</li><li>对称加密（如 AES）用该密钥加密实际传输数据，兼顾效率与安全。</li></ul></li><li><strong>结果</strong>：即使被中间人截获，也无法读取内容。</li></ul><h3 id="_2-身份认证-authentication" tabindex="-1">2. <strong>身份认证（Authentication）</strong> <a class="header-anchor" href="#_2-身份认证-authentication" aria-label="Permalink to “2. 身份认证（Authentication）”">​</a></h3><ul><li>服务器通过 <strong>数字证书（由可信 CA 签发）</strong> 证明身份；</li><li>客户端验证证书有效性（域名匹配、未过期、CA 信任链等），防止“冒充”。</li><li>（可选）客户端也可提供证书实现双向认证。</li></ul><h3 id="_3-数据完整性-integrity" tabindex="-1">3. <strong>数据完整性（Integrity）</strong> <a class="header-anchor" href="#_3-数据完整性-integrity" aria-label="Permalink to “3. 数据完整性（Integrity）”">​</a></h3><ul><li>使用 <strong>MAC（消息认证码）或 AEAD 加密模式</strong>，确保数据在传输中未被篡改。</li></ul><hr><h3 id="为什么比-http-安全" tabindex="-1">为什么比 HTTP 安全？ <a class="header-anchor" href="#为什么比-http-安全" aria-label="Permalink to “为什么比 HTTP 安全？”">​</a></h3><table tabindex="0"><thead><tr><th>维度</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>数据可见性</td><td>明文，可被嗅探</td><td>加密，不可读</td></tr><tr><td>身份验证</td><td>无</td><td>通过证书验证服务器身份</td></tr><tr><td>数据篡改</td><td>可被中间人修改（如注入广告）</td><td>篡改会导致校验失败，连接终止</td></tr><tr><td>会话劫持</td><td>Cookie 等易被盗用</td><td>加密保护敏感信息</td></tr></tbody></table><blockquote><p>💡 <strong>关键点</strong>：HTTPS 的安全不在于“协议本身”，而在于 <strong>TLS 层提供的密码学保障</strong>。HTTP 无任何安全机制，所有数据裸奔；HTTPS 在 TCP 之上构建了可信通道。</p></blockquote><blockquote><p>⚠️ 注意：HTTPS 不能防 XSS、CSRF 或业务逻辑漏洞，仅保障<strong>传输过程</strong>安全。</p></blockquote><h2 id="http的状态码有哪些-并代表什么意思" tabindex="-1">HTTP的状态码有哪些？并代表什么意思？ <a class="header-anchor" href="#http的状态码有哪些-并代表什么意思" aria-label="Permalink to “HTTP的状态码有哪些？并代表什么意思？”">​</a></h2><p>HTTP 状态码是服务器对客户端请求的响应结果分类，共5大类（以首位数字区分），以下是<strong>前端工程师需重点掌握的核心状态码及含义</strong>：</p><hr><h3 id="_1xx-信息性-临时响应" tabindex="-1"><strong>1xx：信息性（临时响应）</strong> <a class="header-anchor" href="#_1xx-信息性-临时响应" aria-label="Permalink to “1xx：信息性（临时响应）”">​</a></h3><ul><li><strong>100 Continue</strong>：客户端应继续发送请求体（用于分段上传前确认）。</li><li><strong>101 Switching Protocols</strong>：服务器同意切换协议（如 WebSocket 升级）。</li></ul><blockquote><p>前端通常不直接处理 1xx。</p></blockquote><hr><h3 id="_2xx-成功" tabindex="-1"><strong>2xx：成功</strong> <a class="header-anchor" href="#_2xx-成功" aria-label="Permalink to “2xx：成功”">​</a></h3><ul><li><strong>200 OK</strong>：请求成功，响应体含结果（GET/PUT/POST 等）。</li><li><strong>201 Created</strong>：资源创建成功（常用于 POST 后返回新资源 URI）。</li><li><strong>204 No Content</strong>：请求成功，但无响应体（常用于 DELETE 或更新操作）。</li></ul><hr><h3 id="_3xx-重定向" tabindex="-1"><strong>3xx：重定向</strong> <a class="header-anchor" href="#_3xx-重定向" aria-label="Permalink to “3xx：重定向”">​</a></h3><ul><li><strong>301 Moved Permanently</strong>：永久重定向（SEO 友好，浏览器会缓存）。</li><li><strong>302 Found</strong>（临时重定向）：资源临时在另一 URI（传统表单提交后跳转常用）。</li><li><strong>304 Not Modified</strong>：协商缓存命中，客户端可使用本地缓存（配合 <code>If-Modified-Since</code> / <code>ETag</code>）。</li></ul><blockquote><p>⚠️ 307/308 是 302/301 的“严格版”（禁止改变请求方法）。</p></blockquote><hr><h3 id="_4xx-客户端错误" tabindex="-1"><strong>4xx：客户端错误</strong> <a class="header-anchor" href="#_4xx-客户端错误" aria-label="Permalink to “4xx：客户端错误”">​</a></h3><ul><li><strong>400 Bad Request</strong>：请求语法错误或参数无效。</li><li><strong>401 Unauthorized</strong>：未认证（需登录，通常触发弹出登录框）。</li><li><strong>403 Forbidden</strong>：已认证但无权限访问资源。</li><li><strong>404 Not Found</strong>：请求资源不存在。</li><li><strong>405 Method Not Allowed</strong>：请求方法（如 POST）不被该资源支持。</li><li><strong>429 Too Many Requests</strong>：请求频次超限（限流场景）。</li></ul><hr><h3 id="_5xx-服务器错误" tabindex="-1"><strong>5xx：服务器错误</strong> <a class="header-anchor" href="#_5xx-服务器错误" aria-label="Permalink to “5xx：服务器错误”">​</a></h3><ul><li><strong>500 Internal Server Error</strong>：服务器内部异常（通用错误）。</li><li><strong>502 Bad Gateway</strong>：网关/代理收到上游无效响应（如 Nginx → 应用宕机）。</li><li><strong>503 Service Unavailable</strong>：服务暂时不可用（如维护、过载）。</li><li><strong>504 Gateway Timeout</strong>：网关/代理等待上游超时。</li></ul><hr><h3 id="✅-前端重点关注" tabindex="-1">✅ 前端重点关注 <a class="header-anchor" href="#✅-前端重点关注" aria-label="Permalink to “✅ 前端重点关注”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>关键状态码</th></tr></thead><tbody><tr><td>接口调用成功</td><td>200, 201, 204</td></tr><tr><td>缓存命中</td><td>304</td></tr><tr><td>登录/权限</td><td>401（未登录）, 403（无权限）</td></tr><tr><td>资源不存在</td><td>404</td></tr><tr><td>请求格式错误</td><td>400</td></tr><tr><td>服务异常</td><td>500, 502, 503, 504</td></tr></tbody></table><blockquote><p>💡 <strong>最佳实践</strong>：前端应根据状态码做差异化处理（如 401 跳登录页，403 提示权限不足，5xx 显示友好错误页）。</p></blockquote><h2 id="post请求为什么会多发送一次option请求" tabindex="-1">post请求为什么会多发送一次option请求 <a class="header-anchor" href="#post请求为什么会多发送一次option请求" aria-label="Permalink to “post请求为什么会多发送一次option请求”">​</a></h2><p>POST 请求<strong>并非总是</strong>会多发一次 OPTIONS 请求，只有在触发 <strong>CORS 预检（Preflight）</strong> 时才会发生。这是浏览器的<strong>安全机制</strong>，与 HTTP 协议本身无关。</p><hr><h3 id="✅-什么情况下会触发-options-预检" tabindex="-1">✅ 什么情况下会触发 OPTIONS 预检？ <a class="header-anchor" href="#✅-什么情况下会触发-options-预检" aria-label="Permalink to “✅ 什么情况下会触发 OPTIONS 预检？”">​</a></h3><p>当请求满足以下<strong>任一条件</strong>（即“非简单请求”）时，浏览器会先发送 OPTIONS 请求：</p><ol><li><strong>使用了非简单方法</strong>：如 <code>PUT</code>、<code>DELETE</code>、<code>PATCH</code>（注意：<code>POST</code> <strong>可能</strong>触发，见下条）；</li><li><strong>设置了非简单请求头</strong>：如 <code>Content-Type: application/json</code>、<code>Authorization</code>、自定义 header（如 <code>X-Requested-With</code>）；</li><li><strong>POST 的 <code>Content-Type</code> 不是以下三种之一</strong>： <ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li></ol><blockquote><p>📌 关键点：<strong><code>POST + application/json</code> 是最常见触发预检的场景</strong>。</p></blockquote><hr><h3 id="🔍-预检请求的作用" tabindex="-1">🔍 预检请求的作用 <a class="header-anchor" href="#🔍-预检请求的作用" aria-label="Permalink to “🔍 预检请求的作用”">​</a></h3><ul><li><strong>询问服务器</strong>：“你是否允许我接下来要发的这个跨域请求？”</li><li>浏览器自动发送 OPTIONS 请求，携带： <ul><li><code>Origin</code>：当前源</li><li><code>Access-Control-Request-Method</code>：实际请求方法（如 POST）</li><li><code>Access-Control-Request-Headers</code>：实际请求带的自定义头</li></ul></li><li>服务器需在响应中明确允许：<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://your-site.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Methods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> POST, GET, OPTIONS</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Content-Type, Authorization</span></span></code></pre></div></li></ul><hr><h3 id="🛠-如何避免不必要的-options" tabindex="-1">🛠 如何避免不必要的 OPTIONS？ <a class="header-anchor" href="#🛠-如何避免不必要的-options" aria-label="Permalink to “🛠 如何避免不必要的 OPTIONS？”">​</a></h3><ul><li>使用简单请求（如 <code>POST</code> + <code>application/x-www-form-urlencoded</code>）；</li><li>后端正确配置 CORS 响应头，并考虑<strong>缓存预检结果</strong>：<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Max-Age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 86400  // 预检结果缓存 24 小时</span></span></code></pre></div></li></ul><hr><h3 id="❌-常见误解澄清" tabindex="-1">❌ 常见误解澄清 <a class="header-anchor" href="#❌-常见误解澄清" aria-label="Permalink to “❌ 常见误解澄清”">​</a></h3><ul><li><strong>不是 POST 本身导致</strong>，而是<strong>跨域 + 非简单请求特征</strong>触发；</li><li><strong>同源请求不会发 OPTIONS</strong>；</li><li><strong>OPTIONS 是浏览器自动发出的，开发者无法阻止（也不应阻止）</strong>。</li></ul><blockquote><p>💡 总结：<strong>OPTIONS 预检是 CORS 安全策略的一部分，用于保护用户免受恶意跨域请求，而非协议缺陷。</strong></p></blockquote><h2 id="http的请求和响应报文分别是什么样的" tabindex="-1">http的请求和响应报文分别是什么样的？ <a class="header-anchor" href="#http的请求和响应报文分别是什么样的" aria-label="Permalink to “http的请求和响应报文分别是什么样的？”">​</a></h2><p>HTTP 请求和响应报文均采用<strong>文本格式</strong>（HTTP/1.x），由三部分组成：<strong>起始行 + 头部（Headers） + 空行 + 正文（Body，可选）</strong>。以下是结构化概括：</p><hr><h3 id="一、http-请求报文-request" tabindex="-1">一、HTTP 请求报文（Request） <a class="header-anchor" href="#一、http-请求报文-request" aria-label="Permalink to “一、HTTP 请求报文（Request）”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>&lt;请求行&gt;</span></span>
<span class="line"><span>&lt;请求头&gt;</span></span>
<span class="line"><span>                  ← 空行（\\r\\n\\r\\n）</span></span>
<span class="line"><span>&lt;请求体（可选）&gt;</span></span></code></pre></div><h4 id="_1-请求行-request-line" tabindex="-1">1. <strong>请求行（Request Line）</strong> <a class="header-anchor" href="#_1-请求行-request-line" aria-label="Permalink to “1. 请求行（Request Line）”">​</a></h4><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /api/users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span></code></pre></div><ul><li>格式：<code>方法 路径 协议版本</code></li><li>方法：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等</li><li>路径：URL 的路径和查询参数（不含域名）</li><li>协议：如 <code>HTTP/1.1</code>、<code>HTTP/2</code></li></ul><h4 id="_2-请求头-request-headers" tabindex="-1">2. <strong>请求头（Request Headers）</strong> <a class="header-anchor" href="#_2-请求头-request-headers" aria-label="Permalink to “2. 请求头（Request Headers）”">​</a></h4><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Host</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> api.example.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">User-Agent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Mozilla/5.0 ...</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Accept</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/json</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/json</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Authorization</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Bearer xxx</span></span></code></pre></div><ul><li>键值对形式，提供元信息（如身份、内容类型、缓存策略等）</li><li><code>Host</code> 是 HTTP/1.1 <strong>必填</strong>字段</li></ul><h4 id="_3-请求体-request-body" tabindex="-1">3. <strong>请求体（Request Body）</strong> <a class="header-anchor" href="#_3-请求体-request-body" aria-label="Permalink to “3. 请求体（Request Body）”">​</a></h4><ul><li><code>GET</code> 请求通常无 body；</li><li><code>POST</code>/<code>PUT</code> 等携带数据（如 JSON、表单、文件）：<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><blockquote><p>✅ 示例（POST）：</p></blockquote><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">POST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /login </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Host</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> example.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/json</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 38</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;username&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;password&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123456&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="二、http-响应报文-response" tabindex="-1">二、HTTP 响应报文（Response） <a class="header-anchor" href="#二、http-响应报文-response" aria-label="Permalink to “二、HTTP 响应报文（Response）”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>&lt;状态行&gt;</span></span>
<span class="line"><span>&lt;响应头&gt;</span></span>
<span class="line"><span>                  ← 空行（\\r\\n\\r\\n）</span></span>
<span class="line"><span>&lt;响应体（可选）&gt;</span></span></code></pre></div><h4 id="_1-状态行-status-line" tabindex="-1">1. <strong>状态行（Status Line）</strong> <a class="header-anchor" href="#_1-状态行-status-line" aria-label="Permalink to “1. 状态行（Status Line）”">​</a></h4><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> OK</span></span></code></pre></div><ul><li>格式：<code>协议版本 状态码 状态文本</code></li><li>如 <code>HTTP/1.1 404 Not Found</code></li></ul><h4 id="_2-响应头-response-headers" tabindex="-1">2. <strong>响应头（Response Headers）</strong> <a class="header-anchor" href="#_2-响应头-response-headers" aria-label="Permalink to “2. 响应头（Response Headers）”">​</a></h4><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/json</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 123</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sessionid=abc123; Path=/</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> no-cache</span></span></code></pre></div><ul><li>描述响应元数据（内容类型、缓存控制、Cookie 设置等）</li></ul><h4 id="_3-响应体-response-body" tabindex="-1">3. <strong>响应体（Response Body）</strong> <a class="header-anchor" href="#_3-响应体-response-body" aria-label="Permalink to “3. 响应体（Response Body）”">​</a></h4><ul><li>返回实际数据（HTML、JSON、图片等）：<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;code&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span></span></code></pre></div></li></ul><blockquote><p>✅ 示例（成功响应）：</p></blockquote><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> OK</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/json</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 25</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;success&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="🔑-关键区别总结" tabindex="-1">🔑 关键区别总结 <a class="header-anchor" href="#🔑-关键区别总结" aria-label="Permalink to “🔑 关键区别总结”">​</a></h3><table tabindex="0"><thead><tr><th>部分</th><th>请求报文</th><th>响应报文</th></tr></thead><tbody><tr><td>起始行</td><td><code>方法 路径 版本</code></td><td><code>版本 状态码 状态文本</code></td></tr><tr><td>必填头部</td><td><code>Host</code></td><td>无强制，但通常有 <code>Content-Type</code></td></tr><tr><td>Body 触发</td><td>非 GET/HEAD 方法</td><td>非 204/304 等无体状态码</td></tr></tbody></table><blockquote><p>💡 注意：HTTP/2 虽将报文转为<strong>二进制分帧</strong>，但语义结构（Header + Body）保持不变，开发者仍按上述逻辑理解。</p></blockquote><h2 id="同样是重定向307-303-302的区别" tabindex="-1">同样是重定向307，303，302的区别？ <a class="header-anchor" href="#同样是重定向307-303-302的区别" aria-label="Permalink to “同样是重定向307，303，302的区别？”">​</a></h2><p>302、303、307 都是 HTTP 重定向状态码，但<strong>对后续请求方法（如 POST → GET）的处理不同</strong>，核心区别在于是否允许浏览器<strong>改变原始请求方法</strong>：</p><hr><h3 id="✅-精简对比表" tabindex="-1">✅ 精简对比表 <a class="header-anchor" href="#✅-精简对比表" aria-label="Permalink to “✅ 精简对比表”">​</a></h3><table tabindex="0"><thead><tr><th>状态码</th><th>名称</th><th>是否允许方法变更</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>302</strong></td><td>Found（临时重定向）</td><td><strong>允许</strong>（实践中常转为 GET）</td><td>传统临时跳转（历史行为不一致）</td></tr><tr><td><strong>303</strong></td><td>See Other</td><td><strong>强制改为 GET</strong></td><td>POST 后重定向到结果页（防重复提交）</td></tr><tr><td><strong>307</strong></td><td>Temporary Redirect</td><td><strong>禁止变更方法</strong></td><td>严格保持原方法（如 POST 仍为 POST）</td></tr></tbody></table><hr><h3 id="🔍-详细说明" tabindex="-1">🔍 详细说明 <a class="header-anchor" href="#🔍-详细说明" aria-label="Permalink to “🔍 详细说明”">​</a></h3><h4 id="_302-found" tabindex="-1"><strong>302 Found</strong> <a class="header-anchor" href="#_302-found" aria-label="Permalink to “302 Found”">​</a></h4><ul><li><strong>原始语义</strong>：临时重定向，<strong>应保持原方法</strong>。</li><li><strong>现实问题</strong>：早期浏览器（如 IE）将 302 的 POST 自动转为 GET，导致行为混乱。</li><li><strong>现状</strong>：多数浏览器对 302 的非 GET 请求<strong>默认转为 GET</strong>（违背 RFC，但已成事实标准）。</li></ul><h4 id="_303-see-other" tabindex="-1"><strong>303 See Other</strong> <a class="header-anchor" href="#_303-see-other" aria-label="Permalink to “303 See Other”">​</a></h4><ul><li><strong>明确要求</strong>：无论原方法是什么，<strong>客户端必须用 GET 发起新请求</strong>。</li><li><strong>典型场景</strong>：表单提交（POST）后，服务器返回 303 跳转到“操作成功”页面，避免刷新重复提交。</li></ul><h4 id="_307-temporary-redirect" tabindex="-1"><strong>307 Temporary Redirect</strong> <a class="header-anchor" href="#_307-temporary-redirect" aria-label="Permalink to “307 Temporary Redirect”">​</a></h4><ul><li><strong>严格语义</strong>：临时重定向，<strong>必须保持原始请求方法和 body</strong>。</li><li><strong>用途</strong>：需要确保重定向后仍用 POST/PUT 等方法（如 API 代理、负载均衡）。</li></ul><hr><h3 id="💡-前端-后端实践建议" tabindex="-1">💡 前端/后端实践建议 <a class="header-anchor" href="#💡-前端-后端实践建议" aria-label="Permalink to “💡 前端/后端实践建议”">​</a></h3><ul><li><strong>要跳转到新页面（如登录后首页）</strong> → 用 <strong>303</strong>（确保 GET）；</li><li><strong>需保持请求方法不变（如 API 重试）</strong> → 用 <strong>307</strong>；</li><li><strong>避免使用 302 处理非 GET 请求</strong>（行为不可控）；</li><li><strong>永久重定向统一用 308</strong>（301 的“方法保持版”）。</li></ul><blockquote><p>📌 <strong>记忆口诀</strong>：<br><strong>303 → See Other（看别的，用 GET）</strong><br><strong>307 → Temporary（临时，原样重发）</strong></p></blockquote><h2 id="http的keep-alive是干什么的" tabindex="-1">HTTP的keep-alive是干什么的？ <a class="header-anchor" href="#http的keep-alive是干什么的" aria-label="Permalink to “HTTP的keep-alive是干什么的？”">​</a></h2><p>HTTP 的 <strong>Keep-Alive</strong> 是一种<strong>持久连接（Persistent Connection）机制</strong>，核心作用是：<strong>在单个 TCP 连接上复用多个 HTTP 请求/响应，避免频繁建立和关闭连接的开销</strong>。</p><hr><h3 id="✅-核心价值" tabindex="-1">✅ 核心价值 <a class="header-anchor" href="#✅-核心价值" aria-label="Permalink to “✅ 核心价值”">​</a></h3><ul><li><strong>减少 TCP 握手（3 次）和挥手（4 次）次数</strong> → 降低延迟；</li><li><strong>避免慢启动（Slow Start）重复发生</strong> → 提升吞吐；</li><li><strong>节省服务器资源</strong>（连接数、内存）；</li><li><strong>对 HTTPS 尤其重要</strong>（省去 TLS 握手开销）。</li></ul><hr><h3 id="🔧-工作方式-http-1-1-默认启用" tabindex="-1">🔧 工作方式（HTTP/1.1 默认启用） <a class="header-anchor" href="#🔧-工作方式-http-1-1-默认启用" aria-label="Permalink to “🔧 工作方式（HTTP/1.1 默认启用）”">​</a></h3><ul><li><strong>HTTP/1.0</strong>：默认关闭，需显式加头部：<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keep-alive</span></span></code></pre></div></li><li><strong>HTTP/1.1</strong>：默认开启，除非显式关闭：<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> close</span></span></code></pre></div></li><li>连接保持一段时间（由服务器 <code>Keep-Alive: timeout=5, max=100</code> 控制），超时或达到最大请求数后关闭。</li></ul><hr><h3 id="🌰-示例" tabindex="-1">🌰 示例 <a class="header-anchor" href="#🌰-示例" aria-label="Permalink to “🌰 示例”">​</a></h3><p>无 Keep-Alive（每次请求新建连接）：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>[GET /a] → TCP 建连 → 传输 → 断连  </span></span>
<span class="line"><span>[GET /b] → TCP 建连 → 传输 → 断连  // 高延迟</span></span></code></pre></div><p>有 Keep-Alive（复用连接）：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>[GET /a] → TCP 建连 → 传输  </span></span>
<span class="line"><span>[GET /b] → 复用同一连接 → 传输  </span></span>
<span class="line"><span>...  </span></span>
<span class="line"><span>空闲超时 → 自动断连</span></span></code></pre></div><hr><h3 id="⚠️-注意事项" tabindex="-1">⚠️ 注意事项 <a class="header-anchor" href="#⚠️-注意事项" aria-label="Permalink to “⚠️ 注意事项”">​</a></h3><ul><li><strong>不是“长连接”</strong>：仍是短生命周期的复用连接（通常几秒到几十秒）；</li><li><strong>与 HTTP/2 关系</strong>：HTTP/2 通过多路复用彻底解决队头阻塞，但仍依赖持久连接，Keep-Alive 在底层依然有效；</li><li><strong>资源泄漏风险</strong>：客户端或服务器若未正确关闭空闲连接，可能耗尽文件描述符。</li></ul><hr><h3 id="💡-总结" tabindex="-1">💡 总结 <a class="header-anchor" href="#💡-总结" aria-label="Permalink to “💡 总结”">​</a></h3><blockquote><p><strong>Keep-Alive = 单 TCP 连接跑多个 HTTP 事务，显著提升性能，是现代 Web 高效加载的基础。</strong><br> （HTTP/1.1 默认开启，无需额外配置；调优重点在服务端超时和最大请求数设置。）</p></blockquote><h2 id="从输入url到看到页面发生的全过程" tabindex="-1">从输入URL到看到页面发生的全过程 <a class="header-anchor" href="#从输入url到看到页面发生的全过程" aria-label="Permalink to “从输入URL到看到页面发生的全过程”">​</a></h2><p>从在浏览器地址栏输入 URL 到最终看到页面，全过程可高度概括为以下 <strong>7 个关键阶段</strong>（前端工程师视角）：</p><hr><h3 id="_1-url-解析与安全检查" tabindex="-1">1. <strong>URL 解析与安全检查</strong> <a class="header-anchor" href="#_1-url-解析与安全检查" aria-label="Permalink to “1. URL 解析与安全检查”">​</a></h3><ul><li>浏览器解析 URL（协议、域名、路径、参数）；</li><li>检查 HSTS 列表（强制 HTTPS）、恶意站点数据库（Safe Browsing）。</li></ul><hr><h3 id="_2-dns-查询-域名-→-ip" tabindex="-1">2. <strong>DNS 查询（域名 → IP）</strong> <a class="header-anchor" href="#_2-dns-查询-域名-→-ip" aria-label="Permalink to “2. DNS 查询（域名 → IP）”">​</a></h3><ul><li>查找缓存顺序：<br><strong>浏览器缓存 → 系统 hosts → 本地 DNS 缓存 → 递归 DNS 服务器（如 8.8.8.8）</strong></li><li>返回目标服务器 IP 地址（可能 IPv4/IPv6）。</li></ul><hr><h3 id="_3-建立-tcp-连接-三次握手" tabindex="-1">3. <strong>建立 TCP 连接（三次握手）</strong> <a class="header-anchor" href="#_3-建立-tcp-连接-三次握手" aria-label="Permalink to “3. 建立 TCP 连接（三次握手）”">​</a></h3><ul><li>客户端 → 服务器：<code>SYN</code></li><li>服务器 → 客户端：<code>SYN-ACK</code></li><li>客户端 → 服务器：<code>ACK</code></li><li>若为 HTTPS，<strong>紧接着进行 TLS 握手</strong>（密钥交换、证书验证等，通常 1-RTT 或 0-RTT）。</li></ul><hr><h3 id="_4-发送-http-请求" tabindex="-1">4. <strong>发送 HTTP 请求</strong> <a class="header-anchor" href="#_4-发送-http-请求" aria-label="Permalink to “4. 发送 HTTP 请求”">​</a></h3><ul><li>构造请求报文（含 Method、Path、Headers 如 <code>Host</code>, <code>User-Agent</code>, <code>Cookie</code> 等）；</li><li>通过已建立的 TCP/TLS 连接发送；</li><li>若启用了 HTTP/2，此阶段可能复用连接并多路复用流。</li></ul><hr><h3 id="_5-服务器处理-返回响应" tabindex="-1">5. <strong>服务器处理 &amp; 返回响应</strong> <a class="header-anchor" href="#_5-服务器处理-返回响应" aria-label="Permalink to “5. 服务器处理 &amp; 返回响应”">​</a></h3><ul><li>Web 服务器（如 Nginx）接收请求，可能： <ul><li>静态资源：直接返回文件（如 HTML/CSS/JS）；</li><li>动态请求：转发给应用服务器（如 Node.js、Java）处理业务逻辑；</li></ul></li><li>返回 HTTP 响应（状态码 + Headers + Body，如 HTML 文档）。</li></ul><hr><h3 id="_6-浏览器解析与渲染-关键" tabindex="-1">6. <strong>浏览器解析与渲染（关键！）</strong> <a class="header-anchor" href="#_6-浏览器解析与渲染-关键" aria-label="Permalink to “6. 浏览器解析与渲染（关键！）”">​</a></h3><h4 id="a-构建-dom-树" tabindex="-1">a) <strong>构建 DOM 树</strong> <a class="header-anchor" href="#a-构建-dom-树" aria-label="Permalink to “a) 构建 DOM 树”">​</a></h4><ul><li>解析 HTML → 生成 DOM 节点树。</li></ul><h4 id="b-构建-cssom-树" tabindex="-1">b) <strong>构建 CSSOM 树</strong> <a class="header-anchor" href="#b-构建-cssom-树" aria-label="Permalink to “b) 构建 CSSOM 树”">​</a></h4><ul><li>加载 <code>&lt;link&gt;</code> CSS 和 <code>&lt;style&gt;</code> → 解析样式规则 → 生成 CSSOM。</li></ul><h4 id="c-构建-render-tree" tabindex="-1">c) <strong>构建 Render Tree</strong> <a class="header-anchor" href="#c-构建-render-tree" aria-label="Permalink to “c) 构建 Render Tree”">​</a></h4><ul><li>合并 DOM + CSSOM → 只包含可见元素的渲染树。</li></ul><h4 id="d-layout-回流" tabindex="-1">d) <strong>Layout（回流）</strong> <a class="header-anchor" href="#d-layout-回流" aria-label="Permalink to “d) Layout（回流）”">​</a></h4><ul><li>计算每个节点几何位置（宽高、坐标）。</li></ul><h4 id="e-paint-重绘" tabindex="-1">e) <strong>Paint（重绘）</strong> <a class="header-anchor" href="#e-paint-重绘" aria-label="Permalink to “e) Paint（重绘）”">​</a></h4><ul><li>将像素绘制到屏幕（分层、合成）。</li></ul><blockquote><p>⚠️ 遇到 <code>&lt;script&gt;</code> 会<strong>阻塞 HTML 解析</strong>（除非 <code>async</code>/<code>defer</code>）；<br> 遇到外部 CSS 会<strong>阻塞渲染</strong>（但不阻塞 HTML 解析）。</p></blockquote><hr><h3 id="_7-加载子资源-执行-js" tabindex="-1">7. <strong>加载子资源 &amp; 执行 JS</strong> <a class="header-anchor" href="#_7-加载子资源-执行-js" aria-label="Permalink to “7. 加载子资源 &amp; 执行 JS”">​</a></h3><ul><li>解析 HTML 时发现 <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>fetch()</code> 等 → 发起新请求（复用 Keep-Alive 连接）；</li><li>执行 JavaScript（可能修改 DOM/CSSOM → 触发重新 Layout/Paint）；</li><li>最终完成 <strong>FP（First Paint）→ FCP（First Contentful Paint）→ LCP（Largest Contentful Paint）</strong>。</li></ul><hr><h3 id="🔄-补充-连接关闭" tabindex="-1">🔄 补充：连接关闭 <a class="header-anchor" href="#🔄-补充-连接关闭" aria-label="Permalink to “🔄 补充：连接关闭”">​</a></h3><ul><li>页面加载完成后，TCP 连接可能保持（Keep-Alive）供后续请求复用；</li><li>空闲超时后由服务器或客户端关闭（四次挥手）。</li></ul><hr><h3 id="💡-性能优化关键点" tabindex="-1">💡 性能优化关键点 <a class="header-anchor" href="#💡-性能优化关键点" aria-label="Permalink to “💡 性能优化关键点”">​</a></h3><table tabindex="0"><thead><tr><th>阶段</th><th>优化手段</th></tr></thead><tbody><tr><td>DNS</td><td>DNS 预解析 (<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>)</td></tr><tr><td>TCP/TLS</td><td>HTTP/2, TLS 1.3, 0-RTT</td></tr><tr><td>请求</td><td>减少请求数、CDN、缓存策略</td></tr><tr><td>渲染</td><td>关键资源内联、懒加载、避免长任务</td></tr></tbody></table><blockquote><p>✅ <strong>一句话总结</strong>：<br><strong>DNS → TCP/TLS → HTTP → 服务端响应 → 浏览器解析 → 构建 DOM/CSSOM → 渲染 → 加载子资源 → 交互就绪。</strong></p></blockquote><h2 id="浏览器缓存的优先级" tabindex="-1">浏览器缓存的优先级？ <a class="header-anchor" href="#浏览器缓存的优先级" aria-label="Permalink to “浏览器缓存的优先级？”">​</a></h2><p>浏览器缓存的优先级遵循一套<strong>明确的决策流程</strong>，核心原则是：<strong>强缓存 &gt; 协商缓存 &gt; 网络请求</strong>。以下是前端工程师必须掌握的精确优先级顺序：</p><hr><h3 id="✅-缓存决策流程-按优先级从高到低" tabindex="-1">✅ 缓存决策流程（按优先级从高到低） <a class="header-anchor" href="#✅-缓存决策流程-按优先级从高到低" aria-label="Permalink to “✅ 缓存决策流程（按优先级从高到低）”">​</a></h3><h4 id="_1-service-worker-缓存-最高优先级" tabindex="-1">1. <strong>Service Worker 缓存（最高优先级）</strong> <a class="header-anchor" href="#_1-service-worker-缓存-最高优先级" aria-label="Permalink to “1. Service Worker 缓存（最高优先级）”">​</a></h4><ul><li>如果注册了 Service Worker 且其 <code>fetch</code> 事件拦截了请求，<strong>完全由 JS 控制缓存逻辑</strong>；</li><li>可绕过所有 HTTP 缓存机制（常用于 PWA）。</li></ul><h4 id="_2-memory-cache-内存缓存" tabindex="-1">2. <strong>Memory Cache（内存缓存）</strong> <a class="header-anchor" href="#_2-memory-cache-内存缓存" aria-label="Permalink to “2. Memory Cache（内存缓存）”">​</a></h4><ul><li>存储在内存中的临时缓存（如页面内重复图片、脚本）；</li><li><strong>生命周期最短</strong>（刷新即失效），但速度最快；</li><li>无标准控制方式，由浏览器自动管理。</li></ul><h4 id="_3-disk-cache-磁盘缓存-http-强缓存" tabindex="-1">3. <strong>Disk Cache（磁盘缓存） + HTTP 强缓存</strong> <a class="header-anchor" href="#_3-disk-cache-磁盘缓存-http-强缓存" aria-label="Permalink to “3. Disk Cache（磁盘缓存） + HTTP 强缓存”">​</a></h4><ul><li>通过响应头控制，<strong>无需发起网络请求</strong>： <ul><li><code>Cache-Control: max-age=3600</code>（HTTP/1.1，优先级更高）</li><li><code>Expires: &lt;GMT 时间&gt;</code>（HTTP/1.0，若无 <code>Cache-Control</code> 则用它）</li></ul></li><li><strong>命中条件</strong>：未过期 → 直接返回缓存。</li></ul><blockquote><p>📌 <code>Cache-Control</code> 指令优先级（常见）：<br><code>no-store</code> &gt; <code>no-cache</code> &gt; <code>max-age</code> &gt; <code>Expires</code></p></blockquote><h4 id="_4-协商缓存-需发请求-但可能-304" tabindex="-1">4. <strong>协商缓存（需发请求，但可能 304）</strong> <a class="header-anchor" href="#_4-协商缓存-需发请求-但可能-304" aria-label="Permalink to “4. 协商缓存（需发请求，但可能 304）”">​</a></h4><ul><li>强缓存失效后触发，通过以下头部验证资源是否更新： <ul><li><strong>ETag / If-None-Match</strong>（优先级更高，基于内容指纹）</li><li><strong>Last-Modified / If-Modified-Since</strong>（基于时间戳）</li></ul></li><li>服务器比对后： <ul><li>未修改 → 返回 <strong>304 Not Modified</strong>（复用本地缓存）</li><li>已修改 → 返回 <strong>200 + 新资源</strong></li></ul></li></ul><h4 id="_5-网络请求-兜底" tabindex="-1">5. <strong>网络请求（兜底）</strong> <a class="header-anchor" href="#_5-网络请求-兜底" aria-label="Permalink to “5. 网络请求（兜底）”">​</a></h4><ul><li>所有缓存均未命中 → 发起完整 HTTP 请求获取新资源。</li></ul><hr><h3 id="🔁-补充说明" tabindex="-1">🔁 补充说明 <a class="header-anchor" href="#🔁-补充说明" aria-label="Permalink to “🔁 补充说明”">​</a></h3><table tabindex="0"><thead><tr><th>缓存类型</th><th>是否发请求</th><th>控制方式</th><th>典型场景</th></tr></thead><tbody><tr><td>Service Worker</td><td>否（可选）</td><td>JavaScript</td><td>PWA、离线应用</td></tr><tr><td>Memory Cache</td><td>否</td><td>浏览器自动</td><td>同页面重复资源</td></tr><tr><td>强缓存</td><td>否</td><td><code>Cache-Control</code> / <code>Expires</code></td><td>静态资源（JS/CSS/图片）</td></tr><tr><td>协商缓存</td><td>是（轻量）</td><td><code>ETag</code> / <code>Last-Modified</code></td><td>动态内容、HTML</td></tr></tbody></table><hr><h3 id="💡-最佳实践" tabindex="-1">💡 最佳实践 <a class="header-anchor" href="#💡-最佳实践" aria-label="Permalink to “💡 最佳实践”">​</a></h3><ul><li><strong>静态资源</strong>：长 <code>max-age</code> + 文件名哈希（如 <code>app.a1b2c3.js</code>）→ 永久强缓存；</li><li><strong>HTML 页面</strong>：<code>Cache-Control: no-cache</code> → 每次走协商缓存，确保最新；</li><li><strong>避免同时设置 <code>ETag</code> 和 <code>Last-Modified</code> 冗余</strong>，优先用 <code>ETag</code>（更精准）；</li><li><strong>调试时</strong>：强制刷新（Ctrl+F5）会跳过所有缓存，普通刷新（F5）仍会使用强缓存。</li></ul><blockquote><p>✅ <strong>一句话总结优先级</strong>：<br><strong>Service Worker → Memory Cache → Disk Cache（强缓存）→ 协商缓存 → 网络请求</strong>。</p></blockquote><h2 id="为什么会存在跨域及常见跨域的解决办法" tabindex="-1">为什么会存在跨域及常见跨域的解决办法？ <a class="header-anchor" href="#为什么会存在跨域及常见跨域的解决办法" aria-label="Permalink to “为什么会存在跨域及常见跨域的解决办法？”">​</a></h2><p>跨域问题源于浏览器的 <strong>同源策略（Same-Origin Policy）</strong>，是安全机制而非缺陷。以下是高度概括的解释与解决方案：</p><hr><h3 id="🔒-为什么存在跨域" tabindex="-1">🔒 为什么存在跨域？ <a class="header-anchor" href="#🔒-为什么存在跨域" aria-label="Permalink to “🔒 为什么存在跨域？”">​</a></h3><ul><li><strong>同源定义</strong>：协议 + 域名 + 端口 <strong>完全相同</strong>。</li><li><strong>目的</strong>：防止恶意网站窃取用户数据（如读取银行页面的 Cookie、DOM）。</li><li><strong>限制行为</strong>（仅限前端 JavaScript）： <ul><li>无法读取非同源响应的 <strong>Response Body / Headers</strong>；</li><li>无法发送某些自定义请求头或非简单方法（触发预检）；</li><li>但 <strong>请求仍会发出</strong>（服务器能收到），只是浏览器拦截响应。</li></ul></li></ul><blockquote><p>⚠️ 注意：跨域是<strong>浏览器限制</strong>，服务端之间调用（如 Node.js、curl）无此问题。</p></blockquote><hr><h3 id="✅-常见跨域解决方案-按适用场景" tabindex="-1">✅ 常见跨域解决方案（按适用场景） <a class="header-anchor" href="#✅-常见跨域解决方案-按适用场景" aria-label="Permalink to “✅ 常见跨域解决方案（按适用场景）”">​</a></h3><h4 id="_1-cors-跨域资源共享-——-最主流方案" tabindex="-1">1. <strong>CORS（跨域资源共享）</strong> —— <strong>最主流方案</strong> <a class="header-anchor" href="#_1-cors-跨域资源共享-——-最主流方案" aria-label="Permalink to “1. CORS（跨域资源共享） —— 最主流方案”">​</a></h4><ul><li><strong>原理</strong>：服务器在响应中添加允许跨域的头部：<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://your-site.com  // 或 *</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Credentials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> true               // 允许带 Cookie</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Content-Type, Authorization</span></span></code></pre></div></li><li><strong>优点</strong>：标准、灵活、支持所有 HTTP 方法；</li><li><strong>注意</strong>： <ul><li><code>Allow-Origin</code> 不能为 <code>*</code> 且同时设置 <code>Credentials: true</code>；</li><li>预检请求（OPTIONS）需正确处理。</li></ul></li></ul><h4 id="_2-代理-proxy-——-开发-部署常用" tabindex="-1">2. <strong>代理（Proxy）</strong> —— <strong>开发/部署常用</strong> <a class="header-anchor" href="#_2-代理-proxy-——-开发-部署常用" aria-label="Permalink to “2. 代理（Proxy） —— 开发/部署常用”">​</a></h4><ul><li><strong>开发时</strong>：Webpack/Vite 的 <code>proxy</code> 配置（如 <code>/api → http://localhost:8080</code>）；</li><li><strong>生产时</strong>：Nginx 反向代理（将 <code>/api</code> 路径转发到后端，同源访问）；</li><li><strong>本质</strong>：绕过浏览器限制，由同源服务器代发请求。</li></ul><h4 id="_3-jsonp-——-仅限-get-已淘汰" tabindex="-1">3. <strong>JSONP</strong> —— <strong>仅限 GET，已淘汰</strong> <a class="header-anchor" href="#_3-jsonp-——-仅限-get-已淘汰" aria-label="Permalink to “3. JSONP —— 仅限 GET，已淘汰”">​</a></h4><ul><li><strong>原理</strong>：利用 <code>&lt;script&gt;</code> 标签不受同源限制，回调函数接收数据；</li><li><strong>缺点</strong>：仅支持 GET、无错误处理、有 XSS 风险；</li><li><strong>现状</strong>：<strong>不推荐使用</strong>（CORS 已全面替代）。</li></ul><h4 id="_4-postmessage-——-跨窗口-iframe-通信" tabindex="-1">4. <strong>PostMessage</strong> —— <strong>跨窗口/iframe 通信</strong> <a class="header-anchor" href="#_4-postmessage-——-跨窗口-iframe-通信" aria-label="Permalink to “4. PostMessage —— 跨窗口/iframe 通信”">​</a></h4><ul><li>适用于父子页面、弹窗等场景：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父页面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">iframe.contentWindow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://target.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子页面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 验证 origin 后处理 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div></li></ul><h4 id="_5-websocket-——-天然支持跨域" tabindex="-1">5. <strong>WebSocket</strong> —— <strong>天然支持跨域</strong> <a class="header-anchor" href="#_5-websocket-——-天然支持跨域" aria-label="Permalink to “5. WebSocket —— 天然支持跨域”">​</a></h4><ul><li>WebSocket 协议本身无同源限制，但服务器可主动校验 <code>Origin</code> 头做防护。</li></ul><h4 id="_6-service-worker-mock-——-仅限开发调试" tabindex="-1">6. <strong>Service Worker / Mock</strong> —— <strong>仅限开发调试</strong> <a class="header-anchor" href="#_6-service-worker-mock-——-仅限开发调试" aria-label="Permalink to “6. Service Worker / Mock —— 仅限开发调试”">​</a></h4><ul><li>拦截请求并返回模拟数据（非真实跨域解决）。</li></ul><hr><h3 id="🚫-无效-错误方案" tabindex="-1">🚫 无效/错误方案 <a class="header-anchor" href="#🚫-无效-错误方案" aria-label="Permalink to “🚫 无效/错误方案”">​</a></h3><ul><li><strong>前端改 header</strong>（如 <code>Origin</code>）→ 浏览器禁止；</li><li><strong>隐藏 iframe / form 提交</strong> → 无法读取响应；</li><li><strong>修改浏览器安全设置</strong> → 不可行（用户环境不可控）。</li></ul><hr><h3 id="💡-总结-1" tabindex="-1">💡 总结 <a class="header-anchor" href="#💡-总结-1" aria-label="Permalink to “💡 总结”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>前后端分离开发</td><td>DevServer 代理</td></tr><tr><td>生产环境 API</td><td>CORS</td></tr><tr><td>跨域 iframe 通信</td><td>postMessage</td></tr><tr><td>实时通信</td><td>WebSocket</td></tr></tbody></table><blockquote><p>✅ <strong>核心原则</strong>：跨域必须由<strong>服务端配合</strong>（CORS 或代理），纯前端无法真正“解决”跨域。</p></blockquote><h2 id="浏览器的渲染机制是怎样的" tabindex="-1">浏览器的渲染机制是怎样的？ <a class="header-anchor" href="#浏览器的渲染机制是怎样的" aria-label="Permalink to “浏览器的渲染机制是怎样的？”">​</a></h2><p>浏览器的渲染机制是将 HTML、CSS、JavaScript 转换为可视页面的过程，核心流程可高度概括为以下 <strong>5 个关键阶段</strong>（以 Chromium/Blink 引擎为例）：</p><hr><h3 id="_1-解析-parsing-→-构建-dom-cssom" tabindex="-1">1. <strong>解析（Parsing） → 构建 DOM &amp; CSSOM</strong> <a class="header-anchor" href="#_1-解析-parsing-→-构建-dom-cssom" aria-label="Permalink to “1. 解析（Parsing） → 构建 DOM &amp; CSSOM”">​</a></h3><ul><li><strong>HTML 解析</strong>：<br> 流式解析 → 生成 <strong>DOM 树</strong>（Document Object Model），遇到 <code>&lt;script&gt;</code> 会阻塞（除非 <code>async</code>/<code>defer</code>）。</li><li><strong>CSS 解析</strong>：<br> 加载并解析所有样式（内联、<code>&lt;link&gt;</code>、<code>@import</code>）→ 生成 <strong>CSSOM 树</strong>（CSS Object Model），<strong>阻塞渲染但不阻塞 HTML 解析</strong>。</li></ul><blockquote><p>⚠️ 关键点：DOM 和 CSSOM 是独立构建的，任一缺失都无法渲染。</p></blockquote><hr><h3 id="_2-合成-combining-→-构建-render-tree" tabindex="-1">2. <strong>合成（Combining） → 构建 Render Tree</strong> <a class="header-anchor" href="#_2-合成-combining-→-构建-render-tree" aria-label="Permalink to “2. 合成（Combining） → 构建 Render Tree”">​</a></h3><ul><li>合并 DOM + CSSOM → 生成 <strong>Render Tree</strong>（渲染树）；</li><li><strong>仅包含可见节点</strong>：<code>display: none</code>、<code>&lt;head&gt;</code>、注释等被剔除；</li><li>每个节点包含<strong>计算后的样式</strong>（Computed Style）。</li></ul><hr><h3 id="_3-布局-layout-reflow" tabindex="-1">3. <strong>布局（Layout / Reflow）</strong> <a class="header-anchor" href="#_3-布局-layout-reflow" aria-label="Permalink to “3. 布局（Layout / Reflow）”">​</a></h3><ul><li>计算每个 Render Tree 节点的<strong>几何信息</strong>（位置、宽高）；</li><li>从根节点开始递归布局（“回流”）；</li><li><strong>触发条件</strong>：DOM 结构变化、窗口 resize、读取 offset/scroll/client 等布局属性。</li></ul><blockquote><p>💡 布局是<strong>全局或局部</strong>的，现代浏览器会优化为增量布局。</p></blockquote><hr><h3 id="_4-绘制-paint-rasterization" tabindex="-1">4. <strong>绘制（Paint / Rasterization）</strong> <a class="header-anchor" href="#_4-绘制-paint-rasterization" aria-label="Permalink to “4. 绘制（Paint / Rasterization）”">​</a></h3><ul><li>将 Render Tree 转换为<strong>屏幕像素</strong>： <ul><li>分层（Layer）：如 <code>transform</code>、<code>opacity</code> 元素会提升为独立合成层；</li><li>光栅化（Raster）：CPU/GPU 将图层绘制成位图；</li></ul></li><li><strong>重绘（Repaint）</strong>：样式变化但不影响布局（如 color、background）。</li></ul><hr><h3 id="_5-合成-compositing" tabindex="-1">5. <strong>合成（Compositing）</strong> <a class="header-anchor" href="#_5-合成-compositing" aria-label="Permalink to “5. 合成（Compositing）”">​</a></h3><ul><li>合成线程（Compositor Thread）将各图层按 <strong>z-index、transform</strong> 等顺序合并；</li><li>直接提交给 GPU 显示，<strong>无需主线程参与</strong>；</li><li>利用 <strong>硬件加速</strong> 实现高性能动画（如 <code>transform: translateX(100px)</code>）。</li></ul><hr><h3 id="🔄-关键优化概念" tabindex="-1">🔄 关键优化概念 <a class="header-anchor" href="#🔄-关键优化概念" aria-label="Permalink to “🔄 关键优化概念”">​</a></h3><table tabindex="0"><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td><strong>重排（Reflow）</strong></td><td>布局变化 → 触发 Layout → 开销大（避免频繁读写布局属性）</td></tr><tr><td><strong>重绘（Repaint）</strong></td><td>样式变化但布局不变 → 触发 Paint → 开销中等</td></tr><tr><td><strong>合成（Composite）</strong></td><td>仅图层变换 → 跳过 Layout/Paint → <strong>开销最小（推荐动画方式）</strong></td></tr></tbody></table><hr><h3 id="💡-渲染性能最佳实践" tabindex="-1">💡 渲染性能最佳实践 <a class="header-anchor" href="#💡-渲染性能最佳实践" aria-label="Permalink to “💡 渲染性能最佳实践”">​</a></h3><ul><li><strong>避免强制同步布局</strong>：不要在循环中读取 <code>offsetWidth</code> 后立即修改样式；</li><li><strong>提升动画元素为合成层</strong>：使用 <code>transform</code> / <code>opacity</code> 触发 GPU 加速；</li><li><strong>减少样式层级嵌套</strong>：简化 CSS 选择器，加速 CSSOM 构建；</li><li><strong>关键资源预加载</strong>：<code>&lt;link rel=&quot;preload&quot;&gt;</code> 提前加载首屏 CSS/JS。</li></ul><hr><h3 id="✅-一句话总结" tabindex="-1">✅ 一句话总结 <a class="header-anchor" href="#✅-一句话总结" aria-label="Permalink to “✅ 一句话总结”">​</a></h3><blockquote><p><strong>DOM + CSSOM → Render Tree → Layout → Paint → Composite，其中 Layout 和 Paint 在主线程，Composite 可由 GPU 异步完成。</strong><br><strong>高性能渲染的核心：减少重排重绘，最大化利用合成。</strong></p></blockquote><h2 id="什么是重绘和回流及怎么减少重绘和回流" tabindex="-1">什么是重绘和回流及怎么减少重绘和回流？ <a class="header-anchor" href="#什么是重绘和回流及怎么减少重绘和回流" aria-label="Permalink to “什么是重绘和回流及怎么减少重绘和回流？”">​</a></h2><p><strong>重绘（Repaint）</strong> 和 <strong>回流（Reflow，也称重排）</strong> 是浏览器渲染过程中的两个关键性能开销操作：</p><hr><h3 id="🔍-定义与区别" tabindex="-1">🔍 定义与区别 <a class="header-anchor" href="#🔍-定义与区别" aria-label="Permalink to “🔍 定义与区别”">​</a></h3><table tabindex="0"><thead><tr><th>操作</th><th>触发条件</th><th>是否影响布局</th><th>性能开销</th></tr></thead><tbody><tr><td><strong>回流（Reflow）</strong></td><td>DOM 结构变化、几何尺寸/位置改变（如 width、padding、font-size）、窗口 resize、读取 offset/scroll/client 等布局属性</td><td>✅ 是</td><td>⚠️ <strong>高</strong>（需重新计算整个或部分 Render Tree 布局）</td></tr><tr><td><strong>重绘（Repaint）</strong></td><td>样式变化但<strong>不改变布局</strong>（如 color、background、visibility）</td><td>❌ 否</td><td>🟡 中等（只需重新绘制像素）</td></tr></tbody></table><blockquote><p>💡 <strong>回流必定触发重绘，但重绘不一定触发回流。</strong></p></blockquote><hr><h3 id="🛠-如何减少回流和重绘" tabindex="-1">🛠 如何减少回流和重绘？ <a class="header-anchor" href="#🛠-如何减少回流和重绘" aria-label="Permalink to “🛠 如何减少回流和重绘？”">​</a></h3><h4 id="✅-1-批量修改-dom" tabindex="-1">✅ 1. <strong>批量修改 DOM</strong> <a class="header-anchor" href="#✅-1-批量修改-dom" aria-label="Permalink to “✅ 1. 批量修改 DOM”">​</a></h4><ul><li>避免逐条修改样式，使用 <strong>CSS class 切换</strong> 或 <strong>documentFragment</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 差：多次触发回流</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;red&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 好：一次回流</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;new-style&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 CSS 中定义</span></span></code></pre></div></li></ul><h4 id="✅-2-离线操作-dom" tabindex="-1">✅ 2. <strong>离线操作 DOM</strong> <a class="header-anchor" href="#✅-2-离线操作-dom" aria-label="Permalink to “✅ 2. 离线操作 DOM”">​</a></h4><ul><li>将元素从文档流中移除 → 修改 → 重新插入：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.display </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;none&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 脱离文档流</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 批量修改...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.display </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;block&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 一次性回流</span></span></code></pre></div></li><li>或使用 <code>DocumentFragment</code> 构建子树后再插入。</li></ul><h4 id="✅-3-避免强制同步布局-forced-synchronous-layout" tabindex="-1">✅ 3. <strong>避免强制同步布局（Forced Synchronous Layout）</strong> <a class="header-anchor" href="#✅-3-避免强制同步布局-forced-synchronous-layout" aria-label="Permalink to “✅ 3. 避免强制同步布局（Forced Synchronous Layout）”">​</a></h4><ul><li>不要在循环中 <strong>先读取布局属性，再修改样式</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 危险：每次 offsetWidth 都触发回流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  items[i].style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container.offsetHeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 安全：先读，后写</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container.offsetHeight;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  items[i].style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h4 id="✅-4-使用-transform-opacity-实现动画" tabindex="-1">✅ 4. <strong>使用 transform / opacity 实现动画</strong> <a class="header-anchor" href="#✅-4-使用-transform-opacity-实现动画" aria-label="Permalink to “✅ 4. 使用 transform / opacity 实现动画”">​</a></h4><ul><li>这些属性由 <strong>合成线程（Compositor Thread）</strong> 处理，<strong>不触发回流/重绘</strong>：<div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">translateX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 推荐 */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 避免：left: 100px; */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h4 id="✅-5-提升元素为独立合成层-谨慎使用" tabindex="-1">✅ 5. <strong>提升元素为独立合成层（谨慎使用）</strong> <a class="header-anchor" href="#✅-5-提升元素为独立合成层-谨慎使用" aria-label="Permalink to “✅ 5. 提升元素为独立合成层（谨慎使用）”">​</a></h4><ul><li>通过 <code>will-change: transform</code> 或 <code>transform: translateZ(0)</code> 提升图层；</li><li>⚠️ 过度使用会增加内存和合成开销。</li></ul><h4 id="✅-6-避免频繁操作表格" tabindex="-1">✅ 6. <strong>避免频繁操作表格</strong> <a class="header-anchor" href="#✅-6-避免频繁操作表格" aria-label="Permalink to “✅ 6. 避免频繁操作表格”">​</a></h4><ul><li>表格的回流成本极高（需多次计算），尽量用 <code>table-layout: fixed</code> 固定列宽。</li></ul><hr><h3 id="💡-总结口诀" tabindex="-1">💡 总结口诀 <a class="header-anchor" href="#💡-总结口诀" aria-label="Permalink to “💡 总结口诀”">​</a></h3><blockquote><p><strong>“读写分离、批量操作、离线修改、合成优先”</strong><br><strong>能用 <code>transform/opacity</code> 就不用改布局；能改 class 就不逐条设 style。</strong></p></blockquote><p>通过以上策略，可显著减少主线程负担，提升页面流畅度（尤其在低端设备）。</p><h2 id="浏览器的事件机制" tabindex="-1">浏览器的事件机制 <a class="header-anchor" href="#浏览器的事件机制" aria-label="Permalink to “浏览器的事件机制”">​</a></h2><p>浏览器的事件机制是前端交互的核心，其核心模型可高度概括为以下三点：</p><hr><h3 id="一、事件流-event-flow-捕获-→-目标-→-冒泡" tabindex="-1">一、<strong>事件流（Event Flow）：捕获 → 目标 → 冒泡</strong> <a class="header-anchor" href="#一、事件流-event-flow-捕获-→-目标-→-冒泡" aria-label="Permalink to “一、事件流（Event Flow）：捕获 → 目标 → 冒泡”">​</a></h3><p>根据 DOM 标准，事件传播分三个阶段：</p><ol><li><strong>捕获阶段（Capture）</strong>：从 <code>window</code> → <code>document</code> → ... → 目标父元素；</li><li><strong>目标阶段（Target）</strong>：事件到达目标元素；</li><li><strong>冒泡阶段（Bubble）</strong>：从目标元素 → 父元素 → ... → <code>document</code> → <code>window</code>。</li></ol><blockquote><p>⚠️ 大多数事件（如 <code>click</code>）默认只走<strong>冒泡阶段</strong>；只有显式设置 <code>{ capture: true }</code> 才监听捕获。</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 冒泡（默认）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handler);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 捕获</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handler, { capture: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><hr><h3 id="二、事件委托-event-delegation" tabindex="-1">二、<strong>事件委托（Event Delegation）</strong> <a class="header-anchor" href="#二、事件委托-event-delegation" aria-label="Permalink to “二、事件委托（Event Delegation）”">​</a></h3><ul><li><strong>原理</strong>：利用事件冒泡，在<strong>父元素</strong>上统一处理子元素事件；</li><li><strong>优势</strong>： <ul><li>减少内存占用（避免为大量子元素绑定监听器）；</li><li>动态新增元素自动生效；</li></ul></li><li><strong>实现</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e.target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matches</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.child&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul><hr><h3 id="三、关键-api-与行为" tabindex="-1">三、<strong>关键 API 与行为</strong> <a class="header-anchor" href="#三、关键-api-与行为" aria-label="Permalink to “三、关键 API 与行为”">​</a></h3><table tabindex="0"><thead><tr><th>方法 / 属性</th><th>作用</th></tr></thead><tbody><tr><td><code>event.stopPropagation()</code></td><td>阻止事件继续传播（捕获/冒泡）</td></tr><tr><td><code>event.stopImmediatePropagation()</code></td><td>阻止同级其他监听器执行 + 停止传播</td></tr><tr><td><code>event.preventDefault()</code></td><td>阻止默认行为（如 <code>&lt;a&gt;</code> 跳转、表单提交）</td></tr><tr><td><code>event.target</code></td><td>实际触发事件的元素（可能不是绑定监听器的元素）</td></tr><tr><td><code>event.currentTarget</code></td><td>绑定监听器的元素（等价于 <code>this</code>）</td></tr></tbody></table><hr><h3 id="四、特殊事件类型" tabindex="-1">四、<strong>特殊事件类型</strong> <a class="header-anchor" href="#四、特殊事件类型" aria-label="Permalink to “四、特殊事件类型”">​</a></h3><ul><li><strong>合成事件（Synthetic Events）</strong>：React 等框架封装的跨浏览器兼容层；</li><li><strong>被动事件（Passive Event）</strong>：提升滚动性能（禁止 <code>preventDefault</code>）：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;touchstart&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handler, { passive: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div></li><li><strong>自定义事件</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CustomEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-event&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { detail: data });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatchEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ev);</span></span></code></pre></div></li></ul><hr><h3 id="💡-最佳实践-1" tabindex="-1">💡 最佳实践 <a class="header-anchor" href="#💡-最佳实践-1" aria-label="Permalink to “💡 最佳实践”">​</a></h3><ul><li><strong>优先使用事件委托</strong>（尤其列表、动态内容）；</li><li><strong>避免在冒泡阶段滥用 <code>stopPropagation</code></strong>（可能破坏第三方组件逻辑）；</li><li><strong>高频事件（scroll/mousemove）务必节流 + passive 优化</strong>；</li><li><strong>移除监听器防内存泄漏</strong>（尤其在 SPA 组件销毁时）。</li></ul><hr><h3 id="✅-一句话总结-1" tabindex="-1">✅ 一句话总结 <a class="header-anchor" href="#✅-一句话总结-1" aria-label="Permalink to “✅ 一句话总结”">​</a></h3><blockquote><p><strong>浏览器事件沿“捕获→目标→冒泡”传播，默认只冒泡；通过委托、节流、被动监听等策略可构建高性能、可维护的交互系统。</strong></p></blockquote><h2 id="浏览器的事件循环和node的事件循环区别" tabindex="-1">浏览器的事件循环和node的事件循环区别 <a class="header-anchor" href="#浏览器的事件循环和node的事件循环区别" aria-label="Permalink to “浏览器的事件循环和node的事件循环区别”">​</a></h2><p>浏览器和 Node.js 的事件循环（Event Loop）都基于 <strong>“异步回调调度”</strong> 模型，但因运行环境不同，在<strong>阶段划分、任务优先级、API 实现</strong>上有关键差异。以下是前端工程师需掌握的核心区别：</p><hr><h3 id="✅-一、宏观架构对比" tabindex="-1">✅ 一、宏观架构对比 <a class="header-anchor" href="#✅-一、宏观架构对比" aria-label="Permalink to “✅ 一、宏观架构对比”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>浏览器 Event Loop</th><th>Node.js Event Loop（v11+）</th></tr></thead><tbody><tr><td><strong>规范依据</strong></td><td>HTML 标准</td><td>基于 libuv（C++ 库）</td></tr><tr><td><strong>主要任务类型</strong></td><td>渲染、用户交互、网络、定时器</td><td>I/O、文件系统、网络、子进程、定时器</td></tr><tr><td><strong>是否含渲染相关</strong></td><td>✅ 包含 <code>requestAnimationFrame</code> 等</td><td>❌ 无</td></tr></tbody></table><hr><h3 id="✅-二、核心阶段与执行顺序" tabindex="-1">✅ 二、核心阶段与执行顺序 <a class="header-anchor" href="#✅-二、核心阶段与执行顺序" aria-label="Permalink to “✅ 二、核心阶段与执行顺序”">​</a></h3><h4 id="🔹-浏览器-event-loop-简化模型" tabindex="-1">🔹 <strong>浏览器 Event Loop（简化模型）</strong> <a class="header-anchor" href="#🔹-浏览器-event-loop-简化模型" aria-label="Permalink to “🔹 浏览器 Event Loop（简化模型）”">​</a></h4><ol><li>执行 <strong>宏任务（MacroTask）</strong> 队列中的一个任务（如 <code>script</code>、<code>setTimeout</code>、I/O）；</li><li>执行 <strong>所有微任务（MicroTask）</strong>（如 <code>Promise.then</code>、<code>MutationObserver</code>）；</li><li><strong>渲染阶段</strong>（可选）： <ul><li>执行 <code>requestAnimationFrame</code> 回调；</li><li>布局、绘制（若需）；</li></ul></li><li>下一轮宏任务。</li></ol><blockquote><p>📌 <strong>关键</strong>：每轮宏任务后，<strong>清空所有微任务</strong>，再考虑渲染。</p></blockquote><h4 id="🔹-node-js-event-loop-libuv-六阶段" tabindex="-1">🔹 <strong>Node.js Event Loop（libuv 六阶段）</strong> <a class="header-anchor" href="#🔹-node-js-event-loop-libuv-六阶段" aria-label="Permalink to “🔹 Node.js Event Loop（libuv 六阶段）”">​</a></h4><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>┌───────────────────────┐</span></span>
<span class="line"><span>│        timers         │ → 执行 setTimeout/setInterval 回调</span></span>
<span class="line"><span>├───────────────────────┤</span></span>
<span class="line"><span>│ pending callbacks     │ → 执行延迟的 I/O 回调（如 TCP 错误）</span></span>
<span class="line"><span>├───────────────────────┤</span></span>
<span class="line"><span>│     idle, prepare     │ → 内部使用</span></span>
<span class="line"><span>├───────────────────────┤</span></span>
<span class="line"><span>│      poll             │ → 获取新 I/O 事件，执行 I/O 回调（重点！）</span></span>
<span class="line"><span>├───────────────────────┤</span></span>
<span class="line"><span>│      check            │ → 执行 setImmediate() 回调</span></span>
<span class="line"><span>├───────────────────────┤</span></span>
<span class="line"><span>│    close callbacks    │ → 执行 close 事件（如 socket.on(&#39;close&#39;)）</span></span>
<span class="line"><span>└───────────────────────┘</span></span></code></pre></div><ul><li><strong>每阶段结束后</strong>，会执行当前阶段的 <strong>微任务（Promise.then 等）</strong>；</li><li><strong><code>process.nextTick()</code> 优先级最高</strong>：在<strong>任意阶段结束后立即执行</strong>，甚至高于 Promise。</li></ul><hr><h3 id="✅-三、关键行为差异" tabindex="-1">✅ 三、关键行为差异 <a class="header-anchor" href="#✅-三、关键行为差异" aria-label="Permalink to “✅ 三、关键行为差异”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>浏览器</th><th>Node.js</th></tr></thead><tbody><tr><td><strong><code>setTimeout(fn, 0)</code> vs <code>setImmediate</code></strong></td><td>只有 <code>setTimeout</code>（最小延迟 ≈4ms）</td><td><code>setImmediate</code> 在 poll 阶段后执行，通常比 <code>setTimeout(0)</code> <strong>更快</strong></td></tr><tr><td><strong>微任务来源</strong></td><td><code>Promise.then</code>, <code>MutationObserver</code>, <code>queueMicrotask</code></td><td>同左 + <code>process.nextTick</code>（更高优先级）</td></tr><tr><td><strong>I/O 异步处理</strong></td><td>主要靠 Web API（如 fetch）</td><td>由 libuv 的 <strong>poll 阶段</strong> 统一调度</td></tr><tr><td><strong>首屏 script 执行</strong></td><td>作为第一个宏任务</td><td>顶层代码同步执行，不进事件循环</td></tr></tbody></table><hr><h3 id="✅-四、经典面试题示例" tabindex="-1">✅ 四、经典面试题示例 <a class="header-anchor" href="#✅-四、经典面试题示例" aria-label="Permalink to “✅ 四、经典面试题示例”">​</a></h3><h4 id="代码" tabindex="-1">代码： <a class="header-anchor" href="#代码" aria-label="Permalink to “代码：”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;timeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setImmediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;immediate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><ul><li><p><strong>浏览器输出</strong>：<br><code>promise</code> → <code>timeout</code>（<code>setImmediate</code> 不存在）</p></li><li><p><strong>Node.js 输出（非 I/O 上下文）</strong>：<br> 不确定！<code>setTimeout</code> 和 <code>setImmediate</code> 顺序取决于事件循环启动速度（通常 <code>timeout</code> 先）；<br><strong>但在 I/O 回调内（如 fs.readFile）</strong>：<br><code>promise</code> → <code>immediate</code> → <code>timeout</code>（因为 <code>setImmediate</code> 在 poll 后立即执行）</p></li></ul><hr><h3 id="💡-总结口诀-1" tabindex="-1">💡 总结口诀 <a class="header-anchor" href="#💡-总结口诀-1" aria-label="Permalink to “💡 总结口诀”">​</a></h3><blockquote><p><strong>浏览器：宏任务 → 清空微任务 → 渲染；</strong><br><strong>Node.js：六阶段循环，<code>nextTick</code> 最高，<code>setImmediate</code> 在 poll 后；</strong><br><strong>共性：微任务总在当前操作后立即执行，但 Node 多一层 <code>nextTick</code> 优先级。</strong></p></blockquote><blockquote><p>⚠️ 注意：Node.js v11+ 已对微任务调度与浏览器对齐（每阶段后清空微任务），但 <code>process.nextTick</code> 仍是特例。</p></blockquote><h2 id="浏览器的垃圾回收机制" tabindex="-1">浏览器的垃圾回收机制 <a class="header-anchor" href="#浏览器的垃圾回收机制" aria-label="Permalink to “浏览器的垃圾回收机制”">​</a></h2><p>浏览器的垃圾回收（Garbage Collection, GC）机制用于自动管理内存，核心目标是<strong>释放不再使用的对象所占内存</strong>。现代浏览器（如 Chrome 的 V8 引擎）主要采用以下策略：</p><hr><h3 id="✅-一、核心原理-可达性分析-reachability" tabindex="-1">✅ 一、核心原理：可达性分析（Reachability） <a class="header-anchor" href="#✅-一、核心原理-可达性分析-reachability" aria-label="Permalink to “✅ 一、核心原理：可达性分析（Reachability）”">​</a></h3><ul><li><strong>GC 根（Roots）</strong>：全局对象（如 <code>window</code>）、当前执行栈中的变量、内置对象等；</li><li><strong>存活对象</strong>：从 GC 根出发<strong>能直接或间接引用到的对象</strong>；</li><li><strong>垃圾对象</strong>：无法从根访问的对象 → 被回收。</li></ul><blockquote><p>📌 不是“引用计数为 0”，而是“不可达”——可解决循环引用问题。</p></blockquote><hr><h3 id="✅-二、主流-gc-算法-以-v8-为例" tabindex="-1">✅ 二、主流 GC 算法（以 V8 为例） <a class="header-anchor" href="#✅-二、主流-gc-算法-以-v8-为例" aria-label="Permalink to “✅ 二、主流 GC 算法（以 V8 为例）”">​</a></h3><h4 id="_1-分代式垃圾回收-generational-gc" tabindex="-1">1. <strong>分代式垃圾回收（Generational GC）</strong> <a class="header-anchor" href="#_1-分代式垃圾回收-generational-gc" aria-label="Permalink to “1. 分代式垃圾回收（Generational GC）”">​</a></h4><p>V8 将堆内存分为两代：</p><ul><li><p><strong>新生代（Young Generation）</strong></p><ul><li>存放<strong>新创建、短生命周期</strong>对象；</li><li>使用 <strong>Scavenge 算法（Cheney 复制算法）</strong>： <ul><li>内存分为 <code>From</code> 和 <code>To</code> 两个半区；</li><li>活跃对象从 <code>From</code> 复制到 <code>To</code>，清空 <code>From</code>；</li><li>存活多次后晋升到老生代。</li></ul></li><li><strong>优点</strong>：快速回收短命对象；</li><li><strong>缺点</strong>：内存利用率仅 50%。</li></ul></li><li><p><strong>老生代（Old Generation）</strong></p><ul><li>存放<strong>长期存活</strong>对象；</li><li>使用 <strong>标记-清除（Mark-Sweep） + 标记-整理（Mark-Compact）</strong>： <ul><li><strong>标记</strong>：遍历所有可达对象；</li><li><strong>清除</strong>：回收未标记对象；</li><li><strong>整理</strong>：移动存活对象消除内存碎片（耗时，按需触发）。</li></ul></li></ul></li></ul><h4 id="_2-增量标记-incremental-marking-并发-并行-gc" tabindex="-1">2. <strong>增量标记（Incremental Marking） &amp; 并发/并行 GC</strong> <a class="header-anchor" href="#_2-增量标记-incremental-marking-并发-并行-gc" aria-label="Permalink to “2. 增量标记（Incremental Marking） &amp; 并发/并行 GC”">​</a></h4><ul><li><strong>问题</strong>：老生代 GC 停顿时间长（“Stop-The-World”）；</li><li><strong>优化</strong>： <ul><li><strong>增量标记</strong>：将标记过程拆分为多步，穿插在 JS 执行中，减少单次停顿；</li><li><strong>并发/并行</strong>：利用多核 CPU，在后台线程执行部分 GC 工作。</li></ul></li></ul><hr><h3 id="✅-三、前端开发者需注意的内存问题" tabindex="-1">✅ 三、前端开发者需注意的内存问题 <a class="header-anchor" href="#✅-三、前端开发者需注意的内存问题" aria-label="Permalink to “✅ 三、前端开发者需注意的内存问题”">​</a></h3><table tabindex="0"><thead><tr><th>问题类型</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td><strong>意外全局变量</strong></td><td>未声明变量 → 挂载到 <code>window</code></td><td>使用严格模式（<code>&#39;use strict&#39;</code>）</td></tr><tr><td><strong>闭包泄漏</strong></td><td>内部函数持有外部大对象引用</td><td>手动置 <code>null</code> 或重构作用域</td></tr><tr><td><strong>DOM 泄漏</strong></td><td>移除 DOM 但保留 JS 引用</td><td>移除事件监听器 + 清空引用</td></tr><tr><td><strong>定时器/回调</strong></td><td><code>setInterval</code> 未清理</td><td>组件销毁时调用 <code>clearInterval</code></td></tr><tr><td><strong>缓存无上限</strong></td><td>Map/Set 不断增长</td><td>设置 LRU 限制或定期清理</td></tr></tbody></table><hr><h3 id="✅-四、性能建议" tabindex="-1">✅ 四、性能建议 <a class="header-anchor" href="#✅-四、性能建议" aria-label="Permalink to “✅ 四、性能建议”">​</a></h3><ul><li><strong>避免频繁创建大对象</strong>（触发 GC 频繁）；</li><li><strong>慎用 <code>delete</code> 对象属性</strong>（可能使对象进入“慢路径”）；</li><li><strong>使用 <code>WeakMap</code> / <code>WeakSet</code></strong>：弱引用，不影响 GC；</li><li><strong>监控内存</strong>：Chrome DevTools 的 <strong>Memory 面板</strong> + <strong>Performance 录制</strong>。</li></ul><hr><h3 id="💡-一句话总结" tabindex="-1">💡 一句话总结 <a class="header-anchor" href="#💡-一句话总结" aria-label="Permalink to “💡 一句话总结”">​</a></h3><blockquote><p><strong>浏览器 GC 基于“可达性”判断垃圾，V8 采用分代回收（Scavenge + Mark-Sweep/Compact），并通过增量、并发优化停顿；开发者应避免意外长引用，主动解绑资源。</strong></p></blockquote><h2 id="进程和线程的区别" tabindex="-1">进程和线程的区别? <a class="header-anchor" href="#进程和线程的区别" aria-label="Permalink to “进程和线程的区别?”">​</a></h2><p><strong>进程（Process）和线程（Thread）</strong> 是操作系统进行任务调度和资源管理的基本单位，核心区别如下：</p><hr><h3 id="✅-一、本质定义" tabindex="-1">✅ 一、本质定义 <a class="header-anchor" href="#✅-一、本质定义" aria-label="Permalink to “✅ 一、本质定义”">​</a></h3><table tabindex="0"><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>程序的一次执行实例，拥有<strong>独立内存空间</strong></td><td>进程内的一个<strong>执行单元</strong>，共享进程资源</td></tr><tr><td><strong>粒度</strong></td><td>粗（重量级）</td><td>细（轻量级）</td></tr></tbody></table><hr><h3 id="✅-二、关键区别" tabindex="-1">✅ 二、关键区别 <a class="header-anchor" href="#✅-二、关键区别" aria-label="Permalink to “✅ 二、关键区别”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td><strong>内存空间</strong></td><td>✅ 完全隔离（独立堆、栈、数据段）</td><td>❌ 共享所属进程的堆、全局变量等</td></tr><tr><td><strong>通信方式</strong></td><td>IPC（管道、消息队列、共享内存等，开销大）</td><td>直接读写共享内存（需同步，如锁、信号量）</td></tr><tr><td><strong>创建/切换开销</strong></td><td>大（需分配独立资源）</td><td>小（只需栈和寄存器上下文）</td></tr><tr><td><strong>稳定性/安全性</strong></td><td>高（一个崩溃不影响其他进程）</td><td>低（一个线程崩溃可能导致整个进程退出）</td></tr><tr><td><strong>并发性</strong></td><td>进程间并发</td><td>线程间并发（更高效利用多核）</td></tr></tbody></table><blockquote><p>📌 <strong>一句话</strong>：<strong>进程是“资源拥有者”，线程是“CPU 调度者”</strong>。</p></blockquote><hr><h3 id="✅-三、类比理解" tabindex="-1">✅ 三、类比理解 <a class="header-anchor" href="#✅-三、类比理解" aria-label="Permalink to “✅ 三、类比理解”">​</a></h3><ul><li><strong>进程 = 工厂</strong>（有独立厂房、设备、原料库）</li><li><strong>线程 = 工人</strong>（在同一个工厂内协作，共用设备和原料，但各有自己的工具箱（栈））</li></ul><hr><h3 id="✅-四、前端相关场景" tabindex="-1">✅ 四、前端相关场景 <a class="header-anchor" href="#✅-四、前端相关场景" aria-label="Permalink to “✅ 四、前端相关场景”">​</a></h3><ul><li><strong>浏览器多进程架构</strong>（Chromium）： <ul><li>浏览器主进程、GPU 进程、网络进程、<strong>每个标签页（Renderer 进程）</strong> → 隔离崩溃；</li></ul></li><li><strong>Web Worker</strong>： <ul><li>在<strong>同进程内</strong>开启新线程（JS 主线程 + Worker 线程），<strong>共享 JS 引擎但不共享内存</strong>（通过 <code>postMessage</code> 通信）；</li><li>⚠️ 注意：Web Worker 是<strong>线程</strong>，但因安全限制<strong>不能直接访问 DOM</strong>。</li></ul></li></ul><hr><h3 id="💡-总结-2" tabindex="-1">💡 总结 <a class="header-anchor" href="#💡-总结-2" aria-label="Permalink to “💡 总结”">​</a></h3><blockquote><p><strong>进程隔离资源，线程共享资源；多进程保稳定，多线程提性能。</strong><br> 前端虽不直接操作 OS 级线程，但需理解浏览器多进程模型与 Web Worker 的线程语义。</p></blockquote><h2 id="浏览器渲染进程有哪些线程" tabindex="-1">浏览器渲染进程有哪些线程 <a class="header-anchor" href="#浏览器渲染进程有哪些线程" aria-label="Permalink to “浏览器渲染进程有哪些线程”">​</a></h2><p>现代浏览器（以 Chromium 为例）的<strong>渲染进程（Renderer Process）</strong> 是多线程架构，主要包含以下 <strong>5 个核心线程</strong>，各司其职以实现高性能、安全的页面渲染：</p><hr><h3 id="✅-1-主线程-main-thread-——-js-执行-dom-操作核心" tabindex="-1">✅ 1. <strong>主线程（Main Thread）</strong> —— <strong>JS 执行 &amp; DOM 操作核心</strong> <a class="header-anchor" href="#✅-1-主线程-main-thread-——-js-执行-dom-操作核心" aria-label="Permalink to “✅ 1. 主线程（Main Thread） —— JS 执行 &amp; DOM 操作核心”">​</a></h3><ul><li>负责： <ul><li>解析 HTML/CSS → 构建 DOM/CSSOM；</li><li>执行 JavaScript（包括事件回调、Promise、setTimeout 等）；</li><li>触发 <strong>Layout（回流）</strong> 和 <strong>Paint（重绘）</strong>；</li></ul></li><li>⚠️ <strong>单线程</strong>：所有 JS 和渲染任务在此排队执行，<strong>长任务会阻塞页面响应</strong>。</li></ul><hr><h3 id="✅-2-合成线程-compositor-thread-——-高性能动画关键" tabindex="-1">✅ 2. <strong>合成线程（Compositor Thread）</strong> —— <strong>高性能动画关键</strong> <a class="header-anchor" href="#✅-2-合成线程-compositor-thread-——-高性能动画关键" aria-label="Permalink to “✅ 2. 合成线程（Compositor Thread） —— 高性能动画关键”">​</a></h3><ul><li>负责： <ul><li>接收主线程生成的<strong>图层（Layers）</strong>；</li><li>执行 <strong>合成（Compositing）</strong>：将图层按 <code>z-index</code>、<code>transform</code> 等合并；</li><li>直接提交给 GPU 渲染，<strong>无需主线程参与</strong>；</li></ul></li><li>✅ 优势：即使主线程卡死，<code>transform</code>/<code>opacity</code> 动画仍流畅（硬件加速）。</li></ul><hr><h3 id="✅-3-光栅化线程-raster-thread-——-位图生成" tabindex="-1">✅ 3. <strong>光栅化线程（Raster Thread）</strong> —— <strong>位图生成</strong> <a class="header-anchor" href="#✅-3-光栅化线程-raster-thread-——-位图生成" aria-label="Permalink to “✅ 3. 光栅化线程（Raster Thread） —— 位图生成”">​</a></h3><ul><li>负责： <ul><li>将合成线程指定的图层内容<strong>转换为位图（光栅化）</strong>；</li><li>可运行在 <strong>GPU 或 CPU</strong> 上（取决于硬件和设置）；</li></ul></li><li>⚠️ 若内容复杂（如大图、阴影），可能成为性能瓶颈。</li></ul><hr><h3 id="✅-4-worker-线程-web-worker-threads-——-用户可控的后台线程" tabindex="-1">✅ 4. <strong>Worker 线程（Web Worker Threads）</strong> —— <strong>用户可控的后台线程</strong> <a class="header-anchor" href="#✅-4-worker-线程-web-worker-threads-——-用户可控的后台线程" aria-label="Permalink to “✅ 4. Worker 线程（Web Worker Threads） —— 用户可控的后台线程”">​</a></h3><ul><li>由开发者通过 <code>new Worker()</code> 创建；</li><li>特点： <ul><li><strong>与主线程并行执行</strong>，不阻塞 UI；</li><li><strong>不能访问 DOM / window / document</strong>；</li><li>通过 <code>postMessage</code> 与主线程通信（结构化克隆）；</li></ul></li><li>用途：密集计算（如图像处理、加密、数据解析）。</li></ul><hr><h3 id="✅-5-io-线程-内部使用-部分版本存在" tabindex="-1">✅ 5. <strong>IO 线程（内部使用，部分版本存在）</strong> <a class="header-anchor" href="#✅-5-io-线程-内部使用-部分版本存在" aria-label="Permalink to “✅ 5. IO 线程（内部使用，部分版本存在）”">​</a></h3><ul><li>处理磁盘缓存读写、网络数据接收等 I/O 操作；</li><li>避免阻塞主线程（实际网络请求通常由<strong>独立的 Browser 进程</strong>处理，通过 IPC 传给 Renderer）。</li></ul><hr><h3 id="🔄-线程协作流程-简化" tabindex="-1">🔄 线程协作流程（简化） <a class="header-anchor" href="#🔄-线程协作流程-简化" aria-label="Permalink to “🔄 线程协作流程（简化）”">​</a></h3><p><img src="`+n+`" alt="An image"></p><hr><h3 id="💡-前端性能关键点" tabindex="-1">💡 前端性能关键点 <a class="header-anchor" href="#💡-前端性能关键点" aria-label="Permalink to “💡 前端性能关键点”">​</a></h3><ul><li><strong>避免主线程长任务</strong> → 使用 <code>Web Worker</code> 或拆分任务（<code>requestIdleCallback</code>）；</li><li><strong>动画优先用 <code>transform</code>/<code>opacity</code></strong> → 触发合成线程，跳过 Layout/Paint；</li><li><strong>减少强制同步布局</strong> → 防止主线程频繁计算几何属性。</li></ul><hr><h3 id="✅-总结" tabindex="-1">✅ 总结 <a class="header-anchor" href="#✅-总结" aria-label="Permalink to “✅ 总结”">​</a></h3><blockquote><p>渲染进程 = <strong>主线程（JS+DOM） + 合成线程（动画） + 光栅线程（绘图） + Worker 线程（计算）</strong><br> 理解线程分工，是优化 Web 性能、实现 60fps 流畅体验的基础。</p></blockquote><h2 id="web安全攻击方式及防御方法" tabindex="-1">web安全攻击方式及防御方法 <a class="header-anchor" href="#web安全攻击方式及防御方法" aria-label="Permalink to “web安全攻击方式及防御方法”">​</a></h2><p>Web 安全攻击方式繁多，以下是<strong>前端工程师必须掌握的 6 大常见攻击类型及其核心防御方法</strong>，按危害性和发生频率排序：</p><hr><h3 id="_1-xss-跨站脚本攻击" tabindex="-1">1. <strong>XSS（跨站脚本攻击）</strong> <a class="header-anchor" href="#_1-xss-跨站脚本攻击" aria-label="Permalink to “1. XSS（跨站脚本攻击）”">​</a></h3><ul><li><strong>原理</strong>：攻击者注入恶意脚本（如 <code>&lt;script&gt;</code>），在用户浏览器执行。</li><li><strong>类型</strong>： <ul><li><strong>反射型</strong>：恶意脚本来自 URL 参数（如搜索框）；</li><li><strong>存储型</strong>：脚本存入数据库（如评论区）；</li><li><strong>DOM 型</strong>：前端 JS 直接操作 <code>innerHTML</code>/<code>location.hash</code>。</li></ul></li><li><strong>防御</strong>： <ul><li><strong>输出编码</strong>：对动态内容做 HTML 转义（如 <code>&lt;</code> → <code>&amp;lt;</code>）；</li><li><strong>CSP（Content Security Policy）</strong>：限制脚本来源（<code>script-src &#39;self&#39;</code>）；</li><li><strong>避免 innerHTML</strong>：用 <code>textContent</code> 或安全框架（React/Vue 默认转义）；</li><li><strong>HttpOnly Cookie</strong>：防止 JS 窃取 Cookie。</li></ul></li></ul><hr><h3 id="_2-csrf-跨站请求伪造" tabindex="-1">2. <strong>CSRF（跨站请求伪造）</strong> <a class="header-anchor" href="#_2-csrf-跨站请求伪造" aria-label="Permalink to “2. CSRF（跨站请求伪造）”">​</a></h3><ul><li><strong>原理</strong>：诱导用户点击恶意链接，在已登录状态下<strong>自动携带 Cookie</strong> 向目标站发起请求（如转账）。</li><li><strong>防御</strong>： <ul><li><strong>SameSite Cookie</strong>：<code>Set-Cookie: SameSite=Strict</code>（现代浏览器默认 Lax）；</li><li><strong>Anti-CSRF Token</strong>：表单/API 请求携带一次性 token（服务端校验）；</li><li><strong>验证 Origin/Referer 头</strong>（辅助手段）。</li></ul></li></ul><hr><h3 id="_3-点击劫持-clickjacking" tabindex="-1">3. <strong>点击劫持（Clickjacking）</strong> <a class="header-anchor" href="#_3-点击劫持-clickjacking" aria-label="Permalink to “3. 点击劫持（Clickjacking）”">​</a></h3><ul><li><strong>原理</strong>：用透明 <code>&lt;iframe&gt;</code> 覆盖按钮，诱使用户点击非预期操作。</li><li><strong>防御</strong>： <ul><li><strong>X-Frame-Options</strong>：<code>DENY</code> 或 <code>SAMEORIGIN</code>（阻止被嵌入 iframe）；</li><li><strong>CSP frame-ancestors</strong>：<code>Content-Security-Policy: frame-ancestors &#39;self&#39;</code>。</li></ul></li></ul><hr><h3 id="_4-中间人攻击-mitm-明文传输" tabindex="-1">4. <strong>中间人攻击（MITM） &amp; 明文传输</strong> <a class="header-anchor" href="#_4-中间人攻击-mitm-明文传输" aria-label="Permalink to “4. 中间人攻击（MITM） &amp; 明文传输”">​</a></h3><ul><li><strong>原理</strong>：HTTP 明文传输，可被窃听/篡改（如公共 Wi-Fi）。</li><li><strong>防御</strong>： <ul><li><strong>强制 HTTPS</strong>：HSTS（<code>Strict-Transport-Security</code> 头）；</li><li><strong>证书校验</strong>：避免忽略证书错误（尤其移动端）。</li></ul></li></ul><hr><h3 id="_5-接口安全-越权、参数篡改" tabindex="-1">5. <strong>接口安全（越权、参数篡改）</strong> <a class="header-anchor" href="#_5-接口安全-越权、参数篡改" aria-label="Permalink to “5. 接口安全（越权、参数篡改）”">​</a></h3><ul><li><strong>原理</strong>：前端隐藏按钮 ≠ 后端无权限，攻击者直接调用 API。</li><li><strong>防御</strong>： <ul><li><strong>后端鉴权</strong>：每个接口校验用户角色/数据归属（<strong>前端不可信！</strong>）；</li><li><strong>敏感操作二次验证</strong>：如支付需短信/密码；</li><li><strong>参数校验</strong>：后端严格校验 ID、金额等字段合法性。</li></ul></li></ul><hr><h3 id="_6-第三方资源风险" tabindex="-1">6. <strong>第三方资源风险</strong> <a class="header-anchor" href="#_6-第三方资源风险" aria-label="Permalink to “6. 第三方资源风险”">​</a></h3><ul><li><strong>原理</strong>：引入 CDN 脚本/图片可能被投毒（如 <code>//unpkg.com/evil.js</code>）。</li><li><strong>防御</strong>： <ul><li><strong>SRI（Subresource Integrity）</strong>：<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://cdn.example.com/app.js&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        integrity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sha384-abc123...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><strong>CSP 限制来源</strong>：<code>script-src https://trusted.cdn.com</code>。</li></ul></li></ul><hr><h3 id="🔒-通用防御原则-前端视角" tabindex="-1">🔒 通用防御原则（前端视角） <a class="header-anchor" href="#🔒-通用防御原则-前端视角" aria-label="Permalink to “🔒 通用防御原则（前端视角）”">​</a></h3><table tabindex="0"><thead><tr><th>原则</th><th>实践</th></tr></thead><tbody><tr><td><strong>永远不信任前端</strong></td><td>所有安全逻辑必须由后端实现</td></tr><tr><td><strong>最小权限原则</strong></td><td>Cookie 加 <code>HttpOnly</code> + <code>Secure</code> + <code>SameSite</code></td></tr><tr><td><strong>输入输出过滤</strong></td><td>前端防 XSS（输出编码），后端防 SQL 注入（参数化查询）</td></tr><tr><td><strong>安全头加固</strong></td><td>配置 CSP、X-Frame-Options、HSTS 等</td></tr></tbody></table><hr><h3 id="💡-总结口诀-2" tabindex="-1">💡 总结口诀 <a class="header-anchor" href="#💡-总结口诀-2" aria-label="Permalink to “💡 总结口诀”">​</a></h3><blockquote><p><strong>XSS 防注入，CSRF 防伪造，<br> 点击劫持设 X-Frame，<br> 敏感操作后端验，<br> HTTPS + CSP 保平安。</strong></p></blockquote><blockquote><p>⚠️ 记住：<strong>前端是攻击入口，后端是安全底线</strong>。任何前端“隐藏”或“禁用”都不能替代服务端校验。</p></blockquote><h2 id="浏览器存储数据方式有哪些" tabindex="-1">浏览器存储数据方式有哪些 <a class="header-anchor" href="#浏览器存储数据方式有哪些" aria-label="Permalink to “浏览器存储数据方式有哪些”">​</a></h2><p>浏览器提供了多种客户端数据存储方式，各有适用场景、容量限制和生命周期。以下是前端工程师必须掌握的 <strong>6 种核心存储机制</strong>及其对比：</p><hr><h3 id="✅-1-cookie" tabindex="-1">✅ 1. <strong>Cookie</strong> <a class="header-anchor" href="#✅-1-cookie" aria-label="Permalink to “✅ 1. Cookie”">​</a></h3><ul><li><strong>用途</strong>：会话管理（如登录态）、个性化设置；</li><li><strong>特点</strong>： <ul><li>每次 HTTP 请求<strong>自动携带</strong>（增加带宽）；</li><li>容量小（<strong>≈4KB/条</strong>）；</li><li>可设过期时间（<code>Expires</code>/<code>Max-Age</code>）；</li><li>支持 <code>HttpOnly</code>（防 XSS 窃取）、<code>Secure</code>（仅 HTTPS）、<code>SameSite</code>（防 CSRF）。</li></ul></li><li><strong>API</strong>：<code>document.cookie = &quot;key=value; path=/; max-age=3600&quot;</code></li></ul><hr><h3 id="✅-2-localstorage" tabindex="-1">✅ 2. <strong>localStorage</strong> <a class="header-anchor" href="#✅-2-localstorage" aria-label="Permalink to “✅ 2. localStorage”">​</a></h3><ul><li><strong>用途</strong>：持久化存储（关浏览器不丢失）；</li><li><strong>特点</strong>： <ul><li><strong>同源策略</strong>限制（协议+域名+端口相同）；</li><li>容量大（<strong>≈5–10MB</strong>）；</li><li><strong>仅字符串</strong>（需 <code>JSON.stringify</code> 存对象）；</li><li><strong>无过期机制</strong>（手动清除）；</li><li><strong>同步 API</strong>，阻塞主线程（不适合大量数据）。</li></ul></li><li><strong>API</strong>：<code>localStorage.setItem(&#39;key&#39;, &#39;value&#39;)</code></li></ul><hr><h3 id="✅-3-sessionstorage" tabindex="-1">✅ 3. <strong>sessionStorage</strong> <a class="header-anchor" href="#✅-3-sessionstorage" aria-label="Permalink to “✅ 3. sessionStorage”">​</a></h3><ul><li><strong>用途</strong>：临时会话数据（页面刷新保留，关闭标签页清除）；</li><li><strong>特点</strong>： <ul><li>同 <code>localStorage</code>，但<strong>生命周期仅限当前会话</strong>；</li><li>不同 tab 间<strong>不共享</strong>（即使同源）。</li></ul></li><li><strong>API</strong>：<code>sessionStorage.getItem(&#39;key&#39;)</code></li></ul><hr><h3 id="✅-4-indexeddb" tabindex="-1">✅ 4. <strong>IndexedDB</strong> <a class="header-anchor" href="#✅-4-indexeddb" aria-label="Permalink to “✅ 4. IndexedDB”">​</a></h3><ul><li><strong>用途</strong>：存储<strong>大量结构化数据</strong>（如离线应用、PWA 缓存）；</li><li><strong>特点</strong>： <ul><li><strong>异步 API</strong>（不阻塞主线程）；</li><li>容量极大（<strong>≈50% 磁盘空间</strong>，用户可授权）；</li><li>支持<strong>事务、索引、游标查询</strong>；</li><li>操作复杂（需封装或使用库如 <code>idb</code>）。</li></ul></li><li><strong>典型场景</strong>：缓存用户文档、消息历史、离线地图数据。</li></ul><hr><h3 id="✅-5-web-sql-已废弃" tabindex="-1">✅ 5. <strong>Web SQL（已废弃）</strong> <a class="header-anchor" href="#✅-5-web-sql-已废弃" aria-label="Permalink to “✅ 5. Web SQL（已废弃）”">​</a></h3><ul><li><strong>状态</strong>：<strong>非标准，已被废弃</strong>（仅 Safari/旧版 Chrome 支持）；</li><li><strong>替代方案</strong>：用 <strong>IndexedDB</strong>。</li></ul><hr><h3 id="✅-6-cache-storage-service-worker-专属" tabindex="-1">✅ 6. <strong>Cache Storage（Service Worker 专属）</strong> <a class="header-anchor" href="#✅-6-cache-storage-service-worker-专属" aria-label="Permalink to “✅ 6. Cache Storage（Service Worker 专属）”">​</a></h3><ul><li><strong>用途</strong>：缓存<strong>网络请求</strong>（HTML/CSS/JS/API 响应）；</li><li><strong>特点</strong>： <ul><li>与 Service Worker 配合实现离线访问；</li><li>按 <strong>Request/Response</strong> 存储（非 key-value）；</li><li>需 HTTPS（或 localhost）。</li></ul></li><li><strong>API</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-cache&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/api/data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div></li></ul><hr><h3 id="🔍-对比速查表" tabindex="-1">🔍 对比速查表 <a class="header-anchor" href="#🔍-对比速查表" aria-label="Permalink to “🔍 对比速查表”">​</a></h3><table tabindex="0"><thead><tr><th>存储方式</th><th>容量</th><th>生命周期</th><th>同步/异步</th><th>是否随请求发送</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Cookie</strong></td><td>~4KB</td><td>可设过期</td><td>同步</td><td>✅ 是</td><td>登录态、跟踪</td></tr><tr><td><strong>localStorage</strong></td><td>5–10MB</td><td>永久（手动清除）</td><td>同步</td><td>❌ 否</td><td>用户偏好、主题配置</td></tr><tr><td><strong>sessionStorage</strong></td><td>5–10MB</td><td>当前会话（关页清）</td><td>同步</td><td>❌ 否</td><td>表单草稿、临时状态</td></tr><tr><td><strong>IndexedDB</strong></td><td>≈50% 磁盘</td><td>永久</td><td><strong>异步</strong></td><td>❌ 否</td><td>大量结构化数据、离线应用</td></tr><tr><td><strong>Cache Storage</strong></td><td>动态</td><td>永久（需手动清理）</td><td>异步</td><td>❌ 否</td><td>网络资源缓存（PWA）</td></tr></tbody></table><hr><h3 id="💡-最佳实践-2" tabindex="-1">💡 最佳实践 <a class="header-anchor" href="#💡-最佳实践-2" aria-label="Permalink to “💡 最佳实践”">​</a></h3><ul><li><strong>敏感数据</strong>（如 token）→ 用 <strong>HttpOnly Cookie</strong>（防 XSS）；</li><li><strong>简单配置</strong> → <code>localStorage</code>；</li><li><strong>离线优先应用</strong> → <strong>IndexedDB + Cache Storage</strong>；</li><li><strong>避免滥用 Cookie</strong>（影响性能）；</li><li><strong>跨标签通信</strong> → <code>localStorage</code> + <code>storage</code> 事件 或 <code>BroadcastChannel</code>。</li></ul><blockquote><p>✅ <strong>一句话总结</strong>：<br><strong>小数据用 Storage，会话用 Cookie，大数据上 IndexedDB，离线靠 Cache API。</strong></p></blockquote><h2 id="如何实现浏览器内多个标签页之间的通信" tabindex="-1">如何实现浏览器内多个标签页之间的通信 <a class="header-anchor" href="#如何实现浏览器内多个标签页之间的通信" aria-label="Permalink to “如何实现浏览器内多个标签页之间的通信”">​</a></h2><p>在浏览器中实现多个标签页（同源）之间的通信，有以下 <strong>5 种主流方案</strong>，按推荐度排序：</p><hr><h3 id="✅-1-broadcastchannel-api-现代首选" tabindex="-1">✅ 1. <strong>BroadcastChannel API（现代首选）</strong> <a class="header-anchor" href="#✅-1-broadcastchannel-api-现代首选" aria-label="Permalink to “✅ 1. BroadcastChannel API（现代首选）”">​</a></h3><ul><li><strong>原理</strong>：创建一个广播通道，所有监听该通道的标签页可收发消息。</li><li><strong>优点</strong>：简单、高效、专为跨标签通信设计。</li><li><strong>兼容性</strong>：现代浏览器（Chrome 54+、Firefox 38+、Safari 15.4+）。</li><li><strong>代码示例</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 所有标签页加入同一频道</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> channel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BroadcastChannel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-channel&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">channel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;收到:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, e.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><strong>清理</strong>：<code>channel.close()</code>。</li></ul><hr><h3 id="✅-2-localstorage-storage-事件-兼容性最佳" tabindex="-1">✅ 2. <strong>localStorage + storage 事件（兼容性最佳）</strong> <a class="header-anchor" href="#✅-2-localstorage-storage-事件-兼容性最佳" aria-label="Permalink to “✅ 2. localStorage + storage 事件（兼容性最佳）”">​</a></h3><ul><li><strong>原理</strong>：一个标签页修改 <code>localStorage</code>，其他同源标签页会触发 <code>storage</code> 事件。</li><li><strong>优点</strong>：兼容所有现代浏览器（包括 IE8+）。</li><li><strong>限制</strong>：仅在<strong>不同标签页</strong>间触发（当前页修改不会触发自身事件）。</li><li><strong>代码示例</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送方</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">localStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;msg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ time: Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), data: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hi&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收方（其他标签页）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;storage&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;msg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;收到:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.newValue));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul><hr><h3 id="✅-3-sharedworker-较少用" tabindex="-1">✅ 3. <strong>SharedWorker（较少用）</strong> <a class="header-anchor" href="#✅-3-sharedworker-较少用" aria-label="Permalink to “✅ 3. SharedWorker（较少用）”">​</a></h3><ul><li><strong>原理</strong>：多个标签页共享同一个 Worker 线程，通过 <code>port</code> 通信。</li><li><strong>优点</strong>：支持复杂逻辑；可跨 iframe。</li><li><strong>缺点</strong>：API 复杂；iOS Safari 长期不支持（15.4+ 才支持）。</li><li><strong>代码示例</strong>：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// shared-worker.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> connections</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onconnect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> port</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.ports[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  connections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(port);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  port.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    connections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg.data));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 页面中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> worker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SharedWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;shared-worker.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.port.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.port.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.data);</span></span></code></pre></div></li></ul><hr><h3 id="✅-4-cookie-sessionstorage-轮询-不推荐" tabindex="-1">✅ 4. <strong>Cookie / sessionStorage 轮询（不推荐）</strong> <a class="header-anchor" href="#✅-4-cookie-sessionstorage-轮询-不推荐" aria-label="Permalink to “✅ 4. Cookie / sessionStorage 轮询（不推荐）”">​</a></h3><ul><li><strong>原理</strong>：通过定时读取 <code>document.cookie</code> 或 <code>sessionStorage</code> 检测变化。</li><li><strong>缺点</strong>：性能差、延迟高、不可靠。</li><li><strong>仅作备选</strong>：当以上方案均不可用时（如极老浏览器）。</li></ul><hr><h3 id="✅-5-service-worker-中转-间接方案" tabindex="-1">✅ 5. <strong>Service Worker 中转（间接方案）</strong> <a class="header-anchor" href="#✅-5-service-worker-中转-间接方案" aria-label="Permalink to “✅ 5. Service Worker 中转（间接方案）”">​</a></h3><ul><li><strong>原理</strong>：标签页 → Service Worker → 其他标签页（需配合 <code>clients.claim()</code> 和 <code>BroadcastChannel</code>/<code>postMessage</code>）。</li><li><strong>适用场景</strong>：PWA 应用中已有 SW，可复用其作为消息中心。</li><li><strong>注意</strong>：SW 本身不能直接访问 DOM，需通过 <code>client.postMessage</code> 与页面通信。</li></ul><hr><h3 id="🔒-安全注意事项" tabindex="-1">🔒 安全注意事项 <a class="header-anchor" href="#🔒-安全注意事项" aria-label="Permalink to “🔒 安全注意事项”">​</a></h3><ul><li><strong>所有方案均受同源策略限制</strong>（协议+域名+端口必须一致）；</li><li><strong>敏感数据避免明文传输</strong>（如 token），建议加密或仅传事件标识；</li><li><strong>防消息伪造</strong>：校验消息来源（如加签名）。</li></ul><hr><h3 id="💡-推荐选择" tabindex="-1">💡 推荐选择 <a class="header-anchor" href="#💡-推荐选择" aria-label="Permalink to “💡 推荐选择”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>现代浏览器（无需兼容 IE）</td><td><strong>BroadcastChannel</strong></td></tr><tr><td>需兼容旧浏览器</td><td><strong>localStorage + storage 事件</strong></td></tr><tr><td>已使用 Service Worker</td><td><strong>SW 中转 + BroadcastChannel</strong></td></tr></tbody></table><blockquote><p>✅ <strong>一句话总结</strong>：<br><strong>优先用 <code>BroadcastChannel</code>，兼容性要求高则用 <code>localStorage</code> 监听 <code>storage</code> 事件。</strong></p></blockquote><h2 id="tcp和udp的区别" tabindex="-1">tcp和udp的区别 <a class="header-anchor" href="#tcp和udp的区别" aria-label="Permalink to “tcp和udp的区别”">​</a></h2><p>TCP（传输控制协议）和 UDP（用户数据报协议）是传输层的两种核心协议，主要区别体现在<strong>可靠性、连接方式、性能和适用场景</strong>上。以下是清晰对比：</p><hr><h3 id="✅-核心区别速览表" tabindex="-1">✅ 核心区别速览表 <a class="header-anchor" href="#✅-核心区别速览表" aria-label="Permalink to “✅ 核心区别速览表”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td><strong>连接方式</strong></td><td>面向连接（三次握手建立，四次挥手断开）</td><td>无连接（直接发数据包）</td></tr><tr><td><strong>可靠性</strong></td><td>✅ 可靠：确认应答 + 重传 + 排序 + 流控</td><td>❌ 不可靠：不保证到达、不重传、不排序</td></tr><tr><td><strong>传输效率</strong></td><td>较低（头部 20 字节 + 控制开销大）</td><td>较高（头部仅 8 字节 + 无控制逻辑）</td></tr><tr><td><strong>实时性</strong></td><td>差（因重传、排队等机制）</td><td>✅ 好（适合音视频、游戏等低延迟场景）</td></tr><tr><td><strong>数据边界</strong></td><td>无消息边界（字节流）</td><td>✅ 有消息边界（每个包独立）</td></tr><tr><td><strong>拥塞控制</strong></td><td>✅ 有（慢启动、拥塞避免等）</td><td>❌ 无</td></tr><tr><td><strong>适用场景</strong></td><td>Web（HTTP/HTTPS）、文件传输、邮件</td><td>视频会议、直播、DNS 查询、在线游戏</td></tr></tbody></table><hr><h3 id="🔍-详细说明-1" tabindex="-1">🔍 详细说明 <a class="header-anchor" href="#🔍-详细说明-1" aria-label="Permalink to “🔍 详细说明”">​</a></h3><h4 id="_1-连接-vs-无连接" tabindex="-1">1. <strong>连接 vs 无连接</strong> <a class="header-anchor" href="#_1-连接-vs-无连接" aria-label="Permalink to “1. 连接 vs 无连接”">​</a></h4><ul><li><strong>TCP</strong>：通信前必须建立连接（三次握手），结束后释放连接（四次挥手）；</li><li><strong>UDP</strong>：直接发送数据包，无需握手，服务器也不知客户端是否存在。</li></ul><h4 id="_2-可靠性机制" tabindex="-1">2. <strong>可靠性机制</strong> <a class="header-anchor" href="#_2-可靠性机制" aria-label="Permalink to “2. 可靠性机制”">​</a></h4><ul><li><strong>TCP</strong>： <ul><li><strong>ACK 确认</strong>：接收方必须回传确认；</li><li><strong>超时重传</strong>：未收到 ACK 则重发；</li><li><strong>序列号</strong>：保证数据按序到达；</li><li><strong>滑动窗口</strong>：流量控制，防止接收方缓冲区溢出。</li></ul></li><li><strong>UDP</strong>：发完即忘，丢包、乱序、重复均由应用层处理（或忽略）。</li></ul><h4 id="_3-性能与开销" tabindex="-1">3. <strong>性能与开销</strong> <a class="header-anchor" href="#_3-性能与开销" aria-label="Permalink to “3. 性能与开销”">​</a></h4><ul><li><strong>TCP 头部</strong>：20 字节（不含选项），含端口、序号、ACK、窗口等字段；</li><li><strong>UDP 头部</strong>：仅 8 字节（源端口、目的端口、长度、校验和）；</li><li><strong>CPU/带宽</strong>：TCP 因控制逻辑更耗资源；UDP 更轻量。</li></ul><h4 id="_4-编程模型" tabindex="-1">4. <strong>编程模型</strong> <a class="header-anchor" href="#_4-编程模型" aria-label="Permalink to “4. 编程模型”">​</a></h4><ul><li><strong>TCP</strong>：<code>socket</code> 编程中使用 <code>SOCK_STREAM</code>，读写像操作文件流；</li><li><strong>UDP</strong>：使用 <code>SOCK_DGRAM</code>，每次 <code>sendto</code>/<code>recvfrom</code> 操作一个完整数据报。</li></ul><hr><h3 id="💡-典型应用场景" tabindex="-1">💡 典型应用场景 <a class="header-anchor" href="#💡-典型应用场景" aria-label="Permalink to “💡 典型应用场景”">​</a></h3><table tabindex="0"><thead><tr><th>协议</th><th>应用示例</th></tr></thead><tbody><tr><td><strong>TCP</strong></td><td>网页浏览（HTTP/HTTPS）、SSH、FTP、数据库连接、API 调用</td></tr><tr><td><strong>UDP</strong></td><td>VoIP（如微信语音）、视频直播（RTMP/QUIC）、DNS 查询、NTP 时间同步、多人在线游戏</td></tr></tbody></table><blockquote><p>📌 <strong>现代趋势</strong>：</p><ul><li>HTTP/3 基于 <strong>QUIC（UDP 上实现可靠传输）</strong>，兼顾 TCP 的可靠性和 UDP 的低延迟；</li><li>实时音视频通常在 UDP 上自定义“部分可靠”策略（如丢帧可接受，但延迟必须低）。</li></ul></blockquote><hr><h3 id="✅-一句话总结-2" tabindex="-1">✅ 一句话总结 <a class="header-anchor" href="#✅-一句话总结-2" aria-label="Permalink to “✅ 一句话总结”">​</a></h3><blockquote><p><strong>TCP 是“打电话”——先拨通、确认听清、按顺序说话；<br> UDP 是“发短信”——发完就走，不管对方是否收到。</strong><br><strong>要可靠选 TCP，要速度选 UDP。</strong></p></blockquote><h2 id="简述tcp三次握手和四次挥手的过程" tabindex="-1">简述tcp三次握手和四次挥手的过程 <a class="header-anchor" href="#简述tcp三次握手和四次挥手的过程" aria-label="Permalink to “简述tcp三次握手和四次挥手的过程”">​</a></h2><p>TCP 的 <strong>三次握手（建立连接）</strong> 和 <strong>四次挥手（断开连接）</strong> 是保证可靠通信的核心机制，过程如下：</p><hr><h3 id="🔗-一、三次握手-three-way-handshake-——-建立连接" tabindex="-1">🔗 一、三次握手（Three-Way Handshake）—— 建立连接 <a class="header-anchor" href="#🔗-一、三次握手-three-way-handshake-——-建立连接" aria-label="Permalink to “🔗 一、三次握手（Three-Way Handshake）—— 建立连接”">​</a></h3><blockquote><p><strong>目的</strong>：同步双方初始序列号（ISN），确保双向通信能力。</p></blockquote><table tabindex="0"><thead><tr><th>步骤</th><th>发送方 → 接收方</th><th>关键字段</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>客户端 → 服务端</td><td><code>SYN=1</code>, <code>seq=x</code></td><td>客户端请求连接，发送初始序号 <code>x</code></td></tr><tr><td>2</td><td>服务端 → 客户端</td><td><code>SYN=1</code>, <code>ACK=1</code>, <code>seq=y</code>, <code>ack=x+1</code></td><td>服务端确认客户端请求，并发送自己的初始序号 <code>y</code></td></tr><tr><td>3</td><td>客户端 → 服务端</td><td><code>ACK=1</code>, <code>seq=x+1</code>, <code>ack=y+1</code></td><td>客户端确认服务端的序号，连接建立</td></tr></tbody></table><p>✅ <strong>结果</strong>：双方进入 <code>ESTABLISHED</code> 状态，可传输数据。<br> ⚠️ <strong>为什么不是两次？</strong> 防止历史重复连接请求突然到达服务器造成资源浪费（“已失效的请求”问题）。</p><hr><h3 id="🚪-二、四次挥手-four-way-wavehand-——-断开连接" tabindex="-1">🚪 二、四次挥手（Four-Way Wavehand）—— 断开连接 <a class="header-anchor" href="#🚪-二、四次挥手-four-way-wavehand-——-断开连接" aria-label="Permalink to “🚪 二、四次挥手（Four-Way Wavehand）—— 断开连接”">​</a></h3><blockquote><p><strong>原因</strong>：TCP 是<strong>全双工</strong>协议，需分别关闭两个方向的连接。</p></blockquote><table tabindex="0"><thead><tr><th>步骤</th><th>发送方 → 接收方</th><th>关键字段</th><th>状态变化</th></tr></thead><tbody><tr><td>1</td><td>主动方 → 被动方</td><td><code>FIN=1</code>, <code>seq=u</code></td><td>主动方进入 <code>FIN-WAIT-1</code></td></tr><tr><td>2</td><td>被动方 → 主动方</td><td><code>ACK=1</code>, <code>seq=v</code>, <code>ack=u+1</code></td><td>被动方进入 <code>CLOSE-WAIT</code><br>主动方进入 <code>FIN-WAIT-2</code></td></tr><tr><td>3</td><td>被动方 → 主动方</td><td><code>FIN=1</code>, <code>ACK=1</code>, <code>seq=w</code>, <code>ack=u+1</code></td><td>被动方进入 <code>LAST-ACK</code></td></tr><tr><td>4</td><td>主动方 → 被动方</td><td><code>ACK=1</code>, <code>seq=u+1</code>, <code>ack=w+1</code></td><td>主动方进入 <code>TIME-WAIT</code>（等待 2MSL 后关闭）<br>被动方收到后立即关闭</td></tr></tbody></table><p>✅ <strong>关键点</strong>：</p><ul><li><strong>主动关闭方</strong>最后会进入 <code>TIME-WAIT</code> 状态（持续 <strong>2 倍最大段生命周期 MSL</strong>，通常 30~120 秒）；</li><li><strong>目的</strong>： <ol><li>确保最后一个 ACK 能到达对方；</li><li>防止旧连接的重复数据包干扰新连接。</li></ol></li></ul><blockquote><p>💡 <strong>为什么挥手比握手多一次？</strong><br> 握手时服务端可将 <code>SYN</code> 和 <code>ACK</code> 合并发送（步骤2）；<br> 挥手时，被动方可能还有数据要发送，不能立即发 <code>FIN</code>，必须等应用层调用 <code>close()</code> 后才发送，因此 <strong>ACK 和 FIN 需分两次</strong>。</p></blockquote><hr><h3 id="✅-总结口诀" tabindex="-1">✅ 总结口诀 <a class="header-anchor" href="#✅-总结口诀" aria-label="Permalink to “✅ 总结口诀”">​</a></h3><blockquote><p><strong>握手三次建连接，同步序号防失效；<br> 挥手四次断双工，TIME-WAIT 保可靠。</strong></p></blockquote><h2 id="tcp-ip协议包含哪几层" tabindex="-1">tcp/ip协议包含哪几层 <a class="header-anchor" href="#tcp-ip协议包含哪几层" aria-label="Permalink to “tcp/ip协议包含哪几层”">​</a></h2><p>TCP/IP 协议栈是一个<strong>四层模型</strong>（实际应用中最常用的说法），它简化了 OSI 七层模型，更贴近互联网的实际实现。从上到下依次为：</p><hr><h3 id="✅-tcp-ip-四层模型" tabindex="-1">✅ TCP/IP 四层模型 <a class="header-anchor" href="#✅-tcp-ip-四层模型" aria-label="Permalink to “✅ TCP/IP 四层模型”">​</a></h3><table tabindex="0"><thead><tr><th>层级</th><th>名称</th><th>核心功能</th><th>常见协议/技术</th></tr></thead><tbody><tr><td><strong>4</strong></td><td><strong>应用层（Application Layer）</strong></td><td>提供应用程序网络接口，处理业务逻辑</td><td>HTTP、HTTPS、FTP、SMTP、DNS、WebSocket</td></tr><tr><td><strong>3</strong></td><td><strong>传输层（Transport Layer）</strong></td><td>端到端通信、可靠性、流量控制、多路复用</td><td><strong>TCP</strong>、<strong>UDP</strong>、SCTP</td></tr><tr><td><strong>2</strong></td><td><strong>网络层（Internet Layer）</strong></td><td>主机到主机的路由与寻址（逻辑地址）</td><td><strong>IP</strong>（IPv4/IPv6）、ICMP、ARP*、IGMP</td></tr><tr><td><strong>1</strong></td><td><strong>网络接口层（Link Layer）</strong></td><td>物理传输、MAC 地址、帧封装（硬件相关）</td><td>Ethernet、Wi-Fi（802.11）、PPP、ARP*</td></tr></tbody></table><blockquote><p>📌 注：ARP（地址解析协议）在功能上属于网络层，但实际封装在数据链路层帧中传输。</p></blockquote><hr><h3 id="🔍-各层详解" tabindex="-1">🔍 各层详解 <a class="header-anchor" href="#🔍-各层详解" aria-label="Permalink to “🔍 各层详解”">​</a></h3><h4 id="_1-应用层" tabindex="-1">1. <strong>应用层</strong> <a class="header-anchor" href="#_1-应用层" aria-label="Permalink to “1. 应用层”">​</a></h4><ul><li>用户直接交互的协议；</li><li>负责<strong>数据格式、会话管理、身份验证</strong>等；</li><li>例如：浏览器用 HTTP 请求网页，邮件客户端用 SMTP 发邮件。</li></ul><h4 id="_2-传输层" tabindex="-1">2. <strong>传输层</strong> <a class="header-anchor" href="#_2-传输层" aria-label="Permalink to “2. 传输层”">​</a></h4><ul><li>提供<strong>进程到进程</strong>的通信（通过端口号区分应用）；</li><li><strong>TCP</strong>：可靠、有序、面向连接；</li><li><strong>UDP</strong>：不可靠、低延迟、无连接。</li></ul><h4 id="_3-网络层-ip-层" tabindex="-1">3. <strong>网络层（IP 层）</strong> <a class="header-anchor" href="#_3-网络层-ip-层" aria-label="Permalink to “3. 网络层（IP 层）”">​</a></h4><ul><li>负责<strong>跨网络的数据包路由</strong>；</li><li>使用 <strong>IP 地址</strong>标识主机；</li><li><strong>IP 协议不保证可靠</strong>（丢包、乱序由上层如 TCP 处理）。</li></ul><h4 id="_4-网络接口层-链路层" tabindex="-1">4. <strong>网络接口层（链路层）</strong> <a class="header-anchor" href="#_4-网络接口层-链路层" aria-label="Permalink to “4. 网络接口层（链路层）”">​</a></h4><ul><li>负责<strong>同一物理网络内</strong>的数据帧传输；</li><li>使用 <strong>MAC 地址</strong>标识设备；</li><li>包括驱动程序、网卡、交换机等硬件交互。</li></ul><hr><h3 id="🔄-数据封装过程-发送端" tabindex="-1">🔄 数据封装过程（发送端） <a class="header-anchor" href="#🔄-数据封装过程-发送端" aria-label="Permalink to “🔄 数据封装过程（发送端）”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>应用层数据 </span></span>
<span class="line"><span>→ [加 TCP/UDP 头] → 传输层段（Segment/Datagram）  </span></span>
<span class="line"><span>→ [加 IP 头]      → 网络层包（Packet）  </span></span>
<span class="line"><span>→ [加 MAC 头+尾]  → 链路层帧（Frame）  </span></span>
<span class="line"><span>→ 物理信号（比特流）</span></span></code></pre></div><p>接收端则<strong>逐层解封装</strong>，从帧 → 包 → 段 → 应用数据。</p><hr><h3 id="⚠️-与-osi-七层模型对比" tabindex="-1">⚠️ 与 OSI 七层模型对比 <a class="header-anchor" href="#⚠️-与-osi-七层模型对比" aria-label="Permalink to “⚠️ 与 OSI 七层模型对比”">​</a></h3><table tabindex="0"><thead><tr><th>TCP/IP 四层</th><th>对应 OSI 层级</th></tr></thead><tbody><tr><td>应用层</td><td>应用层 + 表示层 + 会话层</td></tr><tr><td>传输层</td><td>传输层</td></tr><tr><td>网络层</td><td>网络层</td></tr><tr><td>网络接口层</td><td>数据链路层 + 物理层</td></tr></tbody></table><blockquote><p>💡 <strong>前端工程师重点掌握</strong>：</p><ul><li><strong>应用层</strong>（HTTP/WebSocket）</li><li><strong>传输层</strong>（TCP vs UDP）</li><li><strong>网络层</strong>（IP、DNS 解析）<br> 链路层通常由操作系统/硬件处理，无需深入。</li></ul></blockquote><hr><h3 id="✅-一句话总结-3" tabindex="-1">✅ 一句话总结 <a class="header-anchor" href="#✅-一句话总结-3" aria-label="Permalink to “✅ 一句话总结”">​</a></h3><blockquote><p><strong>TCP/IP 四层：应用传语义，传输管端口，网络定路由，链路走物理。</strong></p></blockquote>`,531)])])}const b=i(l,[["render",r]]);export{c as __pageData,b as default};
