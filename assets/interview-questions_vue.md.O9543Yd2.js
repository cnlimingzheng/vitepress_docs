import{_ as l,c as n,o as r,aj as s,j as i,a,t as o}from"./chunks/framework.CCLGfM8P.js";const E=JSON.parse('{"title":"VUE 面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview-questions/vue.md","filePath":"interview-questions/vue.md"}'),d={name:"interview-questions/vue.md"};function h(t,e,c,p,g,k){return r(),n("div",null,[e[4]||(e[4]=s(`<h1 id="vue-面试题" tabindex="-1">VUE 面试题 <a class="header-anchor" href="#vue-面试题" aria-label="Permalink to “VUE 面试题”">​</a></h1><h2 id="vue-的生命周期有哪些及每个生命周期做了什么" tabindex="-1">vue 的生命周期有哪些及每个生命周期做了什么？ <a class="header-anchor" href="#vue-的生命周期有哪些及每个生命周期做了什么" aria-label="Permalink to “vue 的生命周期有哪些及每个生命周期做了什么？”">​</a></h2><p>Vue 2 的生命周期（按执行顺序）：</p><ol><li><strong>beforeCreate</strong>：实例初始化后，数据观测和事件尚未设置。</li><li><strong>created</strong>：数据观测、计算属性、方法、事件回调已配置完成，但 DOM 未挂载。</li><li><strong>beforeMount</strong>：模板编译完成，虚拟 DOM 创建，但尚未挂载到页面。</li><li><strong>mounted</strong>：DOM 挂载完成，可访问真实 DOM，常用于操作 DOM 或发起请求。</li><li><strong>beforeUpdate</strong>：响应式数据变化，虚拟 DOM 重新渲染前调用。</li><li><strong>updated</strong>：DOM 更新完成，避免在此修改状态以防无限更新。</li><li><strong>beforeDestroy</strong>（Vue 2） / <strong>beforeUnmount</strong>（Vue 3）：实例销毁前，可清理定时器、取消订阅等。</li><li><strong>destroyed</strong>（Vue 2） / <strong>unmounted</strong>（Vue 3）：实例完全销毁，所有绑定和子组件均被移除。</li></ol><blockquote><p>Vue 3 使用 Composition API（如 <code>onMounted</code>）替代选项式写法，但生命周期逻辑一致。</p></blockquote><h2 id="vue-响应式原理是什么-vue3-的响应式有何不同" tabindex="-1">vue 响应式原理是什么？vue3 的响应式有何不同 <a class="header-anchor" href="#vue-响应式原理是什么-vue3-的响应式有何不同" aria-label="Permalink to “vue 响应式原理是什么？vue3 的响应式有何不同”">​</a></h2><p><strong>Vue 2 响应式原理：</strong><br> 基于 <code>Object.defineProperty</code>，递归遍历 data 对象属性，将其转换为 getter/setter。依赖收集通过 Dep 和 Watcher 实现，getter 收集依赖，setter 触发更新。</p><p><strong>Vue 3 响应式改进：</strong><br> 改用 <code>Proxy</code> + <code>Reflect</code>，支持动态增删属性、数组索引监听和深层嵌套对象的懒代理（通过 <code>reactive</code>）。同时引入 <code>effect</code> 和 <code>track/trigger</code> 机制，逻辑更清晰、性能更好，并支持 <code>ref</code> 包装基本类型。</p><h2 id="vue3-和-vue2-的区别" tabindex="-1">vue3 和 vue2 的区别 <a class="header-anchor" href="#vue3-和-vue2-的区别" aria-label="Permalink to “vue3 和 vue2 的区别”">​</a></h2><p>Vue 3 相比 Vue 2 的主要区别：</p><ol><li><p><strong>响应式系统</strong>：</p><ul><li>Vue 2：<code>Object.defineProperty</code>（不支持动态属性、数组索引监听受限）</li><li>Vue 3：<code>Proxy</code>（全面拦截，支持动态增删、嵌套懒代理）</li></ul></li><li><p><strong>Composition API</strong>：</p><ul><li>Vue 3 引入 <code>setup()</code>、<code>ref</code>、<code>reactive</code> 等，逻辑复用更灵活（替代 Mixins）</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>更小的 bundle（Tree-shaking 支持）</li><li>虚拟 DOM 重写，patch 更快</li><li>静态节点提升、事件侦听器缓存等编译优化</li></ul></li><li><p><strong>TypeScript 支持</strong>：</p><ul><li>Vue 3 源码用 TS 重写，类型推导更完善</li></ul></li><li><p><strong>Fragment / Teleport / Suspense</strong>：</p><ul><li>新增内置组件，提升开发能力</li></ul></li><li><p><strong>生命周期钩子变化</strong>：</p><ul><li><code>beforeDestroy</code> → <code>onBeforeUnmount</code>，<code>destroyed</code> → <code>onUnmounted</code>（Composition API 中）</li></ul></li><li><p><strong>全局 API 变更</strong>：</p><ul><li><code>Vue.component</code> → <code>app.component()</code>（应用实例化方式改变）</li></ul></li><li><p><strong>IE11 不再支持</strong>：</p><ul><li>Vue 3 仅支持现代浏览器（ES2015+）</li></ul></li></ol><h2 id="谈一谈对-mvvm-的理解" tabindex="-1">谈一谈对 MVVM 的理解？ <a class="header-anchor" href="#谈一谈对-mvvm-的理解" aria-label="Permalink to “谈一谈对 MVVM 的理解？”">​</a></h2><p>MVVM（Model-View-ViewModel）是一种前端架构模式，核心目标是<strong>分离视图（View）与业务逻辑（Model）</strong>，通过 ViewModel 实现自动同步：</p><ul><li><strong>Model</strong>：数据层，负责业务逻辑和数据处理（如 API、状态）</li><li><strong>View</strong>：UI 层，展示数据，响应用户交互</li><li><strong>ViewModel</strong>：连接 View 与 Model，通过<strong>双向数据绑定</strong>监听双方变化并同步</li></ul><p><strong>关键特点</strong>：</p><ul><li>View 与 Model 无直接引用，解耦</li><li>数据驱动视图，开发者聚焦数据流而非 DOM 操作</li><li>Vue、Angular 等框架是 MVVM 的典型实现（Vue 虽不严格双向绑定，但理念一致）</li></ul><h2 id="在-vue2-x-中如何检测数组的变化" tabindex="-1">在 Vue2.x 中如何检测数组的变化？ <a class="header-anchor" href="#在-vue2-x-中如何检测数组的变化" aria-label="Permalink to “在 Vue2.x 中如何检测数组的变化？”">​</a></h2><p>在 Vue 2.x 中，由于 <code>Object.defineProperty</code> 的限制，<strong>无法直接监听数组索引或长度的变化</strong>。Vue 通过 <strong>重写数组原型上的 7 个变异方法</strong> 来实现响应式更新：</p><p>这 7 个方法是：<br><code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>sort</code>, <code>reverse</code></p><p><strong>原理</strong>：</p><ul><li>Vue 在初始化时，将这些方法替换为自己的版本</li><li>调用时会触发依赖更新（通知 watcher 重新渲染）</li><li>同时对新增的元素进行响应式处理（如 <code>push</code> 进的对象）</li></ul><p><strong>局限</strong>：</p><ul><li>直接通过索引赋值（如 <code>arr[0] = val</code>）或修改 <code>length</code> 不会触发更新</li><li>需使用 <code>Vue.set(arr, index, val)</code> 或 <code>arr.splice(index, 1, val)</code> 替代</li></ul><blockquote><p>Vue 3 使用 <code>Proxy</code> 彻底解决了这个问题。</p></blockquote><h2 id="v-model-双向绑定的原理是什么" tabindex="-1">v-model 双向绑定的原理是什么？ <a class="header-anchor" href="#v-model-双向绑定的原理是什么" aria-label="Permalink to “v-model 双向绑定的原理是什么？”">​</a></h2><p><code>v-model</code> 是 Vue 提供的语法糖，用于在表单元素或组件上实现<strong>双向数据绑定</strong>。</p><h3 id="原理-以-vue-2-为例" tabindex="-1">原理（以 Vue 2 为例）： <a class="header-anchor" href="#原理-以-vue-2-为例" aria-label="Permalink to “原理（以 Vue 2 为例）：”">​</a></h3><ul><li><p><strong>在原生表单元素上</strong>（如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>）：<br><code>v-model=&quot;value&quot;</code> 等价于：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:value=&quot;value&quot; @input=&quot;value = $event.target.value&quot;</span></span></code></pre></div><ul><li><code>:value</code>：将 data 中的数据绑定到元素的 value 属性（<strong>数据 → 视图</strong>）</li><li><code>@input</code>：监听输入事件，更新 data（<strong>视图 → 数据</strong>）</li></ul></li><li><p><strong>在自定义组件上</strong>：<br> 默认展开为：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:value=&quot;value&quot; @input=&quot;value = $event&quot;</span></span></code></pre></div><p>组件需通过 <code>props</code> 接收 <code>value</code>，并通过 <code>$emit(&#39;input&#39;, newValue)</code> 触发更新。</p></li></ul><h3 id="vue-3-的变化" tabindex="-1">Vue 3 的变化： <a class="header-anchor" href="#vue-3-的变化" aria-label="Permalink to “Vue 3 的变化：”">​</a></h3><ul><li>支持自定义 <code>modelValue</code> 和 <code>update:modelValue</code> 事件（更灵活）</li><li>可通过 <code>v-model:foo</code> 实现多 v-model</li></ul><blockquote><p>本质：<strong>语法糖 + 单向数据流 + 事件通信</strong>，并非真正的“双向绑定”，而是<strong>数据与视图的同步机制</strong>。</p></blockquote><h2 id="vue2-x-和-vue3-x-渲染器的-diff-算法分别说一下" tabindex="-1">vue2.x 和 vue3.x 渲染器的 diff 算法分别说一下？ <a class="header-anchor" href="#vue2-x-和-vue3-x-渲染器的-diff-算法分别说一下" aria-label="Permalink to “vue2.x 和 vue3.x 渲染器的 diff 算法分别说一下？”">​</a></h2><p>Vue 2.x 和 Vue 3.x 的 diff 算法都基于 <strong>双端比较（双指针）策略</strong>，但 Vue 3 在细节和性能上做了显著优化。</p><hr><h3 id="vue-2-x-diff-算法-基于-snabbdom-改进" tabindex="-1"><strong>Vue 2.x Diff 算法（基于 Snabbdom 改进）</strong> <a class="header-anchor" href="#vue-2-x-diff-算法-基于-snabbdom-改进" aria-label="Permalink to “Vue 2.x Diff 算法（基于 Snabbdom 改进）”">​</a></h3><ul><li><strong>核心思想</strong>：同层比较，递归 patch。</li><li><strong>节点比较策略</strong>： <ul><li>先比对新旧节点是否为相同类型（<code>sameVnode</code>：key + tag）。</li><li>若不同，直接替换整个节点。</li><li>若相同，递归 patch 子节点。</li></ul></li><li><strong>子节点更新</strong>（列表 diff）： <ul><li>使用 <strong>双端指针（头头、尾尾、头尾、尾头）</strong> 四种情况尝试匹配。</li><li>若都未命中，则用 <strong>key 建立旧节点 map</strong>，遍历新节点查找对应旧节点。</li><li>无 key 时退化为就地复用（易出错）。</li></ul></li><li><strong>缺点</strong>： <ul><li>无法预判移动操作，可能产生多余 DOM 操作。</li><li>静态节点未被充分优化。</li></ul></li></ul><hr><h3 id="vue-3-x-diff-算法-重写-更高效" tabindex="-1"><strong>Vue 3.x Diff 算法（重写，更高效）</strong> <a class="header-anchor" href="#vue-3-x-diff-算法-重写-更高效" aria-label="Permalink to “Vue 3.x Diff 算法（重写，更高效）”">​</a></h3><ul><li><strong>核心改进</strong>：编译时 + 运行时协同优化。</li><li><strong>关键优化点</strong>： <ol><li><strong>静态提升（Static Hoisting）</strong>：<br> 静态节点在编译时提取，diff 时跳过。</li><li><strong>PatchFlags</strong>：<br> 编译时标记动态节点类型（如 TEXT、PROPS、CHILDREN），运行时只 diff 需要的部分。</li><li><strong>Block Tree</strong>：<br> 只追踪动态节点，形成“块”，大幅减少无用遍历。</li><li><strong>子节点 diff 更智能</strong>： <ul><li>引入 <strong>最长递增子序列（LIS）算法</strong>，最小化 DOM 移动。</li><li>减少不必要的移动和插入操作，提升列表更新性能。</li></ul></li></ol></li></ul><hr><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h3><table tabindex="0"><thead><tr><th>维度</th><th>Vue 2.x</th><th>Vue 3.x</th></tr></thead><tbody><tr><td>核心策略</td><td>双端指针 + key map</td><td>双端指针 + LIS + 编译时信息辅助</td></tr><tr><td>静态节点</td><td>每次都参与 diff</td><td>编译时跳过（静态提升）</td></tr><tr><td>动态检测</td><td>运行时全量判断</td><td>编译时标记（PatchFlags）</td></tr><tr><td>列表更新</td><td>可能多余移动</td><td>最小移动（LIS 优化）</td></tr><tr><td>性能</td><td>良好</td><td>显著提升（尤其大型列表/复杂模板）</td></tr></tbody></table><blockquote><p>Vue 3 的 diff 是 <strong>编译时与运行时协同优化</strong> 的典范，不仅更快，还更节省内存。</p></blockquote><h2 id="vue-组件通信方式有哪些及原理" tabindex="-1">vue 组件通信方式有哪些及原理 <a class="header-anchor" href="#vue-组件通信方式有哪些及原理" aria-label="Permalink to “vue 组件通信方式有哪些及原理”">​</a></h2><p>Vue 组件通信方式及原理（简洁概括）：</p><hr><h3 id="_1-props-emit-父子通信" tabindex="-1">1. <strong>Props / $emit</strong>（父子通信） <a class="header-anchor" href="#_1-props-emit-父子通信" aria-label="Permalink to “1. Props / $emit（父子通信）”">​</a></h3><ul><li><strong>原理</strong>：单向数据流 + 自定义事件 <ul><li>父 → 子：通过 <code>props</code> 传递数据</li><li>子 → 父：子组件 <code>$emit(&#39;event&#39;, data)</code>，父组件监听</li></ul></li></ul><h3 id="_2-parent-children-refs-直接访问实例" tabindex="-1">2. <strong>$parent / $children / $refs</strong>（直接访问实例） <a class="header-anchor" href="#_2-parent-children-refs-直接访问实例" aria-label="Permalink to “2. $parent / $children / $refs（直接访问实例）”">​</a></h3><ul><li><strong>原理</strong>：通过组件实例引用直接读写 <ul><li>不推荐，破坏组件封装性，耦合高</li></ul></li></ul><h3 id="_3-eventbus-on-emit-任意组件-vue-2" tabindex="-1">3. <strong>EventBus（$on / $emit）</strong>（任意组件，Vue 2） <a class="header-anchor" href="#_3-eventbus-on-emit-任意组件-vue-2" aria-label="Permalink to “3. EventBus（$on / $emit）（任意组件，Vue 2）”">​</a></h3><ul><li><strong>原理</strong>：创建空 Vue 实例作为中央事件总线 <ul><li><code>bus.$on(&#39;event&#39;, cb)</code> / <code>bus.$emit(&#39;event&#39;, data)</code></li><li><strong>Vue 3 已移除 <code>$on</code>/<code>$off</code>/<code>$once</code>，不支持</strong></li></ul></li></ul><h3 id="_4-vuex-pinia-全局状态管理" tabindex="-1">4. <strong>Vuex / Pinia</strong>（全局状态管理） <a class="header-anchor" href="#_4-vuex-pinia-全局状态管理" aria-label="Permalink to “4. Vuex / Pinia（全局状态管理）”">​</a></h3><ul><li><strong>原理</strong>：集中式 store，响应式状态 + 严格单向数据流 <ul><li>所有组件通过 <code>mapState</code>、<code>store.xxx</code> 或 <code>useStore()</code> 访问/修改状态</li></ul></li></ul><h3 id="_5-provide-inject-跨层级祖先-后代通信" tabindex="-1">5. <strong>provide / inject</strong>（跨层级祖先-后代通信） <a class="header-anchor" href="#_5-provide-inject-跨层级祖先-后代通信" aria-label="Permalink to “5. provide / inject（跨层级祖先-后代通信）”">​</a></h3><ul><li><strong>原理</strong>：祖先组件 <code>provide</code> 数据，后代组件 <code>inject</code> 注入 <ul><li>响应式需配合 <code>ref</code> 或 <code>reactive</code>（Vue 3 中自动保持响应性）</li></ul></li></ul><h3 id="_6-v-model-sync-语法糖-父子双向绑定" tabindex="-1">6. <strong>v-model / .sync（语法糖）</strong>（父子双向绑定） <a class="header-anchor" href="#_6-v-model-sync-语法糖-父子双向绑定" aria-label="Permalink to “6. v-model / .sync（语法糖）（父子双向绑定）”">​</a></h3><ul><li><strong>原理</strong>：<code>v-model</code> 是 <code>:value + @input</code> 的语法糖（Vue 2）；Vue 3 支持多 v-model <ul><li><code>.sync</code> 是 <code>:prop + @update:prop</code> 的语法糖（Vue 2，Vue 3 推荐用 v-model 替代）</li></ul></li></ul><h3 id="_7-attrs-listeners-透传属性-事件" tabindex="-1">7. <strong>$attrs / $listeners（透传属性/事件）</strong> <a class="header-anchor" href="#_7-attrs-listeners-透传属性-事件" aria-label="Permalink to “7. $attrs / $listeners（透传属性/事件）”">​</a></h3><ul><li><strong>原理</strong>： <ul><li><code>$attrs</code>：父组件传入但未被 props 声明的 attribute</li><li><code>$listeners</code>（Vue 2）：未被声明的事件监听器（Vue 3 合并到 <code>$attrs</code>）</li></ul></li></ul><hr><p>✅ <strong>最佳实践</strong>：</p><ul><li>简单场景：<code>props</code> / <code>$emit</code></li><li>跨多层：<code>provide/inject</code></li><li>全局共享：<code>Pinia</code>（推荐）或 <code>Vuex</code></li><li>避免滥用 <code>$parent</code>、EventBus（尤指 Vue 3）</li></ul><h2 id="vue-的路由实现-hash-路由和-history-路由实现原理说一下" tabindex="-1">Vue 的路由实现, hash 路由和 history 路由实现原理说一下 <a class="header-anchor" href="#vue-的路由实现-hash-路由和-history-路由实现原理说一下" aria-label="Permalink to “Vue 的路由实现, hash 路由和 history 路由实现原理说一下”">​</a></h2><p>Vue Router 支持两种路由模式：<strong>hash 模式</strong> 和 <strong>history 模式</strong>，核心区别在于 URL 形式和底层实现机制。</p><hr><h3 id="_1-hash-路由" tabindex="-1">1. <strong>Hash 路由</strong> <a class="header-anchor" href="#_1-hash-路由" aria-label="Permalink to “1. Hash 路由”">​</a></h3><ul><li><strong>URL 形式</strong>：<code>http://example.com/#/home</code></li><li><strong>原理</strong>： <ul><li>利用 <code>window.location.hash</code>（# 及其后内容）</li><li>监听 <code>hashchange</code> 事件，感知 URL 变化</li><li>页面不刷新（# 后内容不属于请求路径）</li></ul></li><li><strong>优点</strong>：兼容性好（IE8+），无需服务端配置</li><li><strong>缺点</strong>：URL 不美观，SEO 略差</li></ul><hr><h3 id="_2-history-路由" tabindex="-1">2. <strong>History 路由</strong> <a class="header-anchor" href="#_2-history-路由" aria-label="Permalink to “2. History 路由”">​</a></h3><ul><li><strong>URL 形式</strong>：<code>http://example.com/home</code></li><li><strong>原理</strong>： <ul><li>基于 HTML5 History API：<code>pushState()</code>、<code>replaceState()</code> 修改 URL（无刷新）</li><li>监听 <code>popstate</code> 事件响应浏览器前进/后退</li><li><strong>注意</strong>：<code>pushState/replaceState</code> 不会触发 <code>popstate</code>，需手动触发路由更新</li></ul></li><li><strong>优点</strong>：URL 简洁，更符合 Web 标准</li><li><strong>缺点</strong>：需服务端配合（所有路径 fallback 到 index.html），否则刷新 404</li></ul><hr><h3 id="vue-router-内部处理" tabindex="-1">Vue Router 内部处理 <a class="header-anchor" href="#vue-router-内部处理" aria-label="Permalink to “Vue Router 内部处理”">​</a></h3><ul><li>初始化时根据 mode 选择监听策略</li><li>维护一个路由映射表（path → component）</li><li>URL 变化时匹配路由，动态渲染对应组件</li></ul><blockquote><p>✅ <strong>选型建议</strong>：</p><ul><li>静态部署 / 无服务端控制 → 用 <strong>hash</strong></li><li>有服务端支持 / 追求体验 → 用 <strong>history</strong></li></ul></blockquote><h2 id="说一下-v-if-与-v-show-的区别" tabindex="-1">说一下 v-if 与 v-show 的区别 <a class="header-anchor" href="#说一下-v-if-与-v-show-的区别" aria-label="Permalink to “说一下 v-if 与 v-show 的区别”">​</a></h2><p><code>v-if</code> 与 <code>v-show</code> 都用于条件渲染，但机制和适用场景不同：</p><hr><h3 id="_1-渲染机制" tabindex="-1"><strong>1. 渲染机制</strong> <a class="header-anchor" href="#_1-渲染机制" aria-label="Permalink to “1. 渲染机制”">​</a></h3><ul><li><strong><code>v-if</code></strong>： <ul><li><strong>真正地销毁/重建</strong> DOM 节点</li><li>条件为 false 时，元素<strong>不存在于 DOM 中</strong></li></ul></li><li><strong><code>v-show</code></strong>： <ul><li>始终渲染 DOM，通过 <strong>CSS <code>display: none</code></strong> 控制显隐</li><li>元素始终存在于 DOM 中</li></ul></li></ul><hr><h3 id="_2-编译过程" tabindex="-1"><strong>2. 编译过程</strong> <a class="header-anchor" href="#_2-编译过程" aria-label="Permalink to “2. 编译过程”">​</a></h3><ul><li><code>v-if</code>：切换时触发组件的<strong>生命周期钩子</strong>（如 <code>mounted</code>/<code>destroyed</code>）</li><li><code>v-show</code>：不触发生命周期，仅切换样式</li></ul><hr><h3 id="_3-性能特点" tabindex="-1"><strong>3. 性能特点</strong> <a class="header-anchor" href="#_3-性能特点" aria-label="Permalink to “3. 性能特点”">​</a></h3><ul><li><strong><code>v-if</code></strong>： <ul><li>切换开销大（重复创建/销毁）</li><li>初始渲染开销小（条件假时不渲染）</li></ul></li><li><strong><code>v-show</code></strong>： <ul><li>初始渲染开销大（始终渲染）</li><li>切换开销小（仅改样式）</li></ul></li></ul><hr><h3 id="_4-使用建议" tabindex="-1"><strong>4. 使用建议</strong> <a class="header-anchor" href="#_4-使用建议" aria-label="Permalink to “4. 使用建议”">​</a></h3><ul><li><strong>频繁切换</strong> → 用 <code>v-show</code></li><li><strong>运行时条件很少改变</strong> → 用 <code>v-if</code></li><li><strong>需要初始不渲染（节省资源）</strong> → 用 <code>v-if</code></li></ul><blockquote><p>⚠️ <code>v-if</code> 可与 <code>v-else</code> / <code>v-else-if</code> 连用，<code>v-show</code> 不支持。</p></blockquote><h2 id="keep-alive-的常用属性有哪些及实现原理" tabindex="-1">keep-alive 的常用属性有哪些及实现原理 <a class="header-anchor" href="#keep-alive-的常用属性有哪些及实现原理" aria-label="Permalink to “keep-alive 的常用属性有哪些及实现原理”">​</a></h2><p><code>&lt;keep-alive&gt;</code> 是 Vue 的内置组件，用于<strong>缓存动态组件</strong>，避免重复创建/销毁。</p><hr><h3 id="常用属性" tabindex="-1"><strong>常用属性</strong> <a class="header-anchor" href="#常用属性" aria-label="Permalink to “常用属性”">​</a></h3><ol><li><strong><code>include</code></strong>：字符串或正则，指定<strong>哪些组件</strong>需要缓存（组件 name 匹配）</li><li><strong><code>exclude</code></strong>：字符串或正则，指定<strong>哪些组件不缓存</strong>（优先级高于 <code>include</code>）</li><li><strong><code>max</code></strong>：数字，最多缓存多少个组件实例（超出则按 LRU 淘汰）</li></ol><blockquote><p>组件必须有 <strong><code>name</code></strong> 才能被匹配（匿名组件无效）。</p></blockquote><hr><h3 id="实现原理-vue-2-3-核心一致" tabindex="-1"><strong>实现原理（Vue 2 / 3 核心一致）</strong> <a class="header-anchor" href="#实现原理-vue-2-3-核心一致" aria-label="Permalink to “实现原理（Vue 2 / 3 核心一致）”">​</a></h3><ol><li><p><strong>包裹动态组件</strong>时，<code>&lt;keep-alive&gt;</code> 不会渲染真实 DOM，而是：</p><ul><li><strong>首次激活</strong>：创建组件实例并缓存到内部对象（<code>cache</code>）</li><li><strong>切换出去</strong>：调用 <code>deactivated</code> 钩子，<strong>保留实例但移出 DOM</strong></li><li><strong>再次激活</strong>：从 <code>cache</code> 取出实例，调用 <code>activated</code> 钩子，重新插入 DOM</li></ul></li><li><p><strong>缓存管理</strong>：</p><ul><li>通过 <code>include</code>/<code>exclude</code> 控制是否缓存</li><li><code>max</code> 限制缓存数量，超限时移除<strong>最久未访问</strong>的实例（LRU 策略）</li></ul></li><li><p><strong>关键钩子</strong>：</p><ul><li><code>activated</code>：组件被激活时调用</li><li><code>deactivated</code>：组件被停用时调用</li></ul></li></ol><hr><h3 id="适用场景" tabindex="-1"><strong>适用场景</strong> <a class="header-anchor" href="#适用场景" aria-label="Permalink to “适用场景”">​</a></h3><ul><li>Tab 切换、列表详情页返回保持滚动位置等需<strong>保留状态</strong>的场景</li><li>避免高频切换组件的重复初始化开销</li></ul><blockquote><p>✅ 注意：<code>&lt;keep-alive&gt;</code> 只作用于<strong>直接子节点</strong>（如 <code>&lt;component :is=&quot;...&quot;&gt;</code> 或动态路由组件）。</p></blockquote><h2 id="nexttick-的作用是什么-他的实现原理是什么" tabindex="-1">nextTick 的作用是什么？他的实现原理是什么？ <a class="header-anchor" href="#nexttick-的作用是什么-他的实现原理是什么" aria-label="Permalink to “nextTick 的作用是什么？他的实现原理是什么？”">​</a></h2><h3 id="作用" tabindex="-1"><strong>作用</strong> <a class="header-anchor" href="#作用" aria-label="Permalink to “作用”">​</a></h3><p><code>Vue.nextTick</code>（或 <code>this.$nextTick</code>）用于<strong>在 DOM 更新完成后执行回调</strong>。<br> 因为 Vue 的数据更新是<strong>异步批量处理</strong>的，修改数据后 DOM 不会立即更新，<code>nextTick</code> 可确保拿到最新的 DOM 状态。</p><p>典型场景：</p><ul><li>修改数据后立即操作更新后的 DOM（如获取元素高度、聚焦 input）</li><li>在 <code>created</code> 中访问 <code>$el</code>（此时 DOM 尚未挂载）</li></ul><hr><h3 id="实现原理" tabindex="-1"><strong>实现原理</strong> <a class="header-anchor" href="#实现原理" aria-label="Permalink to “实现原理”">​</a></h3><p>利用 <strong>微任务（Microtask）优先于宏任务（Macrotask）</strong> 的特性，按以下优先级选择异步机制：</p><ol><li><strong>Promise.then</strong>（微任务，首选）</li><li><strong>MutationObserver</strong>（微任务，兼容旧版 Safari）</li><li><strong>setImmediate</strong>（宏任务，IE 特有）</li><li><strong>setTimeout(fn, 0)</strong>（兜底）</li></ol><blockquote><p>Vue 将所有 watcher 更新放入一个队列，在本轮事件循环末尾统一 flush（触发 DOM 更新），<code>nextTick</code> 的回调被安排在<strong>flush 之后执行</strong>，从而保证 DOM 已更新。</p></blockquote><hr><h3 id="vue-3-改进" tabindex="-1"><strong>Vue 3 改进</strong> <a class="header-anchor" href="#vue-3-改进" aria-label="Permalink to “Vue 3 改进”">​</a></h3><ul><li>使用 <code>Promise</code> + <code>queueMicrotask</code>（更标准的微任务 API）</li><li>更简洁、性能更好</li></ul><hr><p>✅ <strong>一句话总结</strong>：<br><code>nextTick</code> 是 Vue 异步更新机制的配套工具，通过微任务确保回调在 DOM 更新后执行。</p><h2 id="说一下-vue-ssr-的实现原理" tabindex="-1">说一下 Vue SSR 的实现原理 <a class="header-anchor" href="#说一下-vue-ssr-的实现原理" aria-label="Permalink to “说一下 Vue SSR 的实现原理”">​</a></h2><p>Vue SSR（Server-Side Rendering，服务端渲染）的核心目标是：<strong>在服务端生成 HTML 字符串，发送给客户端，实现首屏快速渲染和 SEO 友好</strong>。</p><hr><h3 id="实现原理-1" tabindex="-1"><strong>实现原理</strong> <a class="header-anchor" href="#实现原理-1" aria-label="Permalink to “实现原理”">​</a></h3><h4 id="_1-服务端渲染流程" tabindex="-1">1. <strong>服务端渲染流程</strong> <a class="header-anchor" href="#_1-服务端渲染流程" aria-label="Permalink to “1. 服务端渲染流程”">​</a></h4><ul><li>在 Node.js 环境中，使用 <code>vue-server-renderer</code> 的 <code>renderToString()</code> 方法：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建 Vue 应用实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> html</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(app);</span></span></code></pre></div></li><li>渲染器遍历组件树，同步执行组件的 <code>setup()</code> / <code>data()</code>、<code>computed</code> 等逻辑，<strong>生成完整的 HTML 字符串</strong>。</li><li>服务端将此 HTML 注入模板，返回给浏览器。</li></ul><h4 id="_2-客户端激活-hydration" tabindex="-1">2. <strong>客户端激活（Hydration）</strong> <a class="header-anchor" href="#_2-客户端激活-hydration" aria-label="Permalink to “2. 客户端激活（Hydration）”">​</a></h4><ul><li>浏览器加载 JS 后，Vue 在<strong>已有 DOM 上进行“激活”</strong>（hydrate），而非重新挂载。</li><li>Vue 对比服务端生成的 DOM 结构与客户端虚拟 DOM，<strong>复用节点并绑定事件监听器</strong>，使页面可交互。</li><li>要求：<strong>服务端与客户端渲染结果必须一致</strong>，否则会丢弃服务端 HTML 并重新渲染（警告）。</li></ul><h4 id="_3-数据预取-data-prefetching" tabindex="-1">3. <strong>数据预取（Data Prefetching）</strong> <a class="header-anchor" href="#_3-数据预取-data-prefetching" aria-label="Permalink to “3. 数据预取（Data Prefetching）”">​</a></h4><ul><li>组件可通过 <code>serverPrefetch()</code>（Vue 3）或自定义逻辑在服务端提前获取数据。</li><li>获取的数据需注入到 HTML 中（如 <code>window.__INITIAL_STATE__</code>），客户端直接复用，避免重复请求。</li></ul><h4 id="_4-路由与状态管理同构" tabindex="-1">4. <strong>路由与状态管理同构</strong> <a class="header-anchor" href="#_4-路由与状态管理同构" aria-label="Permalink to “4. 路由与状态管理同构”">​</a></h4><ul><li>路由（Vue Router）和状态（Pinia/Vuex）需在服务端和客户端<strong>共享同一份逻辑</strong>，确保一致性。</li></ul><hr><h3 id="关键依赖" tabindex="-1"><strong>关键依赖</strong> <a class="header-anchor" href="#关键依赖" aria-label="Permalink to “关键依赖”">​</a></h3><ul><li><code>vue-server-renderer</code>（Vue 2）或 <code>@vue/server-renderer</code>（Vue 3）</li><li>Node.js 服务（如 Express、Koa）动态渲染页面</li></ul><hr><h3 id="优点-vs-缺点" tabindex="-1"><strong>优点 vs 缺点</strong> <a class="header-anchor" href="#优点-vs-缺点" aria-label="Permalink to “优点 vs 缺点”">​</a></h3><table tabindex="0"><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首屏加载快（无需等 JS 执行）</td><td>服务端压力增大</td></tr><tr><td>SEO 友好</td><td>构建部署更复杂</td></tr><tr><td>更好的用户体验</td><td>仅支持可在 Node 环境运行的代码（无 window/document）</td></tr></tbody></table><hr><p>✅ <strong>适用场景</strong>：内容型网站（如新闻、电商详情页）、对 SEO 或首屏性能要求高的应用。</p><h2 id="vue-组件的-data-为什么必须是函数" tabindex="-1">Vue 组件的 data 为什么必须是函数 <a class="header-anchor" href="#vue-组件的-data-为什么必须是函数" aria-label="Permalink to “Vue 组件的 data 为什么必须是函数”">​</a></h2><p>Vue 组件的 <code>data</code> 必须是<strong>函数</strong>，是为了<strong>保证每个组件实例拥有独立的数据副本</strong>，避免多个实例间数据共享和相互污染。</p><hr><h3 id="原理" tabindex="-1"><strong>原理</strong> <a class="header-anchor" href="#原理" aria-label="Permalink to “原理”">​</a></h3><ul><li>如果 <code>data</code> 是对象（引用类型），所有实例会<strong>共享同一个对象引用</strong>。</li><li>当一个实例修改 <code>data</code> 中的属性，其他实例也会同步变化，导致状态混乱。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误：多个组件共用同一个 data 对象</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确：每次返回新对象，实例隔离</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="底层机制" tabindex="-1"><strong>底层机制</strong> <a class="header-anchor" href="#底层机制" aria-label="Permalink to “底层机制”">​</a></h3><ul><li>Vue 在初始化组件时，会调用 <code>data()</code> 函数，将其返回的对象通过 <code>reactive</code>（Vue 3）或 <code>Observer</code>（Vue 2）转为响应式。</li><li>每个实例调用一次 <code>data()</code>，获得<strong>独立的响应式对象</strong>。</li></ul><hr><h3 id="例外" tabindex="-1"><strong>例外</strong> <a class="header-anchor" href="#例外" aria-label="Permalink to “例外”">​</a></h3><ul><li><strong>根实例（new Vue）</strong> 的 <code>data</code> 可以是对象，因为根实例只有一个，不存在复用问题。</li></ul><hr><p>✅ <strong>一句话总结</strong>：<br> 函数确保组件多实例下的数据隔离，是 Vue 组件化设计的基础保障。</p><h2 id="说一下-vue-的-computed-的实现原理" tabindex="-1">说一下 Vue 的 computed 的实现原理 <a class="header-anchor" href="#说一下-vue-的-computed-的实现原理" aria-label="Permalink to “说一下 Vue 的 computed 的实现原理”">​</a></h2><p>Vue 的 <code>computed</code>（计算属性）基于<strong>响应式依赖收集 + 缓存机制</strong>实现，核心目标是：<strong>高效、自动地派生状态，并避免重复计算</strong>。</p><hr><h3 id="实现原理-以-vue-3-为例" tabindex="-1"><strong>实现原理（以 Vue 3 为例）</strong> <a class="header-anchor" href="#实现原理-以-vue-3-为例" aria-label="Permalink to “实现原理（以 Vue 3 为例）”">​</a></h3><h4 id="_1-创建-computedref" tabindex="-1">1. <strong>创建 ComputedRef</strong> <a class="header-anchor" href="#_1-创建-computedref" aria-label="Permalink to “1. 创建 ComputedRef”">​</a></h4><ul><li>调用 <code>computed(fn)</code> 时，内部创建一个 <code>ComputedRefImpl</code> 对象。</li><li>该对象包含： <ul><li><code>getter</code>：用户传入的计算函数</li><li><code>effect</code>：一个特殊的 <code>ReactiveEffect</code>（带调度器）</li><li><code>_value</code>：缓存计算结果</li><li><code>_dirty</code>：标记是否需要重新计算</li></ul></li></ul><h4 id="_2-依赖收集" tabindex="-1">2. <strong>依赖收集</strong> <a class="header-anchor" href="#_2-依赖收集" aria-label="Permalink to “2. 依赖收集”">​</a></h4><ul><li>首次读取 <code>computed</code> 值时，执行 <code>getter</code>。</li><li>在 <code>getter</code> 中访问的响应式数据（如 <code>reactive</code> 或 <code>ref</code>）会触发它们的 <code>get</code> 拦截。</li><li>此时，<code>computed</code> 的 <code>effect</code> 会被这些响应式数据的 <code>dep</code> 收集为依赖（即：数据 → computed）。</li></ul><h4 id="_3-缓存与惰性求值" tabindex="-1">3. <strong>缓存与惰性求值</strong> <a class="header-anchor" href="#_3-缓存与惰性求值" aria-label="Permalink to “3. 缓存与惰性求值”">​</a></h4><ul><li>计算结果缓存在 <code>_value</code>，<code>_dirty = false</code>。</li><li><strong>只要依赖未变化，再次访问直接返回缓存值</strong>，不执行 <code>getter</code>。</li></ul><h4 id="_4-依赖变更触发更新" tabindex="-1">4. <strong>依赖变更触发更新</strong> <a class="header-anchor" href="#_4-依赖变更触发更新" aria-label="Permalink to “4. 依赖变更触发更新”">​</a></h4><ul><li>当依赖的响应式数据被修改，会通知其所有依赖（包括 <code>computed</code> 的 <code>effect</code>）。</li><li><code>computed</code> 的 <code>effect.scheduler</code> 被调用，设置 <code>_dirty = true</code>，<strong>但不会立即重新计算</strong>。</li><li>下次读取 <code>computed</code> 时，发现 <code>_dirty === true</code>，才重新执行 <code>getter</code> 并更新缓存。</li></ul><hr><h3 id="与-watch-method-的区别" tabindex="-1"><strong>与 watch / method 的区别</strong> <a class="header-anchor" href="#与-watch-method-的区别" aria-label="Permalink to “与 watch / method 的区别”">​</a></h3><table tabindex="0"><thead><tr><th></th><th>缓存</th><th>自动依赖追踪</th><th>手动调用</th></tr></thead><tbody><tr><td>computed</td><td>✅</td><td>✅</td><td>❌（自动）</td></tr><tr><td>method</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>watch</td><td>❌</td><td>✅</td><td>❌（副作用）</td></tr></tbody></table><hr><p>✅ <strong>一句话总结</strong>：<br><code>computed</code> 通过响应式系统自动追踪依赖，结合惰性求值和缓存，实现高效、声明式的派生状态。</p><h2 id="说一下-vue-complier-的实现原理是什么样的" tabindex="-1">说一下 Vue complier 的实现原理是什么样的？ <a class="header-anchor" href="#说一下-vue-complier-的实现原理是什么样的" aria-label="Permalink to “说一下 Vue complier 的实现原理是什么样的？”">​</a></h2><p>Vue 的 <strong>Compiler（编译器）</strong> 负责将模板（template）编译成 <strong>可执行的渲染函数（render function）</strong>。其核心流程分为三步：<strong>解析（Parse）→ 优化（Optimize）→ 代码生成（Generate）</strong>。</p><hr><h3 id="_1-parse-解析" tabindex="-1">1. <strong>Parse（解析）</strong> <a class="header-anchor" href="#_1-parse-解析" aria-label="Permalink to “1. Parse（解析）”">​</a></h3>`,173)),i("ul",null,[i("li",null,[e[0]||(e[0]=i("strong",null,"输入",-1)),e[1]||(e[1]=a("：字符串形式的模板（如 ",-1)),i("code",null,"<div>"+o(t.msg)+"</div>",1),e[2]||(e[2]=a("）",-1))]),e[3]||(e[3]=s("<li><strong>输出</strong>：<strong>抽象语法树（AST）</strong></li><li><strong>过程</strong>： <ul><li>使用正则和状态机逐字符解析 HTML</li><li>构建包含标签、属性、指令、插值等信息的 AST 节点树</li><li>同时处理 <code>v-if</code>、<code>v-for</code>、<code>@click</code> 等 Vue 指令，标记到 AST 节点上</li></ul></li>",2))]),e[5]||(e[5]=s(`<hr><h3 id="_2-optimize-优化-—-vue-2-特有-vue-3-更深入" tabindex="-1">2. <strong>Optimize（优化）— Vue 2 特有，Vue 3 更深入</strong> <a class="header-anchor" href="#_2-optimize-优化-—-vue-2-特有-vue-3-更深入" aria-label="Permalink to “2. Optimize（优化）— Vue 2 特有，Vue 3 更深入”">​</a></h3><ul><li><strong>目的</strong>：提升运行时 diff 性能</li><li><strong>关键操作</strong>： <ul><li><strong>静态节点标记</strong>：标记永远不会变的节点（如纯文本、无绑定的元素）</li><li><strong>静态根节点提升</strong>：将静态子树提取到 render 函数外，避免重复创建 VNode</li></ul></li><li><strong>Vue 3 增强</strong>： <ul><li>引入 <strong>PatchFlags</strong>：在 AST 阶段就标记动态部分类型（TEXT、PROPS、CHILDREN 等）</li><li>构建 <strong>Block Tree</strong>：只追踪动态节点，大幅减少 diff 范围</li></ul></li></ul><hr><h3 id="_3-generate-代码生成" tabindex="-1">3. <strong>Generate（代码生成）</strong> <a class="header-anchor" href="#_3-generate-代码生成" aria-label="Permalink to “3. Generate（代码生成）”">​</a></h3><ul><li><strong>输入</strong>：优化后的 AST</li><li><strong>输出</strong>：<strong>render 函数的字符串代码</strong>（如 <code>with(this){return _c(&#39;div&#39;,[_v(_s(msg))])}</code>）</li><li><strong>过程</strong>： <ul><li>递归遍历 AST，生成对应 VNode 创建函数的调用代码（如 <code>_c</code>、<code>_v</code>、<code>_s</code>）</li><li>处理指令转换为 JavaScript 逻辑（如 <code>v-if</code> → 三元表达式，<code>v-for</code> → map 循环）</li><li>最终通过 <code>new Function(code)</code> 转为可执行函数</li></ul></li></ul><hr><h3 id="vue-2-vs-vue-3-编译器差异" tabindex="-1">Vue 2 vs Vue 3 编译器差异 <a class="header-anchor" href="#vue-2-vs-vue-3-编译器差异" aria-label="Permalink to “Vue 2 vs Vue 3 编译器差异”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td>静态提升</td><td>支持</td><td>更精细（配合 Block Tree）</td></tr><tr><td>动态检测</td><td>运行时全量判断</td><td><strong>编译时标记 PatchFlags</strong></td></tr><tr><td>编译目标</td><td>render 函数</td><td>render 函数 + Block + PatchFlags</td></tr><tr><td>编译位置</td><td>可运行时编译或预编译</td><td>推荐构建时预编译（运行时仅保留 core）</td></tr></tbody></table><hr><p>✅ <strong>一句话总结</strong>：<br> Vue Compiler 将模板转为高效 render 函数，通过 <strong>AST + 静态分析 + 编译时优化</strong>，实现运行时最小化开销。Vue 3 更进一步，让编译器与运行时深度协同，达成极致性能。</p><h2 id="vue-与-react-的区别是什么" tabindex="-1">Vue 与 React 的区别是什么？ <a class="header-anchor" href="#vue-与-react-的区别是什么" aria-label="Permalink to “Vue 与 React 的区别是什么？”">​</a></h2><p>Vue 与 React 的核心区别可概括为以下几点：</p><hr><h3 id="_1-设计理念" tabindex="-1">1. <strong>设计理念</strong> <a class="header-anchor" href="#_1-设计理念" aria-label="Permalink to “1. 设计理念”">​</a></h3><ul><li><strong>Vue</strong>：渐进式框架，提供<strong>完整的解决方案</strong>（模板、响应式、路由、状态管理等），约定优于配置。</li><li><strong>React</strong>：UI 库（非框架），强调<strong>灵活性与组合</strong>，生态由社区驱动（如路由用 React Router，状态用 Redux/Zustand）。</li></ul><hr><h3 id="_2-数据绑定" tabindex="-1">2. <strong>数据绑定</strong> <a class="header-anchor" href="#_2-数据绑定" aria-label="Permalink to “2. 数据绑定”">​</a></h3><ul><li><strong>Vue</strong>：<strong>响应式系统自动追踪依赖</strong>，数据变更自动更新视图（<code>ref</code>/<code>reactive</code> + <code>effect</code>）。</li><li><strong>React</strong>：<strong>状态不可变 + 手动触发更新</strong>（<code>useState</code>/<code>useReducer</code> + <code>setState</code>），依赖 <strong>re-render + diff</strong> 判断是否更新 DOM。</li></ul><hr><h3 id="_3-模板-vs-jsx" tabindex="-1">3. <strong>模板 vs JSX</strong> <a class="header-anchor" href="#_3-模板-vs-jsx" aria-label="Permalink to “3. 模板 vs JSX”">​</a></h3><ul><li><strong>Vue</strong>：默认使用<strong>基于 HTML 的模板语法</strong>，更贴近 Web 标准，学习成本低。</li><li><strong>React</strong>：使用 <strong>JSX</strong>（JavaScript + XML），逻辑与视图高度融合，表达力强但需熟悉 JS。</li></ul><hr><h3 id="_4-组件通信" tabindex="-1">4. <strong>组件通信</strong> <a class="header-anchor" href="#_4-组件通信" aria-label="Permalink to “4. 组件通信”">​</a></h3><ul><li><strong>Vue</strong>：父子通信（<code>props</code>/<code>$emit</code>）、跨层级（<code>provide/inject</code>）、全局（Pinia）。</li><li><strong>React</strong>：自上而下 <code>props</code>、Context API、状态提升，或借助第三方状态库。</li></ul><hr><h3 id="_5-更新机制" tabindex="-1">5. <strong>更新机制</strong> <a class="header-anchor" href="#_5-更新机制" aria-label="Permalink to “5. 更新机制”">​</a></h3><ul><li><strong>Vue</strong>：细粒度响应式，<strong>精准触发组件更新</strong>（仅依赖变更的组件 re-render）。</li><li><strong>React</strong>：父组件状态变更 → <strong>默认子组件全量 re-render</strong>（需 <code>memo</code>/<code>useCallback</code> 优化）。</li></ul><hr><h3 id="_6-生态系统-工具链" tabindex="-1">6. <strong>生态系统 &amp; 工具链</strong> <a class="header-anchor" href="#_6-生态系统-工具链" aria-label="Permalink to “6. 生态系统 &amp; 工具链”">​</a></h3><ul><li><strong>Vue</strong>：官方维护核心工具（Vue CLI、Vite、Vue Router、Pinia），一致性高。</li><li><strong>React</strong>：社区驱动，选择多但碎片化（Create React App、Vite、Next.js 等）。</li></ul><hr><h3 id="_7-typescript-支持" tabindex="-1">7. <strong>TypeScript 支持</strong> <a class="header-anchor" href="#_7-typescript-支持" aria-label="Permalink to “7. TypeScript 支持”">​</a></h3><ul><li><strong>Vue 3</strong>：源码用 TS 重写，类型推导优秀。</li><li><strong>React</strong>：TS 支持良好，但 JSX 类型有时较复杂。</li></ul><hr><p>✅ <strong>总结</strong>：</p><ul><li><strong>选 Vue</strong>：追求开发效率、快速上手、完整方案、模板友好。</li><li><strong>选 React</strong>：需要高度灵活、函数式思维、强大社区、构建复杂交互应用。</li></ul><blockquote><p>两者都在互相借鉴（如 Vue 3 Composition API 受 React Hooks 启发），核心差异在于<strong>响应式 vs 声明式渲染</strong>的哲学。</p></blockquote><h2 id="说一下-watch-与-computed-的区别是什么-以及他们的使用场景分别是什么" tabindex="-1">说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？ <a class="header-anchor" href="#说一下-watch-与-computed-的区别是什么-以及他们的使用场景分别是什么" aria-label="Permalink to “说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？”">​</a></h2><p><code>watch</code> 与 <code>computed</code> 都用于响应数据变化，但<strong>目的、机制和使用场景不同</strong>：</p><hr><h3 id="核心区别" tabindex="-1"><strong>核心区别</strong> <a class="header-anchor" href="#核心区别" aria-label="Permalink to “核心区别”">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th><code>computed</code></th><th><code>watch</code></th></tr></thead><tbody><tr><td><strong>用途</strong></td><td><strong>派生状态</strong>（计算得到新值）</td><td><strong>执行副作用</strong>（如请求、日志、操作 DOM）</td></tr><tr><td><strong>返回值</strong></td><td>✅ 有返回值，可直接在模板中使用</td><td>❌ 无返回值，用于执行逻辑</td></tr><tr><td><strong>缓存</strong></td><td>✅ 依赖不变时缓存结果，惰性求值</td><td>❌ 每次依赖变化都执行回调</td></tr><tr><td><strong>异步支持</strong></td><td>❌ 不支持（应是纯函数）</td><td>✅ 支持（可在回调中写 async/await）</td></tr><tr><td><strong>监听方式</strong></td><td>自动追踪依赖</td><td>显式指定监听源（ref / reactive / getter）</td></tr></tbody></table><hr><h3 id="使用场景" tabindex="-1"><strong>使用场景</strong> <a class="header-anchor" href="#使用场景" aria-label="Permalink to “使用场景”">​</a></h3><h4 id="✅-computed-适用" tabindex="-1">✅ <code>computed</code> 适用： <a class="header-anchor" href="#✅-computed-适用" aria-label="Permalink to “✅ computed 适用：”">​</a></h4><ul><li>模板中需要<strong>基于其他数据动态计算</strong>的值<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fullName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstName.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastName.value)</span></span></code></pre></div></li><li>多个地方复用同一逻辑，且<strong>无副作用</strong></li></ul><blockquote><p><strong>原则</strong>：只要能用 <code>computed</code>，就不用 <code>watch</code>。</p></blockquote><h4 id="✅-watch-适用" tabindex="-1">✅ <code>watch</code> 适用： <a class="header-anchor" href="#✅-watch-适用" aria-label="Permalink to “✅ watch 适用：”">​</a></h4><ul><li>数据变化时<strong>触发异步操作</strong>（如 API 请求）</li><li>执行<strong>复杂逻辑或副作用</strong>（如打点、修改非响应式变量）</li><li>监听<strong>特定路径</strong>或<strong>深度监听对象</strong></li><li>需要<strong>访问新旧值</strong>进行对比</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(searchText, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newVal) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h3 id="一句话总结" tabindex="-1"><strong>一句话总结</strong> <a class="header-anchor" href="#一句话总结" aria-label="Permalink to “一句话总结”">​</a></h3><ul><li><strong><code>computed</code> 是“算出来的值”</strong> —— 用于声明式派生数据。</li><li><strong><code>watch</code> 是“做事情”</strong> —— 用于响应式地执行副作用。</li></ul><h2 id="说一下你知道的-vue-修饰符都有哪些" tabindex="-1">说一下你知道的 vue 修饰符都有哪些？ <a class="header-anchor" href="#说一下你知道的-vue-修饰符都有哪些" aria-label="Permalink to “说一下你知道的 vue 修饰符都有哪些？”">​</a></h2><p>Vue 的修饰符（Modifiers）用于<strong>增强指令或事件的行为</strong>，主要分为以下几类：</p><hr><h3 id="一、事件修饰符-用于-v-on" tabindex="-1">一、<strong>事件修饰符</strong>（用于 <code>v-on</code> / <code>@</code>） <a class="header-anchor" href="#一、事件修饰符-用于-v-on" aria-label="Permalink to “一、事件修饰符（用于 v-on / @）”">​</a></h3><p>作用：处理 DOM 事件细节，避免在方法中写原生 API。</p><table tabindex="0"><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td><code>.stop</code></td><td>阻止事件冒泡（<code>event.stopPropagation()</code>）</td></tr><tr><td><code>.prevent</code></td><td>阻止默认行为（<code>event.preventDefault()</code>）</td></tr><tr><td><code>.capture</code></td><td>使用事件捕获模式（从外到内）</td></tr><tr><td><code>.self</code></td><td>只当事件在元素自身触发时才处理</td></tr><tr><td><code>.once</code></td><td>事件只触发一次</td></tr><tr><td><code>.passive</code></td><td>提升滚动性能（告诉浏览器不调用 <code>preventDefault</code>）</td></tr></tbody></table><blockquote><p>示例：<code>@click.stop.prevent=&quot;handler&quot;</code></p></blockquote><hr><h3 id="二、按键修饰符-用于键盘事件" tabindex="-1">二、<strong>按键修饰符</strong>（用于键盘事件） <a class="header-anchor" href="#二、按键修饰符-用于键盘事件" aria-label="Permalink to “二、按键修饰符（用于键盘事件）”">​</a></h3><p>作用：监听特定按键。</p><table tabindex="0"><thead><tr><th>修饰符</th><th>对应键</th></tr></thead><tbody><tr><td><code>.enter</code></td><td>Enter</td></tr><tr><td><code>.tab</code></td><td>Tab</td></tr><tr><td><code>.delete</code></td><td>Delete / Backspace</td></tr><tr><td><code>.esc</code></td><td>Esc</td></tr><tr><td><code>.space</code></td><td>Space</td></tr><tr><td><code>.up</code> / <code>.down</code> / <code>.left</code> / <code>.right</code></td><td>方向键</td></tr></tbody></table><blockquote><p>也可自定义：<code>Vue.config.keyCodes.f1 = 112</code></p></blockquote><hr><h3 id="三、系统修饰键-组合键" tabindex="-1">三、<strong>系统修饰键</strong>（组合键） <a class="header-anchor" href="#三、系统修饰键-组合键" aria-label="Permalink to “三、系统修饰键（组合键）”">​</a></h3><p>用于监听 <code>Ctrl</code>、<code>Alt</code>、<code>Shift</code>、<code>Meta</code>（Cmd/Win）：</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><blockquote><p>示例：<code>@keyup.ctrl.enter=&quot;submit&quot;</code></p></blockquote><hr><h3 id="四、v-model-修饰符" tabindex="-1">四、<strong><code>v-model</code> 修饰符</strong> <a class="header-anchor" href="#四、v-model-修饰符" aria-label="Permalink to “四、v-model 修饰符”">​</a></h3><p>用于表单双向绑定：</p><table tabindex="0"><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td><code>.lazy</code></td><td>转为 <code>change</code> 事件更新（而非 <code>input</code>）</td></tr><tr><td><code>.number</code></td><td>自动将输入转为 <code>Number</code> 类型</td></tr><tr><td><code>.trim</code></td><td>自动去除首尾空格</td></tr></tbody></table><blockquote><p>示例：<code>&lt;input v-model.trim.number=&quot;age&quot;&gt;</code></p></blockquote><hr><h3 id="五、其他" tabindex="-1">五、<strong>其他</strong> <a class="header-anchor" href="#五、其他" aria-label="Permalink to “五、其他”">​</a></h3><ul><li><strong><code>.sync</code></strong>（Vue 2）：语法糖，实现父子组件双向绑定（Vue 3 推荐用 <code>v-model</code> 替代）</li><li><strong>动态参数修饰符</strong>（Vue 3）：如 <code>@[eventModifier]</code></li></ul><hr><p>✅ <strong>总结</strong>：<br> 修饰符让 Vue 代码更简洁、语义化，避免在逻辑中混入 DOM 操作细节。合理使用可提升可读性与开发效率。</p><h2 id="如何实现-vue-项目中的性能优化" tabindex="-1">如何实现 vue 项目中的性能优化？ <a class="header-anchor" href="#如何实现-vue-项目中的性能优化" aria-label="Permalink to “如何实现 vue 项目中的性能优化？”">​</a></h2><p>Vue 项目性能优化可从 <strong>编译构建、运行时、加载、渲染</strong> 四个维度入手，核心目标：<strong>减少体积、加快加载、提升渲染效率、降低内存消耗</strong>。</p><hr><h3 id="一、构建与加载优化" tabindex="-1">一、<strong>构建与加载优化</strong> <a class="header-anchor" href="#一、构建与加载优化" aria-label="Permalink to “一、构建与加载优化”">​</a></h3><ol><li><p><strong>代码分割（Code Splitting）</strong></p><ul><li>路由懒加载：<code>defineAsyncComponent(() =&gt; import(&#39;./Foo.vue&#39;))</code></li><li>组件懒加载：<code>import()</code> + <code>Suspense</code>（Vue 3）</li></ul></li><li><p><strong>Tree Shaking</strong></p><ul><li>使用 ES Module，按需引入（如 <code>lodash-es</code>、UI 库组件）</li></ul></li><li><p><strong>压缩与缓存</strong></p><ul><li>启用 Gzip/Brotli 压缩</li><li>静态资源加 hash，配置强缓存</li></ul></li><li><p><strong>CDN 加速</strong></p><ul><li>将 Vue、Axios 等公共库通过 CDN 引入（外链 + externals）</li></ul></li></ol><hr><h3 id="二、运行时优化" tabindex="-1">二、<strong>运行时优化</strong> <a class="header-anchor" href="#二、运行时优化" aria-label="Permalink to “二、运行时优化”">​</a></h3><ol><li><p><strong>避免响应式数据冗余</strong></p><ul><li>不将大数组/对象直接放入 <code>reactive</code>，用 <code>Object.freeze()</code> 或转为普通对象</li><li>非响应式数据用 <code>markRaw</code></li></ul></li><li><p><strong>合理使用 <code>v-if</code> / <code>v-show</code></strong></p><ul><li>频繁切换用 <code>v-show</code>，条件稳定用 <code>v-if</code></li></ul></li><li><p><strong>列表优化</strong></p><ul><li>必须加唯一 <code>key</code>（避免用 index）</li><li>超长列表用虚拟滚动（如 <code>vue-virtual-scroller</code>）</li></ul></li><li><p><strong>计算属性 vs 方法</strong></p><ul><li>可缓存结果用 <code>computed</code>，避免模板中写方法调用</li></ul></li><li><p><strong>避免在模板中写复杂表达式</strong></p><ul><li>提前在 <code>computed</code> 中处理</li></ul></li></ol><hr><h3 id="三、渲染优化" tabindex="-1">三、<strong>渲染优化</strong> <a class="header-anchor" href="#三、渲染优化" aria-label="Permalink to “三、渲染优化”">​</a></h3><ol><li><p><strong>组件拆分</strong></p><ul><li>拆分大组件，利用 Vue 的细粒度更新机制（仅更新依赖变更的组件）</li></ul></li><li><p><strong>使用 <code>keep-alive</code> 缓存组件</strong></p><ul><li>Tab、详情页等场景避免重复创建</li></ul></li><li><p><strong>避免不必要的 watcher</strong></p><ul><li><code>watch</code> 指定 <code>deep: false</code>（默认）</li><li>复杂对象监听用 getter 函数代替 <code>deep: true</code></li></ul></li><li><p><strong>Vue 3 特有优化</strong></p><ul><li>利用 <code>PatchFlags</code> 和 <code>Block Tree</code>（无需手动干预，但需正确使用模板）</li><li>使用 <code>v-memo</code>（Vue 3.2+）缓存子树</li></ul></li></ol><hr><h3 id="四、网络与资源优化" tabindex="-1">四、<strong>网络与资源优化</strong> <a class="header-anchor" href="#四、网络与资源优化" aria-label="Permalink to “四、网络与资源优化”">​</a></h3><ol><li><p><strong>图片/静态资源优化</strong></p><ul><li>图片压缩、WebP 格式、懒加载（<code>&lt;img loading=&quot;lazy&quot;&gt;</code>）</li><li>字体子集化</li></ul></li><li><p><strong>接口优化</strong></p><ul><li>数据分页、懒加载</li><li>合并请求、启用缓存（ETag / Cache-Control）</li></ul></li></ol><hr><h3 id="五、开发体验辅助" tabindex="-1">五、<strong>开发体验辅助</strong> <a class="header-anchor" href="#五、开发体验辅助" aria-label="Permalink to “五、开发体验辅助”">​</a></h3><ul><li>使用 <strong>Vue DevTools</strong> 分析组件层级、响应式依赖</li><li>使用 <strong>Webpack Bundle Analyzer</strong> 查看包体积</li><li>开启 <strong>生产环境模式</strong>（移除警告、压缩代码）</li></ul><hr><p>✅ <strong>总结口诀</strong>：<br><strong>懒加载、少响应、缓计算、精渲染、压体积、快网络</strong>。<br> 优先做 <strong>高 ROI 优化</strong>（如路由懒加载、图片压缩），再深入细节。</p><h2 id="vue-中的-spa-应用如何优化首屏加载速度" tabindex="-1">vue 中的 spa 应用如何优化首屏加载速度? <a class="header-anchor" href="#vue-中的-spa-应用如何优化首屏加载速度" aria-label="Permalink to “vue 中的 spa 应用如何优化首屏加载速度?”">​</a></h2><p>Vue 的 SPA（单页应用）首屏加载慢通常因<strong>打包体积大、资源未按需加载、服务端无优化</strong>。优化核心思路：<strong>减体积、快加载、早渲染</strong>。</p><hr><h3 id="一、代码层面优化" tabindex="-1">一、<strong>代码层面优化</strong> <a class="header-anchor" href="#一、代码层面优化" aria-label="Permalink to “一、代码层面优化”">​</a></h3><h4 id="_1-路由懒加载-关键" tabindex="-1">1. <strong>路由懒加载（关键！）</strong> <a class="header-anchor" href="#_1-路由懒加载-关键" aria-label="Permalink to “1. 路由懒加载（关键！）”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 3 + Vite / Webpack</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Home</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@/views/Home.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li>按路由拆分 chunk，首屏只加载必要代码</li></ul><h4 id="_2-组件懒加载" tabindex="-1">2. <strong>组件懒加载</strong> <a class="header-anchor" href="#_2-组件懒加载" aria-label="Permalink to “2. 组件懒加载”">​</a></h4><ul><li>非首屏组件（如弹窗、图表）用 <code>defineAsyncComponent</code> 延迟加载</li></ul><h4 id="_3-tree-shaking-按需引入" tabindex="-1">3. <strong>Tree Shaking + 按需引入</strong> <a class="header-anchor" href="#_3-tree-shaking-按需引入" aria-label="Permalink to “3. Tree Shaking + 按需引入”">​</a></h4><ul><li>UI 库（如 Element Plus、Ant Design Vue）启用按需导入</li><li>工具库用 <code>lodash-es</code> 替代 <code>lodash</code></li></ul><h4 id="_4-移除无用依赖-代码" tabindex="-1">4. <strong>移除无用依赖/代码</strong> <a class="header-anchor" href="#_4-移除无用依赖-代码" aria-label="Permalink to “4. 移除无用依赖/代码”">​</a></h4><ul><li>使用 <code>webpack-bundle-analyzer</code> 分析包体积</li><li>删除未使用的插件、polyfill（如 IE 兼容）</li></ul><hr><h3 id="二、构建与部署优化" tabindex="-1">二、<strong>构建与部署优化</strong> <a class="header-anchor" href="#二、构建与部署优化" aria-label="Permalink to “二、构建与部署优化”">​</a></h3><h4 id="_1-开启-gzip-brotli-压缩" tabindex="-1">1. <strong>开启 Gzip / Brotli 压缩</strong> <a class="header-anchor" href="#_1-开启-gzip-brotli-压缩" aria-label="Permalink to “1. 开启 Gzip / Brotli 压缩”">​</a></h4><ul><li>Nginx / CDN 配置压缩，可减少 70%+ 体积</li></ul><h4 id="_2-静态资源-cdn-加速" tabindex="-1">2. <strong>静态资源 CDN 加速</strong> <a class="header-anchor" href="#_2-静态资源-cdn-加速" aria-label="Permalink to “2. 静态资源 CDN 加速”">​</a></h4><ul><li>将 JS/CSS/图片部署到 CDN，提升下载速度</li></ul><h4 id="_3-预加载关键资源" tabindex="-1">3. <strong>预加载关键资源</strong> <a class="header-anchor" href="#_3-预加载关键资源" aria-label="Permalink to “3. 预加载关键资源”">​</a></h4><ul><li>使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 加载首屏关键 chunk</li><li>或通过 Webpack 的 <code>prefetch</code> / <code>preload</code>（谨慎使用）</li></ul><h4 id="_4-splitchunks-合理分包" tabindex="-1">4. <strong>SplitChunks 合理分包</strong> <a class="header-anchor" href="#_4-splitchunks-合理分包" aria-label="Permalink to “4. SplitChunks 合理分包”">​</a></h4><ul><li>避免 vendor 过大，将第三方库（如 Vue、Axios）单独抽离并长期缓存</li></ul><hr><h3 id="三、渲染体验优化" tabindex="-1">三、<strong>渲染体验优化</strong> <a class="header-anchor" href="#三、渲染体验优化" aria-label="Permalink to “三、渲染体验优化”">​</a></h3><h4 id="_1-骨架屏-skeleton-screen" tabindex="-1">1. <strong>骨架屏（Skeleton Screen）</strong> <a class="header-anchor" href="#_1-骨架屏-skeleton-screen" aria-label="Permalink to “1. 骨架屏（Skeleton Screen）”">​</a></h4><ul><li>首屏 HTML 内联简单骨架，提升感知速度</li><li>工具：<code>vue-skeleton-webpack-plugin</code>（Vue 2）或手写</li></ul><h4 id="_2-ssr-ssg-终极方案" tabindex="-1">2. <strong>SSR / SSG（终极方案）</strong> <a class="header-anchor" href="#_2-ssr-ssg-终极方案" aria-label="Permalink to “2. SSR / SSG（终极方案）”">​</a></h4><ul><li><strong>SSR</strong>（Nuxt.js / 自建）：服务端直出 HTML，首屏内容立即可见</li><li><strong>SSG</strong>（如 VitePress、Nuxt Content）：构建时生成静态 HTML，兼顾 SEO 与速度</li></ul><blockquote><p>若无法上 SSR，至少保证<strong>首屏关键数据预加载</strong>（在 <code>main.js</code> 前发起 API 请求）</p></blockquote><hr><h3 id="四、其他技巧" tabindex="-1">四、<strong>其他技巧</strong> <a class="header-anchor" href="#四、其他技巧" aria-label="Permalink to “四、其他技巧”">​</a></h3><ul><li><strong>字体优化</strong>：字体子集化 + <code>font-display: swap</code></li><li><strong>图片优化</strong>：WebP 格式 + 懒加载 + 适当压缩</li><li><strong>缓存策略</strong>：JS/CSS 文件加 hash，配置强缓存（Cache-Control: max-age=31536000）</li></ul><hr><p>✅ <strong>优先级建议</strong>：</p><ol><li>路由懒加载 ✅</li><li>Gzip + CDN ✅</li><li>包体积分析 &amp; 精简 ❗</li><li>骨架屏（提升体验）</li><li>条件允许上 SSR/SSG（效果最显著）</li></ol><blockquote><p>首屏加载 ≠ 白屏时间，<strong>让用户“感觉快”同样重要</strong>。</p></blockquote><h2 id="vue-中的-key-的作用是什么" tabindex="-1">Vue 中的 Key 的作用是什么？ <a class="header-anchor" href="#vue-中的-key-的作用是什么" aria-label="Permalink to “Vue 中的 Key 的作用是什么？”">​</a></h2><p>Vue 中的 <code>key</code> 是<strong>虚拟 DOM 节点的唯一标识</strong>，核心作用是：<strong>帮助 Vue 的 diff 算法高效、准确地复用和更新 DOM 元素</strong>。</p><hr><h3 id="一、核心作用" tabindex="-1">一、核心作用 <a class="header-anchor" href="#一、核心作用" aria-label="Permalink to “一、核心作用”">​</a></h3><h4 id="_1-精准识别节点身份" tabindex="-1">1. <strong>精准识别节点身份</strong> <a class="header-anchor" href="#_1-精准识别节点身份" aria-label="Permalink to “1. 精准识别节点身份”">​</a></h4><ul><li>默认 diff 策略（无 key）：就地复用（in-place patch），按位置更新</li><li>有 <code>key</code>：通过 key 建立新旧节点映射，<strong>跨位置复用真实 DOM</strong></li></ul><blockquote><p>✅ 避免因列表顺序变化导致不必要的 DOM 创建/销毁</p></blockquote><h4 id="_2-触发组件重建" tabindex="-1">2. <strong>触发组件重建</strong> <a class="header-anchor" href="#_2-触发组件重建" aria-label="Permalink to “2. 触发组件重建”">​</a></h4><ul><li>当 <code>key</code> 变化时，Vue 会<strong>销毁旧组件实例并创建新实例</strong></li><li>用于强制重新渲染（如表单重置、切换同类型组件）</li></ul><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentView</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentViewId</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><hr><h3 id="二、典型场景" tabindex="-1">二、典型场景 <a class="header-anchor" href="#二、典型场景" aria-label="Permalink to “二、典型场景”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>无 key 的问题</th><th>有 key 的优势</th></tr></thead><tbody><tr><td>列表渲染（<code>v-for</code>）</td><td>顺序变更时状态错乱（如输入框内容错位）</td><td>正确复用/移动 DOM，保持组件状态</td></tr><tr><td>动态组件切换</td><td>组件缓存，状态残留</td><td>强制重建，干净初始化</td></tr></tbody></table><hr><h3 id="三、注意事项" tabindex="-1">三、注意事项 <a class="header-anchor" href="#三、注意事项" aria-label="Permalink to “三、注意事项”">​</a></h3><ul><li><strong>必须唯一且稳定</strong>：避免用 <code>index</code>（插入/删除会导致 key 错位）</li><li><strong>不要随意变更</strong>：除非需要强制重建</li><li><strong>仅在 v-for 或动态组件中必要</strong>：静态元素无需加 key</li></ul><hr><p>✅ <strong>一句话总结</strong>：<br><code>key</code> 是 Vue diff 算法的“身份证”，确保 DOM 更新<strong>准确、高效、状态一致</strong>。</p><h2 id="组件中写-name-选项有哪些好处" tabindex="-1">组件中写 name 选项有哪些好处 <a class="header-anchor" href="#组件中写-name-选项有哪些好处" aria-label="Permalink to “组件中写 name 选项有哪些好处”">​</a></h2><p>在 Vue 组件中定义 <code>name</code> 选项主要有以下好处：</p><hr><h3 id="_1-支持-keep-alive-缓存" tabindex="-1">1. <strong>支持 <code>&lt;keep-alive&gt;</code> 缓存</strong> <a class="header-anchor" href="#_1-支持-keep-alive-缓存" aria-label="Permalink to “1. 支持 &lt;keep-alive&gt; 缓存”">​</a></h3><ul><li><code>keep-alive</code> 的 <code>include</code> / <code>exclude</code> 属性通过组件的 <code>name</code> 进行匹配</li><li>若未显式声明 <code>name</code>，则无法被精准缓存或排除</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;UserProfile&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;UserProfile&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;component :is=&quot;currentComp&quot; /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><hr><h3 id="_2-调试工具友好-devtools" tabindex="-1">2. <strong>调试工具友好（DevTools）</strong> <a class="header-anchor" href="#_2-调试工具友好-devtools" aria-label="Permalink to “2. 调试工具友好（DevTools）”">​</a></h3><ul><li>Vue DevTools 中会显示组件的 <code>name</code>，便于识别组件树结构</li><li>匿名组件显示为 <code>&lt;Anonymous&gt;</code>，不利于调试</li></ul><hr><h3 id="_3-递归组件自引用" tabindex="-1">3. <strong>递归组件自引用</strong> <a class="header-anchor" href="#_3-递归组件自引用" aria-label="Permalink to “3. 递归组件自引用”">​</a></h3><ul><li>递归组件需通过 <code>name</code> 在模板中调用自身（否则无法解析）</li></ul><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- TreeItem.vue --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {{ item.name }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">tree-item</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.children</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child.id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">child</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TreeItem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 必须！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;item&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><hr><h3 id="_4-动态组件与错误边界-vue-3" tabindex="-1">4. <strong>动态组件与错误边界（Vue 3）</strong> <a class="header-anchor" href="#_4-动态组件与错误边界-vue-3" aria-label="Permalink to “4. 动态组件与错误边界（Vue 3）”">​</a></h3><ul><li>在 <code>errorCaptured</code> 等生命周期中可通过 <code>name</code> 识别出错组件</li><li>动态导入时可用于日志、监控等场景</li></ul><hr><h3 id="_5-代码可读性与维护性" tabindex="-1">5. <strong>代码可读性与维护性</strong> <a class="header-anchor" href="#_5-代码可读性与维护性" aria-label="Permalink to “5. 代码可读性与维护性”">​</a></h3><ul><li>显式命名提升组件语义，便于团队协作和代码搜索</li></ul><hr><p>✅ <strong>总结</strong>：<br><code>name</code> 虽非强制，但在 <strong>缓存、调试、递归、工具链集成</strong> 等场景至关重要，<strong>建议所有组件都显式声明 <code>name</code></strong>。</p><h2 id="说一下-ref-的作用是什么" tabindex="-1">说一下 ref 的作用是什么？ <a class="header-anchor" href="#说一下-ref-的作用是什么" aria-label="Permalink to “说一下 ref 的作用是什么？”">​</a></h2><p><code>ref</code> 在 Vue 中主要有两个作用，分别用于 <strong>访问 DOM 元素 / 子组件实例</strong> 和 <strong>创建响应式基本类型数据</strong>（Vue 3 Composition API）。</p><hr><h3 id="一、在模板中-获取-dom-或子组件引用" tabindex="-1">一、<strong>在模板中：获取 DOM 或子组件引用</strong> <a class="header-anchor" href="#一、在模板中-获取-dom-或子组件引用" aria-label="Permalink to “一、在模板中：获取 DOM 或子组件引用”">​</a></h3><ul><li>通过 <code>ref=&quot;xxx&quot;</code> 标记元素或组件</li><li>在逻辑中通过 <code>this.$refs.xxx</code>（Vue 2）或 <code>xxx.value</code>（Vue 3 setup）访问</li></ul><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;inputEl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref, onMounted } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputEl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  inputEl.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 聚焦输入框</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><blockquote><p>✅ 适用于：操作焦点、获取尺寸、调用子组件方法等</p></blockquote><hr><h3 id="二、在逻辑中-vue-3-创建响应式基本类型" tabindex="-1">二、<strong>在逻辑中（Vue 3）：创建响应式基本类型</strong> <a class="header-anchor" href="#二、在逻辑中-vue-3-创建响应式基本类型" aria-label="Permalink to “二、在逻辑中（Vue 3）：创建响应式基本类型”">​</a></h3><ul><li><code>ref()</code> 将原始值（如 number、string）包装成<strong>响应式对象</strong></li><li>访问/修改需通过 <code>.value</code>（模板中自动解包）</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 响应式更新</span></span></code></pre></div><blockquote><p>✅ 解决了 Vue 2 中 <code>data</code> 无法直接响应基本类型的限制</p></blockquote><hr><h3 id="三、与-reactive-的区别" tabindex="-1">三、<strong>与 reactive 的区别</strong> <a class="header-anchor" href="#三、与-reactive-的区别" aria-label="Permalink to “三、与 reactive 的区别”">​</a></h3><table tabindex="0"><thead><tr><th></th><th><code>ref</code></th><th><code>reactive</code></th></tr></thead><tbody><tr><td>类型</td><td>适用于<strong>基本类型 &amp; 对象</strong></td><td>仅适用于<strong>对象/数组</strong></td></tr><tr><td>使用方式</td><td><code>.value</code>（逻辑中）</td><td>直接属性访问</td></tr><tr><td>模板</td><td>自动解包</td><td>无需处理</td></tr></tbody></table><blockquote><p>实际上，<code>ref</code> 内部对对象会调用 <code>reactive</code> 包裹</p></blockquote><hr><p>✅ <strong>一句话总结</strong>：<br><code>ref</code> 既是 <strong>DOM/组件的“桥梁”</strong>，也是 <strong>基本类型响应式的“容器”</strong>，是 Vue 3 Composition API 的核心工具之一。</p><h2 id="你的接口请求一般放在哪个生命周期中-为什么要这样做" tabindex="-1">你的接口请求一般放在哪个生命周期中？为什么要这样做？ <a class="header-anchor" href="#你的接口请求一般放在哪个生命周期中-为什么要这样做" aria-label="Permalink to “你的接口请求一般放在哪个生命周期中？为什么要这样做？”">​</a></h2><p>在 Vue 中，<strong>接口请求通常放在 <code>mounted</code>（Vue 2）或 <code>onMounted</code>（Vue 3）中</strong>，但在实际项目中更推荐 <strong>根据数据依赖和场景灵活选择</strong>。以下是详细说明：</p><hr><h3 id="✅-常规做法-mounted-onmounted" tabindex="-1">✅ <strong>常规做法：<code>mounted</code> / <code>onMounted</code></strong> <a class="header-anchor" href="#✅-常规做法-mounted-onmounted" aria-label="Permalink to “✅ 常规做法：mounted / onMounted”">​</a></h3><ul><li><strong>原因</strong>： <ul><li>此时组件已挂载，DOM 可用（如需操作 DOM）</li><li>避免在 <code>created</code> 中请求后立即因路由跳转等导致无意义渲染</li></ul></li><li><strong>适用场景</strong>：<br> 页面初始化数据、不需要 SSR 的普通数据加载</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h3 id="⚠️-但更优实践-根据需求选择" tabindex="-1">⚠️ <strong>但更优实践：根据需求选择</strong> <a class="header-anchor" href="#⚠️-但更优实践-根据需求选择" aria-label="Permalink to “⚠️ 但更优实践：根据需求选择”">​</a></h3><h4 id="_1-需要服务端渲染-ssr-→-放在-serverprefetch-vue-3-或路由级预取" tabindex="-1">1. <strong>需要服务端渲染（SSR）？ → 放在 <code>serverPrefetch</code>（Vue 3）或路由级预取</strong> <a class="header-anchor" href="#_1-需要服务端渲染-ssr-→-放在-serverprefetch-vue-3-或路由级预取" aria-label="Permalink to “1. 需要服务端渲染（SSR）？ → 放在 serverPrefetch（Vue 3）或路由级预取”">​</a></h4><ul><li><code>mounted</code> 在服务端不执行，SSR 无法获取数据</li><li>Vue 3 提供 <code>serverPrefetch</code> 钩子，支持服务端数据预取</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> serverPrefetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchFromAPI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_2-依赖响应式数据-如-route-params、props-→-用-watch" tabindex="-1">2. <strong>依赖响应式数据（如 route params、props）？ → 用 <code>watch</code></strong> <a class="header-anchor" href="#_2-依赖响应式数据-如-route-params、props-→-用-watch" aria-label="Permalink to “2. 依赖响应式数据（如 route params、props）？ → 用 watch”">​</a></h4><ul><li>若请求参数来自 <code>props</code> 或 <code>$route</code>，应在 <code>watch</code> 中监听变化后请求</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> route.params.id, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, { immediate: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><h4 id="_3-组合式函数封装-→-在-setup-顶层直接调用-配合-onmounted-或自动触发" tabindex="-1">3. <strong>组合式函数封装？ → 在 <code>setup()</code> 顶层直接调用（配合 <code>onMounted</code> 或自动触发）</strong> <a class="header-anchor" href="#_3-组合式函数封装-→-在-setup-顶层直接调用-配合-onmounted-或自动触发" aria-label="Permalink to “3. 组合式函数封装？ → 在 setup() 顶层直接调用（配合 onMounted 或自动触发）”">​</a></h4><ul><li>使用 <code>useXxx</code> 组合函数时，常在内部处理请求时机</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useUser.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> load</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* fetch */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(load); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或由外部控制</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { user, load };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="❌-为什么不放-created" tabindex="-1">❌ <strong>为什么不放 <code>created</code>？</strong> <a class="header-anchor" href="#❌-为什么不放-created" aria-label="Permalink to “❌ 为什么不放 created？”">​</a></h3><ul><li>虽然 <code>created</code> 更早，但： <ul><li>SSR 场景下可行，但客户端仍需重复请求（除非注入状态）</li><li>若组件很快被销毁（如路由切换），会造成无效请求</li><li>一般无 DOM 操作需求时，<code>created</code> 和 <code>mounted</code> 差异不大，但 <code>mounted</code> 语义更清晰（“挂载后加载”）</li></ul></li></ul><hr><h3 id="✅-最佳实践总结" tabindex="-1">✅ <strong>最佳实践总结</strong> <a class="header-anchor" href="#✅-最佳实践总结" aria-label="Permalink to “✅ 最佳实践总结”">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐位置</th></tr></thead><tbody><tr><td>普通页面初始化数据</td><td><code>onMounted</code></td></tr><tr><td>依赖 props / route 参数</td><td><code>watch(..., { immediate: true })</code></td></tr><tr><td>需要 SSR 支持</td><td><code>serverPrefetch</code> + 客户端激活复用</td></tr><tr><td>封装可复用逻辑</td><td>组合式函数内部管理生命周期</td></tr></tbody></table><blockquote><p><strong>核心原则</strong>：<strong>在确保必要且有效的时机发起请求，避免浪费资源，兼顾 SSR 与用户体验。</strong></p></blockquote><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to “”">​</a></h2>`,220))])}const b=l(d,[["render",h]]);export{E as __pageData,b as default};
